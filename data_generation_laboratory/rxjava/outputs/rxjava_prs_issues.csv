Issue_NumberPR_NumberIssue_TitleIssue_BodyIssue_CommentsPR_TitlePR_BodyPR_CommentsPR_Author_NamePR_Author_UsernamePR_Closed_Date
210.0230Intermittent OperationTake$UnitTest.testUnsubscribeAfterTake test failure"```
rx.operators.OperationTake$UnitTest > testUnsubscribeAfterTake FAILED
    org.mockito.exceptions.verification.WantedButNotInvoked:
    Wanted but not invoked:
    subscription.unsubscribe();
    -> at rx.operators.OperationTake$UnitTest.testUnsubscribeAfterTake(OperationTake.java:253)
    Actually, there were zero interactions with this mock.
        at rx.operators.OperationTake$UnitTest.testUnsubscribeAfterTake(OperationTake.java:253)
```""```
22:42:25.806 [DEBUG] [TestEventLogger]
22:42:25.808 [DEBUG] [TestEventLogger] rx.operators.OperationTake$UnitTest > testUnsubscribeAfterTake STARTED
22:42:25.808 [DEBUG] [TestEventLogger]
22:42:25.809 [DEBUG] [TestEventLogger] rx.operators.OperationTake$UnitTest > testUnsubscribeAfterTake STANDARD_OUT
22:42:25.809 [DEBUG] [TestEventLogger]     TestObservable subscribed to ...
22:42:25.808 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: output()]]
22:42:25.809 [DEBUG] [TestEventLogger]     starting TestObservable thread
22:42:25.815 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: output()]]
22:42:25.816 [DEBUG] [TestEventLogger]     running TestObservable thread
22:42:25.816 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: output()]]
22:42:25.822 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: output()]]
22:42:25.822 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: output()]]
22:42:25.823 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: output()]]
22:42:25.823 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: output()]]
22:42:25.822 [DEBUG] [TestEventLogger]     TestObservable onNext: one
22:42:25.824 [DEBUG] [TestEventLogger]     TestObservable onNext: two
22:42:25.830 [DEBUG] [TestEventLogger]     TestObservable onNext: three
22:42:25.831 [DEBUG] [TestEventLogger]     done starting TestObservable thread
22:42:25.831 [DEBUG] [TestEventLogger]     TestObservable thread finished
22:42:25.836 [QUIET] [system.out] 22:42:25.836 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 3f00e622-9121-4171-ae82-b025e097f81b, payload: [MethodInvocation method: processTestClass()]]
22:42:25.841 [QUIET] [system.out] 22:42:25.841 [DEBUG] [org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor] Executing test rx.operators.OperationTakeLast$UnitTest
22:42:25.861 [QUIET] [system.out] 22:42:25.861 [DEBUG
22:42:25.866 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: failure()]]
22:42:25.866 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: completed()]]
22:42:25.867 [QUIET] [system.out] ] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 3f00e622-9121-4171-ae82-b025e097f81b, payload: [MethodInvocation method: processTestClass()]]
22:42:25.868 [QUIET] [system.out] 22:42:25.867 [DEBUG] [org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor] Executing test rx.operators.OperationToObservableFuture$UnitTest
22:42:25.872 [DEBUG] [TestEventLogger]
22:42:25.872 [DEBUG] [TestEventLogger] rx.operators.OperationTake$UnitTest > testUnsubscribeAfterTake FAILED
22:42:25.876 [DEBUG] [TestEventLogger] org.mockito.exceptions.verification.WantedButNotInvoked:
22:42:25.877 [DEBUG] [TestEventLogger]     Wanted but not invoked:
22:42:25.881 [DEBUG] [TestEventLogger] subscription.unsubscribe();
22:42:25.881 [DEBUG] [TestEventLogger]     -> at rx.operators.OperationTake$UnitTest.testUnsubscribeAfterTake(OperationTake.java:285)
22:42:25.887 [DEBUG] [TestEventLogger]     Actually, there were zero interactions with this mock.
22:42:25.888 [DEBUG] [TestEventLogger]         at rx.operators.OperationTake$UnitTest.testUnsubscribeAfterTake(OperationTake.java:285)
22:42:25.901 [DEBUG] [TestEventLogger]         at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
22:42:25.902 [DEBUG] [TestEventLogger]         at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
22:42:25.906 [DEBUG] [TestEventLogger]         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
22:42:25.907 [DEBUG] [TestEventLogger]         at java.lang.reflect.Method.invoke(Method.java:597)
22:42:25.907 [DEBUG] [TestEventLogger]         at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)
22:42:25.907 [DEBUG] [TestEventLogger]         at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
22:42:25.907 [DEBUG] [TestEventLogger]         at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)
22:42:25.908 [DEBUG] [TestEventLogger]         at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
22:42:25.908 [DEBUG] [TestEventLogger]         at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)
22:42:25.909 [DEBUG] [TestEventLogger]         at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)
22:42:25.909 [DEBUG] [TestEventLogger]         at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)
22:42:25.909 [DEBUG] [TestEventLogger]         at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)
22:42:25.909 [DEBUG] [TestEventLogger]         at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)
22:42:25.909 [DEBUG] [TestEventLogger]         at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)
22:42:25.910 [DEBUG] [TestEventLogger]         at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)
22:42:25.910 [DEBUG] [TestEventLogger]         at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)
22:42:25.910 [DEBUG] [TestEventLogger]         at org.junit.runners.ParentRunner.run(ParentRunner.java:300)
22:42:25.910 [DEBUG] [TestEventLogger]         at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:55)
22:42:25.910 [DEBUG] [TestEventLogger]         at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:42)
22:42:25.911 [DEBUG] [TestEventLogger]         at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:75)
22:42:25.911 [DEBUG] [TestEventLogger]         at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:49)
22:42:25.911 [DEBUG] [TestEventLogger]         at sun.reflect.GeneratedMethodAccessor11.invoke(Unknown Source)
22:42:25.911 [DEBUG] [TestEventLogger]         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
22:42:25.912 [DEBUG] [TestEventLogger]         at java.lang.reflect.Method.invoke(Method.java:597)
22:42:25.912 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
22:42:25.912 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
22:42:25.912 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
22:42:25.912 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
22:42:25.913 [DEBUG] [TestEventLogger]         at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
22:42:25.913 [DEBUG] [TestEventLogger]         at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:103)
22:42:25.913 [DEBUG] [TestEventLogger]         at sun.reflect.GeneratedMethodAccessor10.invoke(Unknown Source)
22:42:25.913 [DEBUG] [TestEventLogger]         at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
22:42:25.913 [DEBUG] [TestEventLogger]         at java.lang.reflect.Method.invoke(Method.java:597)
22:42:25.922 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
22:42:25.922 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
22:42:25.923 [DEBUG] [TestEventLogger]         at org.gradle.messaging.remote.internal.TypeCastDispatch.dispatch(TypeCastDispatch.java:30)
22:42:25.924 [DEBUG] [TestEventLogger]         at org.gradle.messaging.remote.internal.WorkerProtocol.handleIncoming(WorkerProtocol.java:53)
22:42:25.924 [DEBUG] [TestEventLogger]         at org.gradle.messaging.remote.internal.WorkerProtocol.handleIncoming(WorkerProtocol.java:31)
22:42:25.927 [DEBUG] [TestEventLogger]         at org.gradle.messaging.remote.internal.ProtocolStack$ProtocolStage.handleIncoming(ProtocolStack.java:167)
22:42:25.928 [DEBUG] [TestEventLogger]         at org.gradle.messaging.remote.internal.ProtocolStack$BottomStage.handleIncoming(ProtocolStack.java:277)
22:42:25.928 [DEBUG] [TestEventLogger]         at org.gradle.messaging.remote.internal.ProtocolStack$BottomConnection$1.run(ProtocolStack.java:299)
22:42:25.929 [DEBUG] [TestEventLogger]         at org.gradle.messaging.remote.internal.ProtocolStack$ExecuteRunnable.dispatch(ProtocolStack.java:120)
22:42:25.929 [DEBUG] [TestEventLogger]         at org.gradle.messaging.remote.internal.ProtocolStack$ExecuteRunnable.dispatch(ProtocolStack.java:116)
22:42:25.930 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.AsyncDispatch.dispatchMessages(AsyncDispatch.java:132)
22:42:25.930 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.AsyncDispatch.access$000(AsyncDispatch.java:33)
22:42:25.930 [DEBUG] [TestEventLogger]         at org.gradle.messaging.dispatch.AsyncDispatch$1.run(AsyncDispatch.java:72)
22:42:25.934 [DEBUG] [TestEventLogger]         at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:66)
22:42:25.934 [DEBUG] [TestEventLogger]         at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:895)
22:42:25.935 [DEBUG] [TestEventLogger]         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:918)
22:42:25.935 [DEBUG] [TestEventLogger]         at java.lang.Thread.run(Thread.java:680)
22:42:25.868 [DEBUG] [org.gradle.messaging.remote.internal.WorkerProtocol] Dispatching request to worker: [Request consumer: 6004969e-021a-4e9f-968d-dfc84b2f583c, payload: [MethodInvocation method: completed()]]
22:42:25.940 [DEBUG] [TestEventLogger]
```
 =||= I'll be investigating further.
 =||= Hmm, hopefully just a bad test implementation involving thread.sleep instead of using join or CountDownLatch.

If you don't beat me to it I'll eventually look at this.
 =||= The problem is the TestObservable sequence makes its last onNext() notification before TakeWhile<T>.call() can stuff the ItemObserver's subscription into the AtomicObservableSubscription.
 =||= In other words, I think the `verify(s, times(1)).unsubscribe();` assertion is an invalid test.

I do think there should be a `verify(aObserver, times(1)).onCompleted();` assertion in that test.
 =||= One possibility would be to have `AtomicObservableSubscription.wrap()` unsubscribe its parameter if `AtomicObservableSubscription.unsubscribe()` had been previously called. That would require a single guard around both `unsubscribed` and `actualSubscription`.
 =||= Perhaps the `Runnable()` inside `TestObservable.subscribe()` should sleep or wait on a latch before generating output.

The Thread-within-subcribe() pattern is used in a lot of unit tests and this problem probably needs to be fixed in all of them. I am seeing intermittent failures in other tests, it's just that this particular one is what shows up most frequently.

By the way, I hate the Tests-as-Inner-Classes pattern as it means I can't run the tests from within the IntelliJ IDE.
 =||= Running tests in IntelliJ for a selected package ...

![running-tests-in-intellij](https://f.cloud.github.com/assets/813492/315596/d0351b6c-97ec-11e2-81e4-468e0c68f1f5.png)
 =||= If I try to run an individual test or tests for a given class, it craps out with:

```
Exception in thread ""main"" java.lang.NoClassDefFoundError: junit/textui/ResultPrinter
    at java.lang.Class.forName0(Native Method)
    at java.lang.Class.forName(Class.java:171)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:113)
Caused by: java.lang.ClassNotFoundException: junit.textui.ResultPrinter
    at java.net.URLClassLoader$1.run(URLClassLoader.java:202)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:190)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:306)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:247)
    ... 3 more
```

Which makes debugging a failing test difficult.
 =||= So fix the classpath :-) It can't find JUnit which suggests IntelliJ has a bug since it can run it from the package but not the individual test level. I was able to replicate your issue and then fix it by changing the the Module Settings -> Dependencies -> Scope from 'Provided' to 'Compile'. Apparently the test runner knows to include 'Provided' when run at the package level but not at the individual test level. I found a bunch of chatter on Google about the issue as well without any clear resolution. This is an issue for any dependency which is 'Provided' which is most of them on the language adaptor side of things.

Perhaps the Gradle build file 'idea' task could be tweaked to work around this issue so it sets IntelliJ up differently: https://github.com/Netflix/RxJava/blob/master/rxjava-core/build.gradle#L28 

Another example but from a language adaptor:

https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/build.gradle#L41

Note how 'Provided' is used for the language dependencies: https://github.com/Netflix/RxJava/blob/master/language-adaptors/rxjava-groovy/build.gradle#L10

Screenshot of running a single test:

![Screen Shot 2013-03-28 at 10 33 20 PM](https://f.cloud.github.com/assets/813492/316659/c934a5e0-9831-11e2-84fc-75af955d3e5a.png)
 =||= I'm also getting random test failures when I run tests from CLI. These are (at least) the tests that are failing randomly: 

rx.operators.OperationConcat$UnitTest > testConcatUnsubscribe FAILED
    org.mockito.exceptions.verification.NeverWantedButInvoked at OperationConcat.java:222

rx.operators.OperationTake$UnitTest > testUnsubscribeAfterTake FAILED
    org.mockito.exceptions.verification.WantedButNotInvoked at OperationTake.java:243

rx.operators.OperationTakeWhile$UnitTest > testUnsubscribeAfterTake FAILED
    org.mockito.exceptions.verification.WantedButNotInvoked at OperationTakeWhile.java:311

rx.plugins.RxJavaPlugins$UnitTest > testObservableExecutionHookViaProperty FAILED
    java.lang.AssertionError at RxJavaPlugins.java:211

rx.plugins.RxJavaPlugins$UnitTest > testObservableExecutionHookDefaultImpl FAILED
    java.lang.AssertionError at RxJavaPlugins.java:195

To me it looks like a threading problem. I'll take a closer look after I get my environment set up. 

**Here's the setup I'm using:**

Gradle 1.5

Gradle build time: Wednesday, March 27, 2013 1:51:06 PM UTC
Groovy: 1.8.6
Ant: Apache Ant(TM) version 1.8.4 compiled on May 22 2012
Ivy: 2.2.0
JVM: 1.7.0_17 (Oracle Corporation 23.7-b01)
OS: Mac OS X 10.7.5 x86_64
 =||= Fixed by #230
 =||= "An unsubscribed AtomicObservableSubscription.wrap() unsubscribes its argumentFixes #210John Gardiner Myersjohngmyers04/16/13, 08:16:22 PM
320.0422JRuby examples don't work (JRuby picks the wrong overloaded method)"The JRuby adapter doesn't work because JRuby can't figure out which overloaded `Observable#subscribe` method to pick. It ends up picking `Observable#subscribe(Map<String, Object>)`, which raises an error because the argument doesn't respond right:

``` ruby
require 'rxjava-core-0.10.0.jar'
require 'rxjava-jruby-0.10.0.jar'

observable = Java::Rx::Observable.toObservable(['one', 'two', 'three'])
observable.take(2).subscribe(lambda { |x| puts x })
```

the code above prints the following errors in JRuby 1.7.4:

```
% ruby rxjava.rb
rxjava.rb:6 warning: ambiguous Java methods found, using subscribe(java.util.Map)
onNext
Observable.java:278:in `subscribe': java.lang.RuntimeException: 'onNext' key must contain an implementation
    from NativeMethodAccessorImpl.java:-2:in `invoke0'
    from NativeMethodAccessorImpl.java:57:in `invoke'
    from DelegatingMethodAccessorImpl.java:43:in `invoke'
    from Method.java:601:in `invoke'
    from JavaMethod.java:455:in `invokeDirectWithExceptionHandling'
    from JavaMethod.java:316:in `invokeDirect'
    from InstanceMethodInvoker.java:61:in `call'
    from MethodHandle.java:599:in `invokeWithArguments'
    from InvocationLinker.java:153:in `invocationFallback'
    from rxjava.rb:5:in `__file__'
    from rxjava.rb:-1:in `load'
    from Ruby.java:807:in `runScript'
    from Ruby.java:800:in `runScript'
    from Ruby.java:669:in `runNormally'
    from Ruby.java:518:in `runFromMain'
    from Main.java:390:in `doRunFromMain'
    from Main.java:279:in `internalRun'
    from Main.java:221:in `run'
    from Main.java:201:in `main'
```

in JRuby 1.6.8 it prints a less verbose version of the same error.

Notice the line which reads ""onNext"". That's actually the `puts` from `lambda { |x| puts x }` in action. JRuby wraps the lambda in something that looks like a `Map`, and then when RxJava calls `get` on that map JRuby calls `call` on the lambda.

So if you modify the example code to read `lambda { |x| lambda { |y| puts y } }` this is what happens:

```
% ruby rxjava.rb
rxjava.rb:6 warning: ambiguous Java methods found, using subscribe(java.util.Map)
RxJava => Could not find function language adaptor: Groovy with path: rx.lang.groovy.GroovyAdaptor
RxJava => Successfully loaded function language adaptor: JRuby with path: rx.lang.jruby.JRubyAdaptor
RxJava => Could not find function language adaptor: Clojure with path: rx.lang.clojure.ClojureAdaptor
RxJava => Could not find function language adaptor: Scala with path: rx.lang.scala.ScalaAdaptor
one
two
```

Which kind of works, but it's not as smooth as the ideal API would be:

``` ruby
observable.subscribe { |x| puts x }
```

But that would probably require a real JRuby native extension (if I get the time I'll send you a pull request with one).""Glad to have you involved, we haven't had much use of JRuby (that I'm aware of) so I'm not surprised we have some issues. I would appreciate your involvement.

Can you check out code from this pull request (https://github.com/Netflix/RxJava/pull/319), build the rxjava-jruby jar and try it? We are working on a very different approach in this pull request for language adaptors that is statically typed.

As for the `subscribe(Map)` overload ... I'm not thrilled by that one and it has caused other issues. I've considered getting rid of it before we hit 1.0, but I know it's used in a variety of places so haven't pulled that trigger.
 =||= It works better, but not perfect. JRuby seems to pick a working overload, but it still warns about there being multiple overloads (which is hard to fix without adding JRuby-metadata to the `Observable` class).

An upside is that you can skip the `lambda { ... }` and use the more Ruby-ish: `obs.subscribe { |x| puts x }` (i.e. pass a block to `#subscribe`).

Since there will be a version generated to work specially for JRuby, how much can the code generation things add? Ideally it would add JRuby metadata to the class to make it work as a JRuby native extension. Can you give me any hints on how to dig into that? Where should I start to look in the code to understand the code generation?
 =||= If the generated `Observable` could be something like this (but lots more, obviously), it could integrate with JRuby even better:

``` ruby
@JRubyClass(name=""Rx::Observable"")
public class Observable<T> extends RubyObject {
    @JRubyMethod(meta = true, rest = true)
    public static <T> Observable<T> from(ThreadContext ctx, IRubyObject receiver, IRubyObject[] args) {
        // ...
    }

    @JRubyMethod(name = ""subscribe"")
    public IRubyObject subscribeRuby(ThreadContext ctx, Block block) {
        // ...
    }
```

There would be some more code needed that registered the class with the runtime, and created the `Rx` module, and some more things, but that wouldn't need to be generated.
 =||= Can you take a look at pull request https://github.com/Netflix/RxJava/pull/323 and suggest how to re-add JRuby support correctly? We have decided against doing byte-code generation.

We can not add anything (such as the annotations in your example) to rxjava-core, it needs to be in a separate submodule, similar to Groovy, Scala and Clojure. So this means using something like extension methods, implicits, or other such tools if JRuby supports them. 
 =||= I will have a look.
 =||= With some small patches at least some of the basics work:

``` ruby
require 'rxjava-core/build/libs/rxjava-0.10.1-SNAPSHOT.jar'

class Java::Rx::Observable
  java_alias :subscribe, :subscribe, [Java::RxUtilFunctions::Action1.java_class]
end

module Rx
  include_package 'rx'
end

o = Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

I haven't tested any more than that, but it looks like it could work.
 =||= #323 should be `0.11.0-SNAPSHOT` afaik, not `0.10.1-SNAPSHOT`. Are you sure you're using the correct version of RxJava?
 =||= Good catch, I'm not used to gradle, or even having to compile stuff, so I didn't clean up from the last build I did so the old jars were still around. 

The Ruby patch works with 0.11.0 too (which means that those small patches would have make the old version work too, so that's good to know). Without the patch it works as with #319, the code runs but it prints a warning about not finding the right overloaded method.

The boring part of doing it this way is that each method on Observable, and any other classes needed for interoperability will need to be annotated with `java_alias`. On the other hand I don't see any other way of doing it which wouldn't involve writing even more code.
 =||= Does JRuby have a way to apply these aliases programmatically? For example, in Groovy we use reflection to determine all methods that need extensions and then programmatically create all of the `MetaMethod` implementations to bridge Groovy and Java. You can see an example here: https://github.com/mattrjacobs/RxJava/blob/8c87c29bea5e076bdc4202af5626d474ab1c7117/language-adaptors/rxjava-groovy/src/main/java/rx/lang/groovy/RxGroovyExtensionModule.java#L103

Otherwise every time a new method is added to core someone will have to maintain the JRuby java_alias mappings.
 =||= Maybe, I'm not sure, I'll have to look into more about how JRuby's native extensions work. So far I've only done it by creating classes and adding metadata, but I guess that it should be possible to do it on existing classes to somehow.

If I understand the code you linked to correctly it's looking through the `Observable` and `BlockingObservable` classes for methods that take subclasses of `Function` and somehow makes the Groovy runtime prefer those over any other overloads. That's what would be needed for JRuby too, and since the Groovy version just uses Java reflection to do it I think it should be possible in JRuby too. 

All that the `java_alias` thing does is that it looks up a Java method by reflection and adds that method into a cache that JRuby will look in before it looks at the Java class, which is kind of similar to what the Groovy extension thing does, I think.

So, yes, probably, maybe, hopefully, but I'm not sure exactly how right now.
 =||= This isn't complete yet, but here's a first pass at an implementation I think will work. @benjchristensen can you take a look and let me know if this is the direction you're looking for? It's largely cribbed from the Groovy implementation.

https://github.com/ragalie/RxJava/commit/fc0a706faaa27d1d797cfb8c43080a3b68e1cb1f
 =||= I'm getting warnings about overloads.

This is my code:

``` ruby
require 'rxjava-core/build/libs/rxjava-core-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/build/libs/language-adaptors-0.14.2-SNAPSHOT-sources.jar'

module Rx
  include_package 'rx'
end

o = Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

and this is the output (JRuby 1.7.4):

```
rxjava.rb:14 warning: ambiguous Java methods found, using subscribe(rx.util.functions.Action1)
2
4
6
```
 =||= Just to be clear, the commit I posted doesn't work yet. I just want to make sure that the approach is sane before investing more time in it. 
 =||= Ok. Yeah, it might work.

Not sure how well the generated methods will work, though: they are added on the classes, but call `super` to call the original method, but I'm not sure that `super` is actually what you think it is (it might be, I assume you've run the code, and I have not, so I could be completely wrong). In other words, you're adding a method on `Observable`, and then you call `super` in that method to call the original method on `Observable`, but that should call a method on the superclass of `Observable`, not the original method -- unless JRuby tries to be clever and figures out that your added method is on the eigenclass and `super` should refer to `Observable`, but I don't think it does.

And either way, once you call `super` JRuby still has to look up the right Java method to call, and it doesn't have any more type information to do it, so it will pick one at random and print out the ""ambiguous Java methods found"" warning. Even if you've wrapped the proc in an `Action` I'm not sure that JRuby will pick the right overloaded method. In my experience it tries, but it doesn't always succeed in picking the right method.

I think a better way to solve the problem is to use `java_alias` as in one of my examples above. That way JRuby will always pick the right overload. I'm not sure all the wrapper classes would be needed in that case, because JRuby will wrap a proc in a proxy class that implements whatever interface is required (and since `Function` and `Action` interfaces only really have one method, that also just happens to map straight to interface of proc, I think letting JRuby do it makes sense). There might be a slight performance loss from letting JRuby generate proxies instead of having Java classes, but I think it's greatly outweighted by skipping a large part of the work that JRuby otherwise would have done in finding the right overload.
 =||= You're right, the `super` approach won't work.

I tried the `java_alias` approach first and the problem I ran into is that it didn't seem to work correctly when a method had multiple signatures with the same number of arguments. For instance, I tested it with RxJava 0.10 which has `subscribe(Hash)` and `subscribe(Action1)` (or something like that). I tried just running `java_alias` on the methods that had `Function` arguments and it threw an error when I tried to use the `Hash` argument. I tried running `java_alias` on all methods, but running it first on the non-function methods and second on the function methods and that didn't work either (threw an error with a `Hash` argument).

I'm a relative newbie at JRuby, so totally possible I'm doing something wrong. But from my basic understanding I don't understand how `java_alias` will be a solution if there are two signatures with the same number of arguments and we want to allow access to both of them.
 =||= I spent some more time researching this evening and I think the easiest path forward is to leverage the JRuby method dispatching as much as possible. Outside of the `Proc` => `Action`/`OnSubscribeFunc`/`Function` casts, which we can reliably do but which the JRuby dispatch logic is having trouble reliably doing, the default dispatch logic is likely to be far better at sussing out the method signature we want to invoke than we would be.

The first thing the dispatch logic checks for when trying to find a method signature match is whether the Java class of the argument provided is an exact match with the parameter type specified in the method signature (see: https://github.com/jruby/jruby/blob/master/core/src/main/java/org/jruby/java/dispatch/CallableSelector.java#L321). While it isn't guaranteed that this will always be true (JRuby could change the dispatch logic), I think it's a safe bet that it will continue to preference exact class matches when selecting overloads. I think that means that as long as we pass in arguments that implement the exact interfaces JRuby should have a much easier time finding the matching method signature.

Assuming that's true, I think we should implement an algorithm like the following on load:
- Select the methods that have any signatures that contain a parameter type that is a (sub)interface of `rx.util.functions.Function`
- Determine the (sub)interfaces of `Function` that are possibilities for each argument position for a given method.
- If any given argument position has more than one possibility (e.g. `Action1` or `Action0`), ignore.
- If any given argument position has only one possibility, then note that we should convert any `Proc` we see in that argument position into the `Function` subclass we've identified.

Then I think we should implement the following to occur at runtime:
- Upon invoking a method where we've noted that we should convert `Proc`s, replace the `Proc` arguments with wrappers that implements the noted interfaces, if applicable.
- Call the original Ruby method with the modified arguments.

We should be able to do this using `alias_method` to copy the original `subscribe`, for instance, to `subscribe_without_argument_wrapping` and then redefine `subscribe` to modify the arguments and call `subscribe_without_argument_wrapping` with the updated arguments.

Under this scenario most of the hard dispatch logic remains in Java: the only additional runtime things we're doing in Ruby are a) a check to see if the argument is a `Proc`, b) a Hash lookup to see whether we can replace the `Proc` with a wrapper and c) instantiating the Java wrapper. So I don't think it should significantly slow things down.

It's clear you've thought about this quite a bit @iconara; anything stick out to you as suspect here?
 =||= It isn't the cleanest thing in the world, but https://github.com/ragalie/RxJava/commit/957af11bb7e843e79e72a7559a7c0c8a24052e35 seems to be working correctly.

This code no longer causes an ambiguous method warning:

``` ruby
require 'rxjava-core/build/libs/rxjava-core-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/rxjava-jruby/build/libs/rxjava-jruby-0.14.2-SNAPSHOT.jar'
require 'language-adaptors/rxjava-jruby/src/main/ruby/rx/lang/jruby/interop'

o = Java::Rx::Observable.from([1, 2, 3])
o.map { |n| n * 2 }.subscribe { |n| puts(n) }
```

I'm going to clean it up as best as I can then open a PR. I'm pretty new to JRuby, though, and I'm sure there are some ways to simplify what I've done, so hopefully someone can help me out with that. In particular I'd love to be able to leverage the built-in JRuby proxying (telling it which interface to proxy) instead of the clunky ones in the commit.

I also don't know what to do with the Ruby code. Should that stay in the JAR and just need to be required manually? Or should it be pulled out to a gem? I'm not sure what's idiomatic.

Thanks!
 =||= @ragalie I'm sure it can be done more elegantly, but it would take a lot of time, and I don't know very much more about the details of JRuby's Java integration to say for sure how to do it. It's better to get something that works and improve it later than trying to find the optimal solution now.

There's a way to package a JAR that makes JRuby run code when it is require'd from Ruby code. You need to stick a special class at the root of the JAR (here's an example: https://github.com/iconara/msgpack-jruby/blob/master/ext/java/MsgpackJrubyService.java). It's used to load JRuby native extensions (i.e. Java code that creates JRuby modules and classes), but in this case it could be used to automatically run the interop code (which can be loaded from within the JAR).

Another option would be to make the the interop code the main entrypoint for Ruby, and for it to load `rxjava-core.jar` and `rxjava-jruby.jar`. Come to think of it, that would be the better solution.

The benefit of the former solution would be that you could ship it all as just the JAR, but the latter is simpler to maintain and is how many JRuby wrappers for Java libraries work.

If it's ever going to get any kind of adoption in the Ruby world the library must be packaged as a gem.
 =||= I implemented JRuby support in #422. Let me know what you all think and if there's anything that doesn't seem to be working correctly. Thanks!
 =||= Awesome @ragalie! I'm taking a look now and will merge it into master or iterate with you on it if there are changes needed.
 =||= "JRuby function wrapping support"This PR fixes #320 by implementing JRuby wrappers for RxJava-specific function interfaces. Given a set of method signatures for a Java method, JRuby will select the signature that best matches the Ruby arguments provided and wrap each argument in a proxy that implements the correct Java interface.

Occasionally JRuby will be unable to unambiguously select one method signature over another, and will either a) select the correct signature, but report that there was ambiguity in the method signatures or b) select the wrong signature and fail.

By explicitly wrapping `Proc` arguments into wrappers that implement the correct RxJava interface, JRuby will always select the correct method signature and will not need to wrap the argument in a proxy, increasing both correctness and performance."Mike Ragalieragalie10/09/13, 06:08:47 AM
1220.01224Shorter naming for .toBlockingObservable()"Hi folks,

I'm exposing Observables to my user, and while this is awesome I'm realistic and know that a lot of them will fall back to blocking immediately either because they are migrating their blocking codebases or they just can't handle it properly.

While I think how RxJava exposes blocking is good, I think there is also room for improvement to make it shorter. For example, consider the following:

``` java
Cluster cluster = new CouchbaseCluster(""127.0.0.1"");
Bucket bucket = cluster.openBucket().toBlockingObservable().single();

Document doc = JsonDocument.create(""hello"", JsonObject.empty().put(""Hello"", ""World""));
bucket.upsert(doc).toBlockingObservable().single();

System.out.println(bucket.get(""hello"").toBlockingObservable().single());
```

Especially if you are dealing a lot with just a single value, something like `await()` on the observable would be good, or some shorter way/alias name. To be honest I'm not sure if this is possible, but I also thought about shipping a helper class which just wraps the calls like `BlockingUtils(observable).single()` or something like this. ""@benjchristensen wdyt?
 =||= We specifically chose the explicit and long name `toBlockingObservable` so people are fully aware of what they're opting into. We also consciously moved all of the blocking operators out of `Observable` into `BlockingObservable` so it is very clear what operators are blocking and which are not.

You can however use `BlockingObservable.from(o)` which would be the same as `BlockingUtils(observable)`.

The `await` name isn't quite right, as the method itself is not awaiting anything, it's just giving access to the blocking methods that would await. 

We could suggest to the broader group to alias something shorter like `.blocking()` or `.toBlocking()` to `.toBlockingObservable()`. Then it would be like this:

``` java
System.out.println(bucket.get(""hello"").blocking().single());
```
 =||= @benjchristensen makes sense! I really like `.blocking()` it is much more concise. Can you bring that to a vote?
 =||= +1 for Alias, `toBlocking()` and `toBlockingObservable()` 
 =||= @chrisjenx what do you think about  just `blocking()`?
 =||= @daschl I think it needs to remain clear that its is _to_ a blocking Observable, as `blocking()` to me implies its an operator, which it is not.
 =||= @headinthebox @akarnokd @abersnaze @zsxwing Any issues with aliasing `.toBlocking()` for `.toBlockingObservable()` to keep it shorter?
 =||= `.toBlocking()` is fine with me.
 =||= `toBlocking` +1
 =||= I submitted a (simple) PR for this in case we get consensus.
 =||= I vote no, strongly. Autocomplete will type it for you. And as Ben says, it should be there as a blinking danger sign to war you that you are doing something unsafe. That why in Haskell unsafePerformIO has such a long name. 

If you want to make it shorter, I propose .BLOCKING(), all caps.
 =||= @headinthebox not sure I can follow. While I can understand that it breaks the idea of async flows, lots of applications, sooner or later at the end of the chain will fall back to blocking so they can return it to a servlet or whatever.

I don't think we should make it hard on people, sync programming is a legit concept, even if it is not as powerful as Rx.
 =||= I also vote no. `BlockingObservable.from()` is sufficient and avoids auto-complete-induced temptation. Ideally if you need blocking, it's in a single, generic spot so it shouldn't even come up that often.
 =||= @daschl won this one :-)

We have deprecated `toBlockingObservable()` in favor of `toBlocking()` which is less annoying to use while still being clear, and will better match the pattern with `toParallel()` that will come one day when I get around to it.
 =||= See https://github.com/Netflix/RxJava/pull/1233 for the change.
 =||= @benjchristensen thanks for taking care of it. My users will appreciate it.
 =||= "Implement shorter toBlocking as shorter alias for toBlockingObservable.Fixes #1220Michael Nitschingerdaschl05/20/14, 04:22:03 PM
1344.01347schedulePeriodically cannot be unsubscribed from"The subscription returned by `schedulePeriodically()` is automatically marked as unsubscribed when the first run terminates, after queuing the next event. As a result, the periodic event cannot be unsubscribed from once the first `call()` happens, as `unsubscribe()` will now be a no-op (as `isUnsubscribed` is true).

Example in the Scala REPL (with the Java bindings for RxJava 0.19):

``` scala
import rx._
import rx.functions._
import rx.schedulers.Schedulers
import java.util.concurrent.TimeUnit
val s = Schedulers.io().createWorker.schedulePeriodically(new Action0 { override def call = println(""In call"") }, 1, 1, TimeUnit.SECONDS)
s.isUnsubscribed
```

Here, `s.isUnsubscribed()` returns `false`. However, if you wait one second, it will return `true` and `s.unsubscribe()` will not do anything and the constant display will continue every second."Allow use of the returned subscription to cancel periodic scheduling"The documentation for schedulePeriodically indicates that the returned
subscription can be used to unsubscribe from the periodic action, or to
unschedule it if it has not been scheduled yet. That was the case only
before the first action took place, and it was then impossible to
unsubscribe using the given subscription, although unsubscribing the
worker did work.

This fixes #1344."Samuel Tardieusamueltardieu06/12/14, 04:31:06 PM
1365.01367Exception in the inner observable of flatMap not rethrown"Hi all,
I'm trying to figure out, how errors are handled in RxJava (0.19.1). Basically, I'd expect the fundamental rule to be something like: _Any exception thrown within an operator is either handed to the onError handler of subscribe if one is provided, or rethrown if none is provided._

This works for the map operator: 

``` scala
def throwOnB2(prefix: String) = Observable.from(List(1, 2, 3))
  .map(x ⇒ prefix + x.toString)
  .map(s ⇒ if (s == ""b2"") throw new Exception(""Bang!"") else s)

throwOnB2(""b"").subscribe(next ⇒ println(next))
```

throws a `rx.exceptions.OnErrorNotImplementedException: Bang!` as expected.

``` scala
throwOnB2(""b"").subscribe(
  next ⇒ println(next),
  err ⇒ println(s""error: ${err}""),
  () ⇒ println(""completed"")
)
```

prints `error: java.lang.Exception: Bang!` as expected.

For nested observables joined using `flatMap`

``` scala
def nested = Observable
  .from(List(""a"", ""b"", ""c""))
  .flatMap(prefix ⇒ throwOnB2(prefix))

nested
  .subscribe(
    next ⇒ println(next),
    err ⇒ println(s""error: ${err}""),
    () ⇒ println(""completed"")
  )
```

prints `error: java.lang.Exception: Bang!` as expected,

**But:**

``` scala
nested.subscribe(next ⇒ println(next))
```

prints

```
a1
a2
a3
b1
```

and finishes without throwing any exception. 

Is this the intended behavior? For me it is quite unfortunate, since bugs in my code can easily slip away unnoticed, but perhaps there is something I don't see.

Thank you, best regards""@dvtomas Good catch.
 =||= "Fix the bug that 'flatMap' swallows OnErrorNotImplementedException"Fixed #1365
Not sure if any other place will swallow `OnErrorNotImplementedException` or the fatal errors."Shixiong Zhuzsxwing06/21/14, 02:25:24 PM
1405.01431CompositeException issue"I'm using RxJava on Android and I've encountered issues with CompositeException. Because it collects throwables as `Collection<Throwable> errors` the exceptions are not logged to the logcat output if there is an unhandled Exception in onError callback. 

Here is a sample output:

```
2739:E/AndroidRuntime(14639): FATAL EXCEPTION: main
2740:E/AndroidRuntime(14639): rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError
2741:E/AndroidRuntime(14639):   at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:182)
2742:E/AndroidRuntime(14639):   at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:103)
2743:E/AndroidRuntime(14639):   at rx.internal.operators.NotificationLite.accept(NotificationLite.java:144)
2744:E/AndroidRuntime(14639):   at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:139)
2745:E/AndroidRuntime(14639):   at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:61)
2746:E/AndroidRuntime(14639):   at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$1.call(OperatorObserveOn.java:121)
2747:E/AndroidRuntime(14639):   at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)
2748:E/AndroidRuntime(14639):   at android.os.Handler.handleCallback(Handler.java:730)
2749:E/AndroidRuntime(14639):   at android.os.Handler.dispatchMessage(Handler.java:92)
2750:E/AndroidRuntime(14639):   at android.os.Looper.loop(Looper.java:137)
2751:E/AndroidRuntime(14639):   at android.app.ActivityThread.main(ActivityThread.java:5103)
2752:E/AndroidRuntime(14639):   at java.lang.reflect.Method.invokeNative(Native Method)
2753:E/AndroidRuntime(14639):   at java.lang.reflect.Method.invoke(Method.java:525)
2754:E/AndroidRuntime(14639):   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:737)
2755:E/AndroidRuntime(14639):   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553)
2756:E/AndroidRuntime(14639):   at dalvik.system.NativeStart.main(Native Method)
2757:E/AndroidRuntime(14639): Caused by: rx.exceptions.CompositeException: 2 exceptions occurred. See them in causal chain below.
2758:E/AndroidRuntime(14639):   ... 16 more
```

That's it. No logs about real cause. I can wrap my onError code in try catch block and log the real cause, but I think this can be handled better by RxJava. What do you guys think?""How do you recommend doing it differently? 
 =||= What about using `initCause` (API 1) or I'm sure `addSuppressed` is dedicated for this case but as far as I remember it was introduced in java 7, so it's available in KitKat (API 19)
 =||= We print them out when `printStackTrace()` is called, but we no longer add them as part of the actual causal chain as it could end up causing circular loops under odd edge-cases. This was just barely changed in the last release: https://github.com/Netflix/RxJava/pull/1388

Here is the code: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java

Note how it will print all causes: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L111

What version of RxJava are you running to get that stack trace?

In the example you give, it looks like the chain is being cropped when it had more to display (2 causes).

I'm wondering if Android does something different than normal Java and doesn't actually invoke the `printStackTrace()` method and thus won't see the causal chain?
 =||= I'm using 0.19.2. I've also encountered problems with the previous version when unhandled exception in onError ended up in circular loop and crash of a StringBuilder but current implementation doesn't provide any useful information for debugging. If you are using error logging service like Bugsense or Crashlytics the only information you see is the stacktrace I've pasted above - it's useless.

Solution with `initCause` works perfect for me. What do you think about it?
 =||= As I said above, we used to use `initCause`, but because this is a composite of many exceptions, we are creating an artificial causal chain and it could result in infinite loops, hence it being removed in 0.19.2.

I can't speak to Bugsense or Crashlytics, but if something printing a stack trace calls `printStackTrace` then it would work and print out the full list of causes.

For historical information, here is the version that used `initCause`: https://github.com/Netflix/RxJava/blob/ea2249afecbf4d1380f2d7b0775fec60e37e3369/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L108 and the current one without it: https://github.com/Netflix/RxJava/blob/master/rxjava-core/src/main/java/rx/exceptions/CompositeException.java#L111

We need a solution that either does not use `initCause` due to the circular-reference problem, or solves the circular-reference problem. The change done in https://github.com/Netflix/RxJava/pull/1388 was based on the assumption that anything printing a stack trace would do it correctly via the `printStackTrace()` method and thus we can override the printing of the causes so the causal chain is shown, but not actually mutate the chain by using `initCause` which is what causes the issues.
 =||= Ok I've dive deeper into the implementation and it turns out that none of the `printStackTrace` methods are called when an `OnErrorFailedException` is thrown. Only `getMessage` and `getCause` methods are called so the real cause is not printed to the output. Here is my simple test with logged methods of the `CompositeException` class.

```
        AndroidRuntime  D  Shutting down VM
              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x4195e700)
 gt_CompositeException  I  CompositeException.getMessage
                        I  CompositeException.getCause
              dalvikvm  D  GC_FOR_ALLOC freed 453K, 5% free 11287K/11776K, paused 29ms, total 30ms
 gt_CompositeException  I  CompositeException.getCause
                        I  CompositeException.getMessage
                        I  CompositeException.getCause
        AndroidRuntime  E  FATAL EXCEPTION: main
                        E  rx.exceptions.OnErrorFailedException: a
                        E   at test.MainActivity.refreshTasksLists(MainActivity.java:267)
                        E   at test.MainActivity.onCreateOptionsMenu(MainActivity.java:156)
                        E   at android.app.Activity.onCreatePanelMenu(Activity.java:2504)
                        E   at com.android.internal.policy.impl.PhoneWindow.preparePanel(PhoneWindow.java:413)
                        E   at com.android.internal.policy.impl.PhoneWindow.doInvalidatePanelMenu(PhoneWindow.java:775)
                        E   at com.android.internal.policy.impl.PhoneWindow$1.run(PhoneWindow.java:198)
                        E   at android.view.Choreographer$CallbackRecord.run(Choreographer.java:749)
                        E   at android.view.Choreographer.doCallbacks(Choreographer.java:562)
                        E   at android.view.Choreographer.doFrame(Choreographer.java:531)
                        E   at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:735)
                        E   at android.os.Handler.handleCallback(Handler.java:730)
                        E   at android.os.Handler.dispatchMessage(Handler.java:92)
                        E   at android.os.Looper.loop(Looper.java:137)
                        E   at android.app.ActivityThread.main(ActivityThread.java:5103)
                        E   at java.lang.reflect.Method.invokeNative(Native Method)
                        E   at java.lang.reflect.Method.invoke(Method.java:525)
                        E   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:737)
                        E   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553)
                        E   at dalvik.system.NativeStart.main(Native Method)
                        E  Caused by: test.CompositeException: 2 exceptions occurred. See them in causal chain below.
                        E   ... 19 more
 gt_CompositeException  I  CompositeException.getMessage
                        I  CompositeException.getCause
                        I  CompositeException.getMessage
                        I  CompositeException.getCause

                           Process 28215 ended
```

It turns out Android has its own implementation of a `Throwable` with uses `private void private void printStackTrace(Appendable err, String indent, StackTraceElement[] parentStack)` to print the stacktrace. If the `cause` is `null` nothing is printed to the output.

I don't see any solution for this issue. For KitKat and above the `addSuppressed` is an easy fix, but what about older versions?
 =||= What about appending the stack trace to the message of a `CompositeException`? This is some kind of a dirty hack but it will work on any platform regardless of `printStackTrace` implementation.
 =||= Appending the stacktrace to the message is bad practice and would be despised in non-Android environments.

It's very annoying that Android does the wrong thing for this. 

If we do anything, it would need to special-case behavior just for Android (such as appending the whole stack trace as a message).
 =||= I think any working solution would be appreciated by the Android developers society. I ended up wrapping the whole implementation of `onError` in try-catch block so I'm able to log the cause. So far this is a simple workaround but better error logging by the RxJava should be really addressed in the future release.
 =||= @mttkay What do you suggest be done for Android and `CompositeException` since it doesn't behave correctly with `Throwable.printStackTrace()`?

@tomrozb According to the code I see for Android, this should work if the logger is calling `printStackTrace()` as it looks exactly like the Java one: https://android.googlesource.com/platform/libcore.git/+/android-4.2.2_r1/luni/src/main/java/java/lang/Throwable.java

How are the logs being generated? Is this default Android logging that bypasses `printStackTrace()` or a 3rd party logging library?
 =||= Thanks for flagging this. We're still on 0.19.1 so haven't had this problem yet. I'll have a look as well. 
 =||= @benjchristensen 
I'm not using any 3rd party logging library. The logs I've attached are from the standard logging tool called logcat. Logs are generated by Android system. The second posted log is slightly different because I'm using tool to present it in a user-friendly way, but the log is still being generated by Android OS.

Crash reporting tools like Crashlytics or Bugsense utilize the `Thread.UncaughtExceptionHandler` to obtain the stack trace and send it to the server. As I wrote above, stack traces obtained this way are exactly the same as printed by the system.

The `Throwable` implementation is different for Android and plain Java. If they are using the private `printStackTrace` method with 3 arguments to print the stack trace, other public `printStackTrace` methods, which are overridden by RxJava, will not be called when a crash occurred.

I can confirm this bug on:
Galaxy Nexus 4.3 (stock Android)
G900F 4.4.2
GT-I9506 4.4.2
GT-I9195 4.4.2
GT-N7100 4.4.2
SM-T335 4.4.2
SM-T320 4.4.2

I've not tested this on non-samsung devices but I'm sure this apply to all Android devices.
 =||= It is very easy to understand what is going under the hood even without writing a line of code.

The simplest test case:

```
throw new RuntimeException(new CompositeException(Arrays.asList(new RuntimeException(""the real cause""))));
```

No matter which one of the `printStackTrace` methods is called in the first place it end up calling the  `printStackTrace(err, """", null)` on a first `RuntimeException`. 

Now take a look at the Throwable implementation (Android 4.2.2)

```
    private void printStackTrace(Appendable err, String indent, StackTraceElement[] parentStack)
            throws IOException {
        err.append(toString());
        err.append(""\n"");
        StackTraceElement[] stack = getInternalStackTrace();
        if (stack != null) {
            int duplicates = parentStack != null ? countDuplicates(stack, parentStack) : 0;
            for (int i = 0; i < stack.length - duplicates; i++) {
                err.append(indent);
                err.append(""\tat "");
                err.append(stack[i].toString());
                err.append(""\n"");
            }
            if (duplicates > 0) {
                err.append(indent);
                err.append(""\t... "");
                err.append(Integer.toString(duplicates));
                err.append("" more\n"");
            }
        }
        // Print suppressed exceptions indented one level deeper.
        if (suppressedExceptions != null) {
            for (Throwable throwable : suppressedExceptions) {
                err.append(indent);
                err.append(""\tSuppressed: "");
                throwable.printStackTrace(err, indent + ""\t"", stack);
            }
        }
        Throwable cause = getCause();
        if (cause != null) {
            err.append(indent);
            err.append(""Caused by: "");
            cause.printStackTrace(err, indent, stack);
        }
    }
```

What is important the only method used on a `cause` is `printStackTrace` with 3 arguments. Our cause is the `CompositeException` which doesn't have a cause and there is no way to override private `printStackTrace` method so that's why it doesn't work this way.
 =||= Just wondering, if the problem is that Android's `Throwable` refuses to print the stack trace when the cause is null, why not simply return `this` from `CompositeException.getCause`? That way we still don't have to `initCause` on the wrapped exceptions and make Android forward to `CompositeException`'s custom printStackTrace impl.

This is just by reading the discussion mind you, so sorry if I'm not making any sense. I still haven't had time to bump RxJava to a newer version in our app .
 =||= We see more threads getting stuck in infinite loops in `removeDuplicatedCauses`.  Re-opening as we will need to re-fix this.
 =||= So should we revert to what it was when we fixed it last time and special case Android? Or does someone have a legit fix for this?

I'm planning on reverting to what was a known fix for non-Android, and then following up with a special case for Android.
 =||= Closing out again as I believe this is solved in https://github.com/ReactiveX/RxJava/pull/1632

As per comment https://github.com/ReactiveX/RxJava/pull/1632#issuecomment-53595353:

> This passed the Netflix production canary over night. There are no threads spinning on circular references.
> 
> This pull request should work for both Android and Oracle JVMs as it supports both `printStackTrace` and `getCause` mechanisms. The `printStackTrace` approach is better, but the `getCause` one should work normally and then bail if it sees a circular reference.
 =||= There are still issues with stack trace printing on Android with RxJava 0.20.3. For example when `UnknownHostException`  is thrown from `OnSubscribe` implementation nothing is printed to the logcat output. I've tested it on S5 4.4.2, S4 4.4.2, Galaxy Nexus 4.3.

Simple example to reproduce:

```
        Observable.create(new OnSubscribe<Object>() {
            @Override
            public void call(Subscriber<? super Object> subscriber) {
                subscriber.onError(new UnknownHostException());
            }
        }).subscribeOn(Schedulers.io())
                .observeOn(AndroidSchedulers.mainThread())
                .subscribe(new Action1<Object>() {
                    @Override
                    public void call(Object o) {
                        // Does nothing intentionally.
                    }
                }, new Action1<Throwable>() {
                    @Override
                    public void call(Throwable e) {
                        throw new RuntimeException(e);
                    }
                });
```

Logcat output:

```
        AndroidRuntime  D  Shutting down VM
              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x417a7da0)
        AndroidRuntime  E  FATAL EXCEPTION: main
                        E  Process: pl.example.test, PID: 25099
```

Change `UnknownHostException` to `IOException`, now logcat output looks like below:

```
        AndroidRuntime  D  Shutting down VM
              dalvikvm  W  threadid=1: thread exiting with uncaught exception (group=0x417a7da0)
        AndroidRuntime  E  FATAL EXCEPTION: main
                        E  Process: pl.example.test, PID: 9153
                        E  rx.exceptions.OnErrorFailedException: Error occurred when trying to propagate error to Observer.onError
                        E      at rx.observers.SafeSubscriber._onError(SafeSubscriber.java:175)
                        E      at rx.observers.SafeSubscriber.onError(SafeSubscriber.java:97)
                        E      at rx.internal.operators.NotificationLite.accept(NotificationLite.java:144)
                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.pollQueue(OperatorObserveOn.java:169)
                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber.access$000(OperatorObserveOn.java:66)
                        E      at rx.internal.operators.OperatorObserveOn$ObserveOnSubscriber$2.call(OperatorObserveOn.java:151)
                        E      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)
                        E      at android.os.Handler.handleCallback(Handler.java:733)
                        E      at android.os.Handler.dispatchMessage(Handler.java:95)
                        E      at android.os.Looper.loop(Looper.java:136)
                        E      at android.app.ActivityThread.main(ActivityThread.java:5586)
                        E      at java.lang.reflect.Method.invokeNative(Native Method)
                        E      at java.lang.reflect.Method.invoke(Method.java:515)
                        E      at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1268)
                        E      at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1084)
                        E      at dalvik.system.NativeStart.main(Native Method)
                        E  Caused by: rx.exceptions.CompositeException: 2 exceptions occurred.
                        E      ... 16 more
                        E  Caused by: rx.exceptions.CompositeException$CompositeExceptionCausalChain: Chain of Causes for CompositeException In Order Received =>
                        E      at android.util.Log.getStackTraceString(Log.java:421)
                        E      at android.util.Slog.e(Slog.java:151)
                        E      at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)
                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)
                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)
                        E      ... 1 more
                        E  Caused by: java.io.IOException
                        E      at pl.example.test.MyActivity$3.call(MyActivity.java:48)IOException
                        E      at pl.example.test.MyActivity$3.call(MyActivity.java:45)
                        E      at rx.Observable.unsafeSubscribe(Observable.java:8587)
                        E      at rx.internal.operators.OperatorSubscribeOn$1$1.call(OperatorSubscribeOn.java:62)
                        E      at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:43)
                        E      at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)
                        E      at java.util.concurrent.FutureTask.run(FutureTask.java:237)
                        E      at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:152)
                        E      at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:265)
                        E      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
                        E      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
                        E      at java.lang.Thread.run(Thread.java:841)
                        E  Caused by: java.lang.RuntimeException: Duplicate found in causal chain so cropping to prevent loop ...
                        E      at android.util.Log.getStackTraceString(Log.java:421)
                        E      at android.util.Slog.e(Slog.java:151)
                        E      at com.android.internal.os.RuntimeInit$UncaughtHandler.uncaughtException(RuntimeInit.java:109)
                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:693)
                        E      at java.lang.ThreadGroup.uncaughtException(ThreadGroup.java:690)
                        E      at dalvik.system.NativeStart.main(Native Method)
```

Can anyone confirm this issue with the code I've attached?
 =||= I can't help to test this as I don't do Android development or have an environment to test with.

The current implementation uses `getCause()` to provide the causes, so as long as Android calls `getCause()` then it should work. If however it even bypasses that (as it bypasses `printStackTrace`) and reaches into the internal super field, then it won't work, as we don't wire up the causal chain unless `getCause()` is invoked (instead of construction time as non-Android platforms don't need or want that). If Android is doing that ... then apparently it doesn't obey any APIs.

If Android is completely ignoring even `getCause()` then the only way I can think of fixing this is having two different implementations and an Android specific check that delegates to a different solution. 

/cc @mttkay 
 =||= Maybe there's something wrong with my code. I've put the code above in onResume of a totally empty Activity to nail down where's the issue. If somebody can test this on other devices it would be very helpful. I don't have any non-Samsung devices at the moment.
 =||= I'll put some time aside either tomorrow or Thursday to work through a backlog of Rx specific things. I can try to reproduce then.

I haven't personally seen this issue yet (we're on 0.20.3) but I'll double check the crash logs.
 =||= Just a quick heads up that I can confirm this issue.

Not sure yet _why_ it's happening, but swapping out the exception type does appear to fix it. Which is odd, since `UnknownHostException` _is_ an `IOException`? I also looked at `Exceptions.throwIfFatal` if it had to do with rethrowing exceptions or not, but it does not mention either type.
 =||= `UnknownHostException` is not the only one that is not logged. I'm sure I've found at least 3 different exceptions that do not produce any output to the logcat. I'll post these exceptions here once I figure out which one causing problems. Good to hear that this issue is confirmed and easy to reproduce.
 =||= It's really hard to debug, unfortunately. I was able to pour your example in an automated test and run it on a Genymotion 4.3 instance -- that's the easy part. What I'm not able to do is debug into Android's stack trace methods (parts of it are native code, too, but the problem might exist on the Java layer). This might be an issue with the new project setup, I'm usually able to debug platform classes.

I'll poke around some more.
 =||= Sorry I'm still fighting the tools :-/ I might have to pick this up again another day...
 =||= Moving Android specific discussion to https://github.com/ReactiveX/RxAndroid/issues/21
 =||= "CompositeException fix for Android"Fixes #1405
- revert changes from f4ae92aa
- remove duplicated causes in stack trace chain"Tomasz Rozbickitomrozb07/21/14, 11:22:07 PM
1741.01742Observer.empty() vs EmptyObserver"The behavior between Observer.empty() and `EmptyObserver` is different. This seems confusing.

`EmptyObserver` swallows errors whereas `Observer.empty()` will throw `OnErrorNotImplementedException` if `onError` is invoked.

Thoughts on what we should do?""I think deleting `EmptyObserver` is the best approach. It serves no value.
 =||= I deleted `EmptyObserver` and updated the `Observers.empty()` javadocs to be clear that it throws `OnErrorNotImplementedException`. 

If someone wants to swallow errors they need to actively code for that. RxJava will not swallow errors itself.
 =||= Like!
 =||= "EmptyObserver and TestObserver"- Remove `EmptyObserver` as it was confusing compared to `Observers.empty()` (fixes #1741)
- Make `TestObserver` not throw `OnErrorNotImplemented` if a delegate is not provided (fixes #1571)"Ben Christensenbenjchristensen10/10/14, 03:44:23 AM
1571.01742TestObserver always delegates to EMPTY, throws exception"I noticed that TestObserver was changed to always delegate calls, by default to the `EMPTY` Observer.

However, the EMPTY Observer does not define `onError`, so any attempt to use TestObserver with an observable that's supposed to fail in a unit test crashes the test with a `OnErrorNotImplementedException`

I wonder why this change was done? It adds complexity and surprise to something that should be void of behavior (mocks should record things, not perform logic IMHO)""I had a problem with this to when using the `TestObserver` to test errors.
I'm using mockito so I worked this around creating my TestObservers like this:

```
    @SuppressWarnings(""unchecked"")
    public static <T> TestObserver<T> createTestObserver()
    {
        Observer<T> delegate = mock(Observer.class);
        return new TestObserver<T>(delegate);
    }
```
 =||= Opening discussion about confusion between `EmptyObserver` and `Observers.empty()`: https://github.com/ReactiveX/RxJava/issues/1741
 =||= It will no longer throw an exception when a delegate is not provided. That was a mistake.
 =||= :+1: 
 =||= "EmptyObserver and TestObserver"- Remove `EmptyObserver` as it was confusing compared to `Observers.empty()` (fixes #1741)
- Make `TestObserver` not throw `OnErrorNotImplemented` if a delegate is not provided (fixes #1571)"Ben Christensenbenjchristensen10/10/14, 03:44:23 AM
1791.01792Observable#first causes retryWhen to trigger retry without an exception"Noticed this behavior using rx-netty as internally it does a take(1) internally:

```
    AtomicLong inc = new AtomicLong(0);
    Observable.OnSubscribe<Long> onSubscribe = subscriber -> {
        final long emit = inc.getAndIncrement();
        LOGGER.info(""Emitting: {}"", emit);
        subscriber.onNext(emit);
        subscriber.onCompleted();
    };

    LOGGER.info(""DONE: {}"", Observable.create(onSubscribe)
                    .retryWhen(attempt -> attempt.zipWith(Observable.range(1, 4), (n, i) -> i))
                    .toBlocking()
                    .first()
    );
```

The test output is:
    Emitting: 0
    Emitting: 1
    DONE: 0

As you can see the observable is subscribed to twice. This is because take, in combination with single, causes the retryWhen producer to request another item.""Manually merged in https://github.com/ReactiveX/RxJava/pull/1793

Thank you @alexwen for submitting a bug report and then this fix!
 =||= "Fix for #1791"Fixes #1791 

don't retry (subscribe) to source if child has unsubscribed."Alex Wenckusalexwen10/23/14, 09:48:29 PM
1812.01813Multiple Zipped Observers never complete"The following code never executes the onComplete if the number is greater than 1025. I think it has to due with back pressure which uses a default request of 1024. I am using Java 8 

```
    Observable merged1 = Observable.zip(Observable.range(0, 1026), Observable.range(0, 1026),
            (o, e) -> new int[]{o, e});
    Observable merged2 = Observable.<int[], Integer, int[]>zip(merged1, Observable.range(0, 1026),
            (o, e) -> new int[]{o[0], o[1], e}).serialize();
    merged2.subscribe(
            (o) -> System.out.println(o),
            e -> {},
            () -> {
                System.out.println(""This never prints"");
            }
    );
```

I am using the following version of Java.

java version ""1.8.0_05""
Java(TM) SE Runtime Environment (build 1.8.0_05-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)""Thanks for reporting it.
 =||= "Fix issue #1812 that zip may swallow requestsFixed #1812Shixiong Zhuzsxwing10/31/14, 07:28:49 PM
1826.01827Race with CachedThreadScheduler Eviction"Although I have not been able to find a way to reproduce the issue reliably, I have seen the following stack several times now:

```
 ! java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@328cda0 rejected from java.util.concurrent.ScheduledThreadPoolExecutor@2200705d[Terminated, pool size = 0, active threads = 0, queued tasks = 0, completed tasks = 3]
 ! at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047) ~[na:1.8.0_20]
 ! at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823) [na:1.8.0_20]
 ! at java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute(ScheduledThreadPoolExecutor.java:326) ~[na:1.8.0_20]
 ! at java.util.concurrent.ScheduledThreadPoolExecutor.schedule(ScheduledThreadPoolExecutor.java:533) ~[na:1.8.0_20]
 ! at java.util.concurrent.ScheduledThreadPoolExecutor.submit(ScheduledThreadPoolExecutor.java:632) ~[na:1.8.0_20]
 ! at rx.internal.schedulers.NewThreadWorker.scheduleActual(NewThreadWorker.java:66) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]
 ! at rx.schedulers.CachedThreadScheduler$EventLoopWorker.schedule(CachedThreadScheduler.java:149) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]
 ! at rx.schedulers.CachedThreadScheduler$EventLoopWorker.schedule(CachedThreadScheduler.java:139) ~[sasquatch_46ada84dd260fa8b7ab66fb20b7ae79f29810947.jar:0.1-SNAPSHOT]
```

While auditing the CachedThreadScheduler, I noticed a potential race condition when evicting workers from the eviction queue, from CachedThreadScheduler:

```
        void evictExpiredWorkers() {
            if (!expiringWorkerQueue.isEmpty()) {
                long currentTimestamp = now();

                Iterator<ThreadWorker> threadWorkerIterator = expiringWorkerQueue.iterator();
                while (threadWorkerIterator.hasNext()) {
                    ThreadWorker threadWorker = threadWorkerIterator.next();
                    if (threadWorker.getExpirationTime() <= currentTimestamp) {
                        threadWorkerIterator.remove();
                        threadWorker.unsubscribe();
                    } else {
                        // Queue is ordered with the worker that will expire first in the beginning, so when we
                        // find a non-expired worker we can stop evicting.
                        break;
                    }
                }
            }
        }
```

The evictor, uses an `iterator#remove` in order to remove the work from the queue, but it does not check that this operation actually occurred. The iterator, though thread safe, is not atomic for .next and .remove, so, the worker could be pulled from the cache by another thread between the .next and the .remove.

If this occurs then the the NewThreadWorker will be unsubscribed, its executor shutdown, and the next action that executes on that worker would cause the exception above.

In order to fix this race I believe the evictor would need to check that it removed the worker from the queue, before attempting to unsubscribe the worker.""Thanks for the report.
 =||= "CacheThreadScheduler Evictor should Check Removal"Before unsubscribing the worker, the Evictor should check that it actually removed the worker from the queue.

FIxes #1826 "Alex Wenckusalexwen11/06/14, 07:05:16 AM
1878.02091defaultIfEmpty(Observable<T> t)"Went to use `defaultIfEmpty` and found it only accepts a single value .... instead of an `Observable` which means I can't pass in an `Observable.error`.

It would be very helpful to have `defaultIfEmpty(Observable<T> t)`""+1. Then `tail` in RxScala can be implemented by `o.defaultIfEmpty(Observable.error(new UnsupportedOperationException(""tail of empty list""))).drop(1)`
 =||= Maybe `switchIfEmpty` would be a better name.
 =||= "Added Operator switchIfEmpty"Like defaultIfEmpty but subscribes to and emits the items in an Observable if the source is empty.

Fixes #1878 "Alex Wenckusalexwen02/03/15, 08:48:13 AM
1756.02475SynchronizedQueue.clone may cause ClassCastException"While cleaning up, I found a bug caused by too eager delegation:

```
    public synchronized Object clone() {
        return list.clone();
    }
```

Adding a copy constructor and using that in clone should solve the problem. I'd do it but would conflict with the cleanup changes in the class."SynchronousQueue.clone fixFixes #1756.David Karnokakarnokd01/21/15, 12:20:30 PM
2290.02476window time+size emits only 1 window"This code only emits 1 window. 

``` java
        Observable.range(0, 10000).window(1, TimeUnit.SECONDS, 20).flatMap(o -> {
            System.out.println(""window"");
           return o.count(); 
        }).toBlocking().forEach(System.out::println);
```

There are 2 issues I have with it:

1) Why are there 21 instead of 20 elements in it?
2) Why does this only emit 1 window? Why does this not just behave like `window(20)` since the time never triggers?""It has an off-by-one error on L211 and the clear() in L212 clears the consumer and thus not emitting anything further unless the timer fires. This seems to be an odd behavior but conforms the javadoc spec.
 =||= Pretty sure the Javadoc is just documenting how it was implemented. This can't be right as what is the point of the max count if it still waits for the time to fire? The only thing it can then do is drop data. 

cc @headinthebox
 =||= Yes one could use take() on a timed window to achieve the same effect. The buffer() operator does an _or_ between the size and time conditions. I can't remember why I implemented window() this way after implementing buffer() the other way. The fix is simple:

``` java
void emitValue(T t) {
    State<T> s = state;
    if (s.consumer == null) {
        replaceSubject();
        s = state;
    }
    s.consumer.onNext(t);
    if (s.count == size - 1) {
        s.consumer.onCompleted();
        s = s.clear();
    } else {
        s = s.next();
    }
    state = s;
}
```
 =||= Fixed.
 =||= "Fixed off-by-one error and value-drop in the window operator.Fixes #2290.David Karnokakarnokd01/21/15, 02:08:20 PM
2647.02648flatMap doesn't propagate onComplete with unsubscribe of child"The following code hangs forever as it doesn't emit a terminal event:

``` java
import java.util.concurrent.TimeUnit;

import rx.Observable;

public class IntervalTakeWhileExample {

    public static void main(String... args) {
        Observable
                .interval(1, TimeUnit.MILLISECONDS)
                .doOnEach(a -> System.out.println(""A ==> "" + a))
                .takeWhile(aLong -> aLong < 1)
                .doOnEach(b -> System.out.println(""B ==> "" + b))
                .flatMap(aLong -> {
                    return Observable
                            .timer(30, TimeUnit.MILLISECONDS)
                            .doOnUnsubscribe(() -> System.out.println(""unsubscribed timer?""))
                            .doOnEach(c -> System.out.println(""C ==> "" + c))
                            .map(aLong1 -> aLong1 + aLong);
                })
                .doOnEach(d -> System.out.println(""D ==> "" + d))
                .toBlocking().forEach(System.out::println);
    }
}
```

This emits:

```
A ==> [rx.Notification@f6adcf11 OnNext 0]
B ==> [rx.Notification@f6adcf11 OnNext 0]
A ==> [rx.Notification@f6adcf12 OnNext 1]
B ==> [rx.Notification@5b2cf4de OnCompleted]
unsubscribed timer?
```""/cc @abersnaze This may be related to the issue you're hunting.
 =||= It is not related to `interval` as I can replicate without it:

``` java
import java.util.concurrent.TimeUnit;

import rx.Observable;

public class IntervalTakeWhileExample {

    public static void main(String... args) {
        Observable
                .<Integer>create(s -> {
                    s.onNext(0);
                    try {
                        Thread.sleep(5);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    s.onNext(1);
                    s.onCompleted();
                })
                .doOnEach(a -> System.out.println(""A ==> "" + a))
                .takeWhile(aLong -> aLong < 1)
                .doOnEach(b -> System.out.println(""B ==> "" + b))
                .flatMap(aLong -> {
                    return Observable
                            .timer(30, TimeUnit.MILLISECONDS)
                            .doOnUnsubscribe(() -> System.out.println(""unsubscribed timer?""))
                            .doOnEach(c -> System.out.println(""C ==> "" + c))
                            .map(aLong1 -> aLong1 + aLong);
                })
                .doOnEach(d -> System.out.println(""D ==> "" + d))
                .toBlocking().forEach(System.out::println);
    }
}
```

However, if I change `takeWhile` to `take(1)` it works fine, so it may be related to `takeWhile`. But `merge` is always a candidate for this and my first thought. 
 =||= It's not just takeWhile.  It also fails if replace:
.takeWhile(aLong -> aLong < 1)
with:
flatMap(aLong -> (aLong < 1) ? Observable.just(i) : Observable.empty)
 =||= The `takeWhile` issue was fixed in 1.0.6.
 =||= > flatMap(aLong -> (aLong < 1) ? Observable.just(i) : Observable.empty)

I don't understand this one. In the code example, what is variable `i`?

This works in 1.0.6:

``` java
import java.util.concurrent.TimeUnit;

import rx.Observable;

public class IntervalTakeWhileExample {

    public static void main(String... args) {
        Observable
                .<Integer> create(s -> {
                    s.onNext(0);
                    try {
                        Thread.sleep(5);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    s.onNext(1);
                    s.onCompleted();
                })
                .doOnEach(a -> System.out.println(""A ==> "" + a))
                //                .takeWhile(aLong -> aLong < 1)
                .flatMap(aLong -> (aLong < 1) ? Observable.just(aLong) : Observable.empty())
                .doOnEach(b -> System.out.println(""B ==> "" + b))
                .flatMap(aLong -> {
                    return Observable
                            .timer(30, TimeUnit.MILLISECONDS)
                            .doOnUnsubscribe(() -> System.out.println(""unsubscribed timer?""))
                            .doOnEach(c -> System.out.println(""C ==> "" + c))
                            .map(aLong1 -> aLong1 + aLong);
                })
                .doOnEach(d -> System.out.println(""D ==> "" + d))
                .toBlocking().forEach(System.out::println);
    }
}
```
 =||= Is this issue still outstanding with `flatMap()`? I'm seeing a similar behavior where I never get a terminal event after a flatMap
 =||= @felipecsl Could you post a small code example?
 =||= I'll try to write a small sample to reproduce the issue
 =||= Never mind, can't reproduce anymore. Was probably doing something stupid :)
 =||= "TakeWhile: don't unsubscribe downstream.Fixes #2647 issue with TakeWhile.David Karnokakarnokd02/11/15, 09:12:39 PM
2775.02788Confused by behavior of publish+flatten"RxScala 0.23.1 (that means RxJava 1.0.4)

``` scala
import rx.lang.scala.Observable

val o1 = Observable.just(1, 2, 3)
val o2 = Observable.just(10, 20, 30)
val o3 = Observable.just(100, 200, 300)

val roundRobinSource = o1.publish(po1 ⇒ o2.publish(po2 ⇒ o3.publish(po3 ⇒ {
  def oneRound: Observable[Int] = po1.take(1) ++ po2.take(1) ++ po3.take(1)
  Observable.just(oneRound, oneRound, oneRound, oneRound, oneRound).flatten
})))
roundRobinSource.subscribe(println, println)
```

gives me

```
1
10
100
1
20
200
1
30
300
1
1
```

That just bemuses me. Why am I getting an infinite stream of ones for the first observable, but for the others it seems OK. And I'm not even sure that the behavior of others is what I'd expect according to the documentation stating that `publish` _Returns a rx.lang.scala.observables.ConnectableObservable, which waits until the connect function is called before it begins emitting items from this rx.lang.scala.Observable to those rx.lang.scala.Observers that have subscribed to_. It probably is OK, it is just that I'm not able to deduce from that documentation that `publish` is somehow internally keeping track of which items from the published observable have already been emitted and which not even in case of resubscribing to it multiple times...

Can someone enlighten me on this, please?""I think it's because #2596: When zero subscriber, publish will cache values.
 =||= "Fix the bug that 'publish' will cache items when no subscriberFixed #2775 and #2596Shixiong Zhuzsxwing03/04/15, 09:54:42 PM
2844.02845ConcatMap combined with Delay causes a hang"The following code:

``` java
public class Test {
    public static void main(final String[] arg) throws Exception {
        Observable.just(1)
                .repeat()
                .concatMap(x -> {
                    System.out.println(x);
                    return Observable.empty()
                            .delay(1, TimeUnit.SECONDS);
                })
                .subscribe();

        Thread.sleep(Long.MAX_VALUE);
    }
}
```

Prints out two ""1""s quickly, and then another ""1"" every second afterward.

If you change that code just slightly two use the two argument form of `just()` as in:

``` java
public class Test {
    public static void main(final String[] arg) throws Exception {
        Observable.just(1, 2)
                .repeat()
                .concatMap(x -> {
                    System.out.println(x);
                    return Observable.empty()
                            .delay(1, TimeUnit.SECONDS);
                })
                .subscribe();

        Thread.sleep(Long.MAX_VALUE);
    }
}
```

Then, it prints ""1"", then ""2"", and then hangs and doesn't do anything afterward.

I have no idea whats going on, but, I don't think that the 2nd piece of code should hang if the first one doesn't.

I tested with 1.0.8 and didn't find any similar looking issue with a quick look.""Thanks. This is a bug with `repeat()` and the fix is in #2845.
 =||= "Fix for repeat: wrong target of requestFixes #2844.David Karnokakarnokd03/25/15, 03:55:11 PM
2850.02851Using merge() with throttleWithTimeout() leads to MissingBackpressureException"Repro: https://bitbucket.org/marshallpierce/rxjava-merge-backpressure

In text, here's what I'm doing: I have two observables: `Observable.never()`, and another that emits every 200ms. I `merge()` those two and `throttleWithTimeout()` the result with a long timeout. In a few seconds, I'll get this:

```
rx.exceptions.MissingBackpressureException
    at rx.internal.util.RxRingBuffer.onNext(RxRingBuffer.java:349)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.enqueue(OperatorMerge.java:721)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.emit(OperatorMerge.java:698)
    at rx.internal.operators.OperatorMerge$InnerSubscriber.onNext(OperatorMerge.java:586)
    at rx.subjects.SubjectSubscriptionManager$SubjectObserver.onNext(SubjectSubscriptionManager.java:224)
    at rx.subjects.PublishSubject.onNext(PublishSubject.java:114)
    at org.mpierce.rxjava.merge.ExperimentMain.lambda$main$0(ExperimentMain.java:25)
    at org.mpierce.rxjava.merge.ExperimentMain$$Lambda$1/1685538367.call(Unknown Source)
    at rx.Scheduler$Worker$1.call(Scheduler.java:120)
    at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55)
    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
    at java.util.concurrent.FutureTask.run(FutureTask.java:266)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
    at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at java.lang.Thread.run(Thread.java:745)
```

Instead, I would expect that the combo of merge & throttle should simply result in throttle working as expected (never emitting, in this case).""Inserting a PublishSubject between the merge and throttle calls leads to normal operation (no backpressure exception).
 =||= I've been looking into this with Marshall, here's some more oddities:

```
Observable.interval(200, MILLISECONDS)
    .mergeWith(Observable.just(500L))
    .debounce(500, MILLISECONDS)
    .observeOn(Schedulers.newThread())
    .subscribe(
        (i) -> System.out.println(""Got "" + i),
        (t) -> {
            t.printStackTrace();
        }
    );
```

If you remove mergeWith, debounce, or observeOn, it works fine. All three are needed to create a failure situation.

What's weirder is that, given the 200ms interval but 500ms debounce, the subscriber should basically never get onNext (by my understanding). Yet it actually does start to emit items (before the backpressure error kicks in).
 =||= Oh, and one other thing: I tried using an `DebugHook` from RxJavaDebug to look into the situation, but with the hook attached it worked fine, which mystifies me further.
 =||= Could you test #2851?
 =||= The change in #2851 prevents the error I'm seeing.
 =||= @marshallpierce thanks for confirming it.
 =||= @benjchristensen can we get #2851  into v 1.0.9 . :) 
 =||= @yogurtearl merged.
 =||= "Add 'request(Long.MAX_VALUE)' in 'onStart' to fix the backpressure issue of debounce"Fixed #2850.

The issue is because OperatorDebounceWithTime will swallow values but not request more items. Just add `request(Long.MAX_VALUE)` since it doesn't support backpressure."Shixiong Zhuzsxwing04/02/15, 04:24:48 PM
2853.02854AbstractOnSubscribe throws exception when onNext contains a request for more "`AbstractOnSubscribe` improperly throws an exception when the `onNext` method in a subscriber makes a call to `request` (all calls synchronous). The error thrown is this:

```
java.lang.IllegalStateException: This is not reentrant nor threadsafe!
    at rx.observables.AbstractOnSubscribe$SubscriptionState.use(AbstractOnSubscribe.java:590)
    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:360)
    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:345)
    at rx.Subscriber.request(Subscriber.java:145)
    at rx.observables.AbstractOnSubscribeTest$20.onNext(AbstractOnSubscribeTest.java:541)
    at rx.observables.AbstractOnSubscribeTest$20.onNext(AbstractOnSubscribeTest.java:1)
    at rx.observers.SafeSubscriber.onNext(SafeSubscriber.java:130)
    at rx.observables.AbstractOnSubscribe$SubscriptionState.accept(AbstractOnSubscribe.java:533)
    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.doNext(AbstractOnSubscribe.java:367)
    at rx.observables.AbstractOnSubscribe$SubscriptionProducer.request(AbstractOnSubscribe.java:337)
    at rx.Subscriber.setProducer(Subscriber.java:175)
    at rx.Subscriber.setProducer(Subscriber.java:171)
    at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:191)
    at rx.observables.AbstractOnSubscribe.call(AbstractOnSubscribe.java:1)
    at rx.Observable.subscribe(Observable.java:7585)
    at rx.observables.AbstractOnSubscribeTest.testCanRequestInOnNext(AbstractOnSubscribeTest.java:527)
```

Here's a failing unit test:

``` java
    @Test
    public void testCanRequestInOnNext() {
        AbstractOnSubscribe<Integer, Void> aos = new AbstractOnSubscribe<Integer, Void>() {
            @Override
            protected void next(SubscriptionState<Integer, Void> state) {
                state.onNext(1);
                state.onCompleted();
            }
        };
        final AtomicReference<Throwable> exception = new AtomicReference<Throwable>();
        aos.toObservable().subscribe(new Subscriber<Integer>() {

            @Override
            public void onCompleted() {

            }

            @Override
            public void onError(Throwable e) {
                exception.set(e);
            }

            @Override
            public void onNext(Integer t) {
                request(1);
            }
        });
        if (exception.get()!=null)
            exception.get().printStackTrace();
        assertNull(exception.get());
    }
```"Fixes wrong request accounting in AbstractOnSubscribeFixes #2853.David Karnokakarnokd04/07/15, 05:14:21 PM
2896.02897window() emitting overlapping items"I've seen this in 1.07 and 1.09 - using http://reactivex.io/RxJava/javadoc/rx/Observable.html#window(rx.functions.Func0), I am able to observe overlapping items in the output. 

Example test case here:  https://gist.github.com/gjesse/1ae59c32f63d2ad581e8""Thanks y'all!
 =||= "Fix for overlapping windows. "Source was emitting t multiple times while holding queue.

Fixes #2896"Alex Wenckusalexwen04/21/15, 03:58:22 PM
3119.03121NewThreadWorker.tryEnableCancelPolicy doing costly reflection on Android"I was  analyzing startup time in the NY Times Android app and started method profiling on startup using Android Device Monitor.  Total time from the beginning of the application class to end of onCreate for first activity is roughly  2.2seconds. Diving deeper I was able to observe that `NewThreadWorker.tryEnableCancelPolicy`
 was taking 1200ms to execute with the offending line being  
`for (Method m : exec.getClass().getMethods())` (1017ms)
Diving deeper shows a call to 
`CollectionUtils.removeDuplicates (992 ms)`  
which will call 
`collection.sort` (719ms)
 & 
`reflect.compare`(259ms).

tryEnableCancelPolicy has the following comment: 

``` /**
     * Tries to enable the Java 7+ setRemoveOnCancelPolicy.
     * <p>{@code public} visibility reason: called from other package(s) within RxJava.
     * If the method returns false, the {@link #registerExecutor(ScheduledThreadPoolExecutor)} may
     * be called to enable the backup option of purging the executors.
     * @param exec the executor to call setRemoveOnCaneclPolicy if available.
     * @return true if the policy was successfully enabled 
     */ 
```

I tried creating a Scheduler from an Executor but still hit the offending code.  Is there a way to avoid this code or fix the large performance hit that it is causing?""Woah. If the signature of the to-be-reflected method is known why is a direct lookup not being done?
 =||= @digitalbuddha You can use the system property ""rx.scheduler.jdk6.purge-force"" set to ""true"" to avoid the loop. The reason for the loop is to avoid NoSuchMethodException being thrown on JDK 6 which is more costly than looping through ~70 methods. Although I admit evaluating that all the time is unnecessary as Executors.newScheduledExecutor() won't change is ability during runtime.
 =||= Thankfully that property _just_ squeezes under Android's 31 character max at 29 chars!
 =||= Can we use `PlatformDependent.isAndroid()` to default this to `true`?
 =||= My google search indicates the method `setRemoveOnCancelPolicy` is supported from API level 22. If there could be a way to discover the API level programmatically and cross-platform safe then sure.
 =||= The `android.os.Build.VERSION` class has an `SDK_INT` int constant which can be read. The presence of the class could replace the check for `android.app.Application`.
 =||= @akarnokd what do you mean by 

>  cross-platform safe

? `android.os.Build.VERSION` is safe to call for all Android versions. 

Documentation: http://developer.android.com/reference/android/os/Build.VERSION.html#SDK_INT
 =||= Android is one platform
 =||= Great. Would you like to submit a PR?
 =||= Just pushed the PR #3121.

Android [supports `ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy()` since API 21](http://developer.android.com/reference/java/util/concurrent/ScheduledThreadPoolExecutor.html#setRemoveOnCancelPolicy%28boolean%29).
 =||= Little Gist for those who want to fix this in Android app with RxJava: https://gist.github.com/artem-zinnatullin/51b6c6720ecb8a2a71eb
 =||= Your gist says ""static initializer block"" and then proceeds to use an instance initializer block.
 =||= Such a stupid mistake…Uh. Thanks.
 =||= "Improve performance of NewThreadWorker, disable search for setRemoveOnCancelPolicy() on Android API < 21"Resolves #3119.

This PR adds methods for detecting Android API Version and disables `NewThreadWorker.tryEnableCancelPolicy()` on Android API < 21 which has significant performance cost on Android.

PR also improves performance of `NewThreadWorker.tryEnableCancelPolicy()` via caching Reflection."Artem Zinnatullin :slowpoke:artem-zinnatullin08/01/15, 10:58:18 AM
3156.03169Merge Limiting Concurrency - Can Deadlock"Since the `merge` changes in 1.0.13 we now have a bug in `merge` that limits concurrency and can cause an async ""deadlock"" since not all `Observable`s being merged will be subscribed to. 

These unit tests show the issue:

``` java
    @Test
    public void testUnboundedDefaultConcurrency() {
        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();
        for(int i=0; i < 2000; i++) {
            os.add(Observable.<Integer>never());
        }
        os.add(Observable.range(0, 100));       

        TestSubscriber<Integer> ts = TestSubscriber.create();
        Observable.merge(os).take(1).subscribe(ts);
        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);
        ts.assertValue(0);
        ts.assertCompleted();
    }

    @Test
    public void testConcurrencyLimit() {
        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();
        for(int i=0; i < 2000; i++) {
            os.add(Observable.<Integer>never());
        }
        os.add(Observable.range(0, 100));       

        TestSubscriber<Integer> ts = TestSubscriber.create();
        Observable.merge(os, Integer.MAX_VALUE).take(1).subscribe(ts);
        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);
        ts.assertValue(0);
        ts.assertCompleted();
    }
```

Surprisingly, even when providing the `maxConcurrent` value the issue still happens.

We have bounded **vertical** buffers, but always must default to unbounded **horizontal** buffers, since it is the code that defines how many items are horizontally buffered. This affects both `merge` and `groupBy`. The `maxConcurrent` overload allows a developer to limit the horizontal buffering, and a developer controls the `groupBy` selector.""This shortcoming is much earlier, at least as old as RxRingBuffer and a certain Scalar optimization in merge...
 =||= Scalar is different ... they aren't async so aren't an issue. A scalar ALWAYS has a value in it, thus it will always emit if there is downstream support. 

These unit tests pass if I go back to 1.0.12

``` java
    @Test
    public void testUnboundedDefaultConcurrency() {
        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();
        for(int i=0; i < 2000; i++) {
            os.add(Observable.<Integer>never());
        }
        os.add(Observable.range(0, 100));       

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
        Observable.merge(os).take(1).subscribe(ts);
        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);
        ts.assertValue(0);
        ts.assertCompleted();
    }

    @Test
    public void testConcurrencyLimit() {
        List<Observable<Integer>> os = new ArrayList<Observable<Integer>>();
        for(int i=0; i < 2000; i++) {
            os.add(Observable.<Integer>never());
        }
        os.add(Observable.range(0, 100));       

        TestSubscriber<Integer> ts = new TestSubscriber<Integer>();
        Observable.merge(os, 5000).take(1).subscribe(ts); // reduced to 5000 instead of MAX_VALUE since it causes an OOM
        ts.awaitTerminalEvent(5000, TimeUnit.MILLISECONDS);
        ts.assertValue(0);
        ts.assertCompleted();
    }
```
 =||= In v12, if there were scalars in the input source, the subscribing was held off until some scalars were drained (i.e., in case of an async downstream request): given 1 normal and 128 scalar queued up, the next source wasn't requested until some or all scalars were drained.

In order for the tests to pass, we need an Spsc queue instead of the RxRingBuffer if the maxConcurrency is lesss than max, otherwise, we need an unbounded spsc queue. JCTools' SpscArrayQueue supports only power of 2 capacity so a backpressure violation wouldn't be detected at item 5000 but only at item 8192. SpscUnboundedArrayQueue works if its capacity is at least some value due to a bug in its lookahead-grow logic (8 with defaults). 

V14 merge has the side effect of limiting the tracking array size so the copy-on-write has to work with at most 512 bytes per add/remove.

I happen to have a platform safe SpscArrayQueue with explicit capacity insurance (but still power of 2 memory cost) and a platform safe SpscLinkedArrayQueue (still sensitive to certain capacity settings), courtesy of my rsi flatMap.

I can't do PR for a few days but this is a simple change (provided the tradeoff is understood) and most of the community should be able to pull this off.
 =||= "Merge can now operate in horizontally unbounded mode."Resolves #3156 

Note that since the default merge operation is unbounded, this change could lead to an excessive memory usage when flatMapping fast sources. Note that the pre 1.0.13 version did this albeit on a slighty slower path.

The change also affects the scalar optimization as well. Pre 1.0.13 implicitly limited the concurrency level to RxRingBuffer.SIZE when scalars were received. This version now fills the queue up to the concurrency level.

For 2.0, I suggest having a bounded behavior by default and require the developer to specify Integer.MAX_VALUE to go for the unbounded behavior so he/she knows about the consequences."David Karnokakarnokd11/10/15, 09:39:27 PM
3168.03171BehaviorSubject.scan not picking up initial value"I would expect this:

```
final Observable<Void> ob = BehaviorSubject.create();
ob.scan(0, (accum, x) -> 123)
  .subscribe(x -> {
    Timber.d(""Hit!"");
  });
```

to emit a value (and indeed it does in the equivalent RxJS code).

Is this a bug?""This is odd. The initial value is emitted just before the first accumulated value or a completion event.
 =||= Fix available via #3171.
 =||= "Scan backpressure and first emission fix"Fixes #3168

If there is no initial value, there is no need to manipulate the request amounts.

If there is an initial value, we must do a full emitter-loop with value queueing because now the downstream request can race with the first onNext or the setting of the upstream producer. The downside is the increased overhead which should be reduced when the spsc unbounded queues get merged."David Karnokakarnokd08/28/15, 05:27:44 PM
3385.03417rx.Single - why no `doOnNext()`?"I have a `Single<?>` that I would like to call `.doOnNext()` on. Why is this omitted? I get why `.doOnCompleted()` does not exist, but I want to call a void action once and there seems to be no simple way to do this with `rx.Single`

Technically I could call `.map()`, do my thing, and return the same object - but that seems like too much overhead. Or call `.toObservable().doOnNext().toSingle()`, but I cannot imagine that is too efficient.""Hi. The class received too little attention after it has been added to the library. The 1.x operators are kind of hanging off the `Observable` so currently you can't do better than `map()`.

If you are interested, you can port back operators from the 2.x version (https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Single.java#L1073)
 =||= So I guess `doOnSuccess()` is the equivalent in `Single` for `doOnNext()` of `Observable`? =||= The `doOnX` matches the parent reactive type's terminology, thus `Single` has `onSuccess` -> `doOnSuccess`. Same for v2 `Maybe.onSuccess`. =||= "Add Single.doOnSuccess()Closes #3385.Artem Zinnatullin :slowpoke:artem-zinnatullin10/09/15, 01:54:21 AM
3490.03491scan infinite loop"The following test fails in 1.x (and 1.0.15):

``` java
    @Test(timeout=1000)
    public void testScanDoesNotHang() {
        Observable.range(0, Integer.MAX_VALUE)
                //
                .scan(1, new Func2<Integer, Integer, Integer>() {

                    @Override
                    public Integer call(Integer t1, Integer t2) {
                        return t1;
                    }
                })
                //
                .subscribe(new Subscriber<Integer>() {

                    int count = 0;

                    @Override
                    public void onCompleted() {

                    }

                    @Override
                    public void onError(Throwable e) {

                    }

                    @Override
                    public void onNext(Integer t) {
                        count++;
                        if (count == 2)
                            unsubscribe();
                    }
                });
    }
```

@akarnokd  I've stepped through in a debugger and in `OperatorScan` L284 initiates a fast path emission in `OnSubscriberRange` which calls `OperatorScan.emit()` L289 but because the method containing L284 has set `emitting` to true the emission goes no further and an a loop occurs that fills the heap.

Though the test might look a bit contrived I just isolated the behaviour to `scan` for the test. I encountered the bug when this hung:

``` java
observable.scan(..).elementAt(n); //where n > 1
```

I'd rank this bug as nasty (not an improbable edge case like some concurrency bugs) and possibly deserving of a new release quickly.""You are right. Serializing the requesting/producer arrival with the normal event emission is unnecessary. I'll merge #3485 now but start working on the fix in my morning. I'll review other operators that might exhibit the same problem.
 =||= Thanks @akarnokd 
 =||= See #3491 for the fix.
 =||= "1.x: make scan's delayed Producer independent of event serialization"It turns out serializing `request()` calls with regular `onXXX()` calls can be problematic because a `request()` may trigger an emission of events which then end up being queued (since `emitting == true`). If the request is large and the queue otherwise unbounded, this will likely cause OOME.

In case of `scan`, the fix was to make the missing request accounting and arrival of the `Producer` independent of the event's emitter loop; there is no need for them to be serialized in respect to each other.

In case of the `ProducerObserverArbiter` where the request accounting and producer swapping has to be serialized with the value emission, the solution is to call `request()` outside the emitter-loop.

There shouldn't be any issue with 2.x `scan()` because in 2.x, scan receives the `Subscription` before it allows the downstream to request anything so there is no missing requested to be handled.

This should resolve #3490. As far as I can remember, no other operator should have such problems because all others use `ProducerArbiter` which is independent of `onXXX` emission serializations."David Karnokakarnokd12/02/15, 07:36:49 PM
3595.03696Execution hook for Single`RxJavaObservableExecutionHook` is not compatible with [`Single`](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Single.java) type. For example: [`RxJavaObservableExecutionHook#onCreate`](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/plugins/RxJavaObservableExecutionHook.java#L54) method tooks [`Observable#OnSubscribe`](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Observable.java#L101) type as a parameter. However, `Single` is using it's own [`OnSubscribe`](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Single.java#L149) type. Shall we implement new class to handle `Single`'s hooks let's say `RxJavaSingleExecutionHook` ?"Would you like to post a PR for this?
 =||= If you agree with my proposition then I will create PR for that feature for sure.
 =||= I don't see anything wrong upfront so go ahead with the PR.
 =||= "1.x: Added Single execution hooksResolves #3595Paweł Hajdukphajduk03/17/16, 12:13:16 PM
3700.03701Make Observable.doOnCompleted name match Completable.doOnComplete in 1.x"`Observable` has a `doOnCompleted` method (past tense), and `Completable` has `doOnComplete` (present tense). The 2.x branch changes `Observable`'s method to be present tense. The 1.x branch can add alias the past tense method in `Observable` and deprecate it.

I'm happy to make the change if this is approved.""Sure.
 =||= "1.x: Add Completable.doOnCompleted and deprecate Completable.doOnCompleteCloses #3700.Zach Klippensteinzach-klippenstein02/14/16, 10:24:25 AM
3440.03766Single.onErrorResumeNext"Observable has a onErrorResumeNext to continue with a new Observable if onError is called. I'd like something similar for Single, so:

``` java
Single<T> onErrorResumeNext(Single<? extends T> resumeSingle)

Single<T> onErrorResumeNext(Func1<? super Throwable, ? extends Single<? extends T>> resumeFunction)
```

Single already has onErrorReturn, it makes sense to have onErrorResumeNext as well.""related: https://groups.google.com/forum/#!topic/rxjava/vCMxB6CY88w
 =||= I'll work on this.
 =||= @akarnokd I can do it in 2 ways: 
1. Convert `Single` to `Observable` and `lift` already implemented and tested `OperatorOnErrorResumeNextViaFunction` and `OperatorOnErrorResumeNextViaObservable`.
2. Re-implement these operators for `Single`, it may give some performance boost, but adds two classes to the library.

I guess you'll vote for 2nd way, but I think it worth to ask :)
 =||= Frankly, I'm not satisfied with 1.x Single and how it tries to reuse Observable components; it leads to wrappers and un-wrappers and so on even for the trivial operators. If they were `retryWhen` then I'd say convert back and forth like I do with 2.x. So yes, I vote for option 2.
 =||= ok, no problem :)
 =||= "1.x: Add Single.onErrorResumeNext(Func)Closes #3440, closes #3731, closes #3472 (whoa, 3 issues at a time!)Artem Zinnatullin :slowpoke:artem-zinnatullin03/15/16, 11:57:39 PM
3731.03766Request: Single.onErrorResumeNext(Func1<? super Throwable, Single<? extends T>> resumeFunction)"To match `Observable`'s.

```
public Single<V> onErrorResumeNext(Func1<? super Throwable, Single<? extends T>> resumeFunction);
```""We are also interested in this feature. Currently we are in the process of switching `Observable` to `Single` where it makes sense. Not having this feature is blocking us. Since we would use this internally and not expose the details to users, does anybody know a workaround for accessing the `Throwable`?
 =||= Since we are just interested in mapping the emitted exception to something else, here is something that just occurred to me. It's ugly, but it seems that it works as a temporary workaround in our use case. It may be useful for others too, so here it is:

``` java
single.onErrorReturn(throwable -> {
    throw mapException(throwable);
});
```

Where `mapException` maps the `Throwable` to one of our exceptions.
 =||= Isn't this a dupe of #3440 ?
 =||= Yes, you're right. It's a duplicate.
 =||= "1.x: Add Single.onErrorResumeNext(Func)Closes #3440, closes #3731, closes #3472 (whoa, 3 issues at a time!)Artem Zinnatullin :slowpoke:artem-zinnatullin03/15/16, 11:57:39 PM
3472.03766Flatmap Single into Observable and ignore errors"I have UI observable which should work as long as my UI lives. When my UI emits I create a network request which could be an Observable or a Single. A Single fits best for a network call.

``` java
RxView.clicks(myButton)
    .flatMap(v - > networkRequest())
    .subscribe(data -> showSomething(data),
            e -> {
                // should only be called when the RxView.clicks() throws. 
                // should not be called for network errors
            });
```

When using an Observable I would use `onErrorResumeNext` returning `Observable.empty()` to prevent errors coming from the network request going into my UI Observable and calling `onError` because the UI Observable should life forever:

``` java
Observable networkRequest() {
    mApiService.fireActionObservable()
        .onErrorResumeNext(throwable -> {
            // somehow handle error here
            return Observable.empty();
     });
}
```

This, in my opinion, elegant way does not work for Single because no `Single.empty()` exists.

``` java
Single networkRequest() {
    mApiService.fireActionSingle()
        .onErrorResumeNext(throwable -> {
            // somehow handle error here
            return Single.empty(); // <-- does not exist. I have to call success or error :/
     });
}
```

`Single.onErrorResumeNext` is btw only available in 2.x

Converting my `Single` to an `Observable` seems wrong, because the network request is a `Single`!""`Single.empty()` doesn't make sense because `Single` has to emit either an `onSuccess` or an `onError`. The best you can do is to have a `Single.just()` with a normal value that represents emptiness.

Generally, this is why I'm skeptic about `Single` and `Completable` because `Observable` can ""emulate"" both and the overhead in true async use is negligible.
 =||= My current solution wraps my Singles:

``` java
    public static <T> Observable<T> onErrorResumeNext(final Single<T> single,
            final Observable<? extends T> resumeSequence) {
        return single.toObservable().onErrorResumeNext(resumeSequence);
    }

    public static <T> Observable<T> onErrorResumeNext(final Single<T> single,
            final Func1<Throwable, ? extends Observable<? extends T>> resumeFunction) {
        return single.toObservable().onErrorResumeNext(resumeFunction);
    }
```

``` java
RxView.clicks(myButton)
    .flatMap(v - > onErrorResumeNext(networkRequest(),
            throwable -> {
            // somehow handle error here
            return Observable.empty();
     }))
    .subscribe(data -> showSomething(data),
            e -> {
                // only called when the RxView.clicks() throws
            });
```

@benjchristensen what happened to the [initial idea](https://github.com/ReactiveX/RxJava/issues/1594#issuecomment-101300655) of heaving a `Single` with 3 final states?

> A Single will always behave in one of 3 ways:
> 
> 1) respond with an error
> 2) never respond
> 3) respond with a success

I was hoping a `Single` is a `Observable` where I don't have to care about multiple items. Nothing more. Like `Observable#single()` but with zero item support and type safetyness.
 =||= @artem-zinnatullin I'm starting to loose what is implemented where. Do you work on `Single.onErrorResumeNext(Func1)`?
 =||= @akarnokd damn… will submit PR today/tomorrow!
 =||= My solution:
RxView.clicks(myButton)
    .flatMap(v - > networkRequest())
    .compose(exceptionHandling())
    .subscribe(data -> showSomething(data),
            e -> {
                // Now you should remove this lambda as it will never be called.
            });
Final: 
RxView.clicks(myButton)
    .flatMap(v - > networkRequest())
    .compose(exceptionHandling())
    .subscribe(data -> showSomething(data));
exceptionHandling:
   protected  <T> ObservableTransformer<T, T> exceptionHandling() {
        return observable ->
                observable
                        .doOnError(t ->{ /* handle error here */})
                        .retry(); // Ignore error to keep subscription.
    }
 =||= "1.x: Add Single.onErrorResumeNext(Func)Closes #3440, closes #3731, closes #3472 (whoa, 3 issues at a time!)Artem Zinnatullin :slowpoke:artem-zinnatullin03/15/16, 11:57:39 PM
3751.03777Confusion when using Backpressure operators"Hey,

We have a use case in which a consumer might not be able to process items fast enough than what is emitted from a source observable. I understood that in this case, a backpressure with either `onBackPressureBuffer()` or `onBackPressureDrop()` might be useful. In case of overflow / drop, we would like to store items to a local storage and try processing them later when the consumer in this case is again able to handle the input rate. Our consumer is actually a remote REST call which might timeout or not be available in which case we retry.

Anyways, I tried alternative ways to address the problem but I can't find a suitable way to solve it. To illustrate my testings, here is some code:

```
package io.reactivex;

import org.junit.Test;
import rx.Observable;
import rx.Subscriber;
import rx.schedulers.Schedulers;

public class BackPressureTest {
    @Test
    public void testOnBackPressureDrop() throws InterruptedException {
        Observable<Integer> emitter = toObservable()
                .subscribeOn(Schedulers.newThread());

        emitter.onBackpressureDrop(i -> System.out.println(""Dropped "" + i))
                .observeOn(Schedulers.computation())
                .map(this::doWork)
                .doOnNext(i -> System.out.println(""Output "" + i))
                .toBlocking()
                .subscribe(new SingleItemSubscriber<>());
    }

    @Test
    public void testOnBackPressureBuffer() throws InterruptedException {
        Observable<Integer> emitter = toObservable()
                .subscribeOn(Schedulers.newThread());

        emitter.onBackpressureBuffer(2, () -> System.out.println(""Overflow""))
                .observeOn(Schedulers.computation())
                .map(this::doWork)
                .doOnNext(i -> System.out.println(""Output "" + i))
                .toBlocking()
                .subscribe(i -> System.out.println(""Subscriber received "" + i));
    }

    private Observable<Integer> toObservable() {
        return Observable.create(subscriber -> {
            for (int i = 0; i < 10; i++) {
                System.out.println(""Emitting "" + i);

                subscriber.onNext(i);

                try {
                    Thread.sleep(250);
                } catch (InterruptedException e) {
                    subscriber.onError(e);
                }
            }

            subscriber.onCompleted();
        });
    }

    private int doWork(int integer) {
        System.out.println(""Consuming "" + integer);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return integer;
    }

    private static class SingleItemSubscriber<T> extends Subscriber<T> {
        @Override
        public void onStart() {
            request(1);
        }

        @Override
        public void onCompleted() {

        }

        @Override
        public void onError(Throwable e) {

        }

        @Override
        public void onNext(T t) {
            System.out.println(""Subscriber received "" + t);
            request(1);
        }
    }
}
```

In `testOnBackPressureDrop()` I would assume that after the `emitter` has queued some items, it would start dropping them. However, it seems that the backpressure operation subscription gets a receive size of 128 items. 128 items in memory in this case is far too much for us and we would like to control the size of the request items.

In `testOnBackPressureBuffer()` I would assume that the `emitter` would overflow after emitting more than two items into the buffer.

However, in neither of the cases, I don't experience an oveflow or dropped items. Also I realized that when using `onBackPressureBuffer()` it seems that in overflow, the observable emits `onError()`. To me that wouldn't be an option since I want the `emitter` to continue and I wan't to deal with the problem myself.

Could you please instruct me that what we are missing here or are we trying to do something that is not yet even possible, e.g. is the API missing an operator like `onBackPressureBufferAndDrop(int capacity, Action1 onDrop)`?

I wrote my tests based on the documentation in https://github.com/ReactiveX/RxJava/wiki/Backpressure""It seems your source doesn't emit enough values thus the default buffer of 128 elements in `observeOn` can hold all of it without backpressure. The `onBackpressureBuffer(int)` behavior is expected and is there to give room to bursty sources but fail on sustained backpressure to prompt the developer to reevaluate the flow.

There is a [PR](https://github.com/ReactiveX/RxJava/pull/3487) in limbo that tries to address this buffer behavior by allowing dropping, but if you want to queue on disk, you have to write a custom operator.
 =||= I've bumped into the queueing on disk use case a few times but haven't implemented anything. I'll have a look (probably in a couple of weeks).
 =||= I see.

The challenge with the PR above is that currently the overflow function does not supply the item(s) which caused the overflow. It is just a void action (`Action0`). Changing that to e.g. `Action1` would probably break the semantics of the original `onBackPressureBuffer()` API so I guess the naming would need to be reconsidered for a new API if it would accept a `Action1` type function.

Based on @akarnokd's comment, we should not use the buffer backpressure but ideally it seems that the current implementation of `onBackpressureDrop(Action1<? super T> onDrop)` is close what I'm after here but I would need to be able to control the size of the default internal buffer (128 now). We can write a custom operator of course but I was just wondering would this be something other may benefit if part of the `Observable` API? When using the current implementation of drop you have very little control when the dropping starts to happen and in our case we can calculate a value for the buffer based on the characteristics and configuration of the application.

The term ""buffer"" fooled me a bit in the API docs and I assumed that the capacity controls the size after which the source observable starts to overflow. Would it make sense to clarify that documentation at least and mention that there is an internal buffer which can hold actually more items than what you specify as your overflow buffer? 

Thanks for the quick reply!
 =||= I've hit this a number of times and generally ended up turning most .observeOn() into .onBackpressureBuffer().observeOn(), I guess the ability to control the 128 size buffer as an optional parameter to observeOn would be a nice addition.
 =||= @srvaroa PR welcome.
 =||= "observeOn: allow configurable buffer size"The observeOn operator is backed by a small queue of 128 slots that may
overflow quickly on slow producers.  This could only be avoided by
adding a backpressure operator before the observeOn (not only
inconvenient, but also taking a perf. hit as it forces hops between two
queues).

This patch allows modifying the default queue size on the observeOn
operator.

Fixes: #3751
Signed-off-by: Galo Navarro anglorvaroa@gmail.com"Galo Navarrosrvaroa03/23/16, 10:41:13 PM
3784.03789Single.zip on empty collection never terminate"``` java
Single.zip(new ArrayList<Single<Integer>>(), i -> i)
          .doAfterTerminate(() -> System.out.println(""terminated""))
          .subscribe();
```

this behavior is different from `Observable.zip`

``` java
Observable.zip(new ArrayList<Observable<Integer>>(), i -> i)
                   .doAfterTerminate(() -> System.out.println(""terminated""))
                   .subscribe();
```""What do you expect it to do? Throw error? Single either emits one result or throws error. 

Looks like the best we can do is to throw something like `IllegalArgumentException`. 
 =||= Observable.zip just completes if there are no sources. If one converts an empty Observable to single, it produces a NoSuchElementException error.
 =||= I'll check this and work on PR soon. 
 =||= "1.x: Prevent Single.zip() of zero SinglesCloses #3784.Artem Zinnatullin :slowpoke:artem-zinnatullin03/23/16, 10:33:02 PM
3161.03790'lift(final Operator<? extends R, ? super T>)' has private access in 'rx.Single'"I was expecting `Single#lift()` to be part of the public API like `Observable#lift()`. Is there a reason for this restriction?

`Single#compose()` is public, too (and links to `#lift()` in the docs). I guess the private access is just a bug.

https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/Single.java#L176

My workaround:

```
Single.just(""value"")
        .toObservable()
        .lift(myOperator)
        .toSingle();
```""Single is in experimental phase, its API is not stable and there wasn't enough confidence to open up many of the methods, including lift.
 =||= I think the time has come to expose `Single.lift()`. PRs welcome.
 =||= "1.x: Expose Single.lift()Closes #3161.Artem Zinnatullin :slowpoke:artem-zinnatullin03/23/16, 10:32:49 PM
3865.03866flatMap from Single to Completable"Is there an easy way of doing a `flatMap` from a `Single` to a `Completable`?

Currently I need to do something like this:

``` java
 Completable saveData(Data data) {
      ... 
 }

 Single.just(data)
        .flatMapObservable(new Func1<Data, Observable<?>>() {
            @Override
            public Observable<?> call(Data data) {
                return saveData(data).toObservable();
            }
        })
        .toCompletable();
```

I think It would be good to have an operator like `Single.flatMapCompletable()` so we could do:

``` java
Single.just(data)
        .flatMapCompletable(new Func1<Data, Completable>() {
            @Override
            public Completable call(Data data) {
                return saveData(data);
            }
        });
```""At the moment you can pass the `Single` to `Completable.fromSingle()`, I'll submit a PR for `Single.toCompletable()`.
 =||= I'm not sure this issue is resolved by adding `Single.toCompletable()`? 

My question was how to ""link"" a `Single` to a `Completable` using an operator like `flatMap` so that the `Completable` can use the result from the `Single`. If I transform my source `Single` to a completable using `Single.toCompletable()` then the value is lost.

My suggestion is to add `Single.flatMapCompletable()`. 
 =||= > so that the `Completable` can use the result from the `Single`

`Completable` is value-less type, you won't be able to use result from `Single` or `Observable`. It was created to replace `Observable<Void> / Single<Void>` when you just need to perform some side-effect work.

Can you use `Single` instead of `Completable`?
 =||= So If I have a method in class `A` like this:

``` java
Completable saveData(Data data) {
     // Creates and returns a Completable that saves some data in local storage
}
```

Then in class `B` I have a method that retrieves some data from a REST API 

``` java
Single<Data> retrieveData() {
     // Creates and returns a Single that gets some data
}
```

Now from class `C` I want to `flatMap` both methods so when `retrieveData()` completes I can pass the result to `saveData(data)`. Are you suggesting that `saveData(data)` should return a `Single` instead of a `Completable`? I would imagine a `Completable` is a better option because I don't care about the value after it's been saved. 
 =||= If you want final result to be `Completable` then one way is to do:

``` java
Completable result = retrieveData()
  .flatMap(data -> saveData(data).toSingle(() -> """")) // Just emit something.
  .toCompletable()
```

If you want final result to be `Single` then one way to do this:

``` java
Single<Data> result = retrieveData()
  .flatMap(data -> saveData(data).toSingle(() -> data))
```
 =||= Yeah, that makes sense. I want the final result to be a `Completable` so the first option would work for me. However it seems a bit redundant having to call `toSingle()` and then call `toCompletable()`. That's why I was thinking that adding a new operator like `single.flatMapCompletable()` could be useful. 
Thanks. 
 =||= A simple extension function in Kotlin would be the following:

``` Kotlin
fun <T> Single<T>.flatMapCompletable(producer: (T) -> Completable): Completable {
    return Completable.create { subscriber ->
        subscribe(
              { producer(it).subscribe(subscriber) },
              { subscriber.onError(it) }
        )
    }
}
```
 =||= Could this please be re-opened? The scenario with a save method seems like a prime use case for `Completable`. To say that you can't go from Single to a nested save is pretty hard to accept.
 =||= There is the PR #4226 for that.
 =||= Didn't see that thanks!
 =||= "1.x: Add Single.toCompletable()Closes #3865.Artem Zinnatullin :slowpoke:artem-zinnatullin04/19/16, 06:18:23 AM
3724.03879APIs for easily changing the thread priority of default schedulers via hook."On Android, the main thread is a sacred holy land at which we must all worship. As such this means other threads (ideally) shouldn't be favorably scheduled in priority with it. For network and filesystem operations this usually means using low priority threads.

One solution is to just use low priority threads on our own schedulers, but this doesn't affect code using the standard `io()` and `computation()` schedulers. Unfortunately there's a whole bunch of ceremony around how various schedulers are initialized which includes a mixed bag of public vs. non-public types and APIs which makes replacing them in a scheduler hook difficult.

I think the most easy way to accomplish this is the following:
- [x] ~~`RxThreadFactory` constructor overload which takes a thread priority to use.~~ Not needed.
- [ ] Factory methods on `Schedulers` for creating instances of `io()`, `computation()`, and `newThread()` except using a supplied `ThreadFactory`
  - [ ] `Schedulers.createIoScheduler(ThreadFactory)`
  - [ ] `Schedulers.createComputationScheduler(ThreadFactory)`
  - [ ] `Schedulers.createNewThreadScheduler(ThreadFactory)`

Nice to have:
- [x] `Schedulers` using these factory methods to create the default implementations. This involves moving the thread factories from the individual types ""up"" to `Shedulers`.""Happy to do some of the work if this sounds acceptable.
 =||= @JakeWharton I think that sound acceptable, I'm happy to review your PR.
 =||= This is a little more tricky than I had initially anticipated. Perhaps it's worth talking about a means of setting the default priority of the internal thread pools through a mechanism like properties as a separate, easier first step? Plus that would be a lot lower-overhead for Android users anyway, and we could even use the existing Android platform detection to lower the thread priority by default.
 =||= Pass a ThreadFactory

On Fri, Jan 20, 2017, 10:48 PM erDaren <notifications@github.com> wrote:

> so, how to set thread priority in android with android values(like
> Process.THREAD_PRIORITY_BACKGROUND)?
>
> —
> You are receiving this because you were mentioned.
>
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/3724#issuecomment-274242173>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEEUOSEQqdFAeQocjdNnUfjwJ8gjubks5rUaorgaJpZM4Heynt>
> .
>
 =||= "Expose scheduler factories which accept thread factories."This allows hooks to create schedulers whose threads have different priorities.

Closes #3724."Jake WhartonJakeWharton04/29/16, 06:13:19 PM
3881.03883Single not calling doAfterTerminate when used in flatMap"I've noticed that when I return a Single from a flatMap and that Single calls doAfterTerminate(Action0) the Action0's call method is never called.  This behaviour is not consistent with what happens when you do the same thing with an Observable.  I am using 1.1.3

When I run:

``` java
Single.just(""Test"")
    .flatMap(s -> 
        Single.just(""Test2"")
            .doAfterTerminate(() -> System.out.println(""singleFlatMapDoAfterTerminate""))
        )
.doAfterTerminate(() -> System.out.println(""singleDoAfterTerminate""))
.subscribe(new TestSubscriber<String>());
```

I would expect the following to be printed to the console:

> singleDoAfterTerminate
> singleFlatMapDoAfterTerminate

However only the following is printed to the console

> singleDoAfterTerminate

When I do the same with an Observable

``` java
Observable.just(""Test"")
    .flatMap(s -> Observable.just(""Test2"")
        .doAfterTerminate(() -> System.out.println(""observableFlatMapDoAfterTerminate""))
     )
.doAfterTerminate(() -> System.out.println(""observableDoAfterTerminate""))
.subscribe(new TestSubscriber<String>());`
```

I see the following printed to the console:

> observableDoAfterTerminate
> observableFlatMapDoAfterTerminate""Interesting.
 =||= Thanks for reporting. See #3883 for a fix.
 =||= This works for me.
 =||= "1.x: fix multiple chained Single.doAfterTerminate not calling actions"Resolves #3881.

The bug is caused by the impedance mismatch between `Observable`'s `Subscriber` and `Single`'s `SingleSubscriber`. The original code called `onNext()` which immediately signalled an `onSuccess` but also caused an unsubscription, preventing a delivery of `onCompleted()` in the inner Single.

The fix keeps `onSuccess`/`onError` rails intact  throughout the chain."David Karnokakarnokd04/29/16, 09:43:36 PM
3885.03886onCompleted swallows all exceptions"I was fairly surprised by the behavior of this stream:

``` java
Observable.empty()
    .subscribe(
        System.out::println, 
        System.err::println,
        () -> { throw new RuntimeException(); }
    );
```

What I expected to see was the thread crashing due to the exception; instead absolutely nothing happens because `onCompleted` swallows the exception entirely.""`SafeSubscriber.OnCompleted` rethrows it as `OnCompletedFailedException` which then bounced back to `onError` because `throwIfFatal` doesn't recognize it (only `OnErrorNotImplementedException` and `OnErrorFailedException` are rethrown from this class of failures).
 =||= Would a reasonable solution be to add `OnCompletedFailedException` to `throwIfFatal`, then? I could work on that PR if that's all it takes.
 =||= Yes, go ahead.
 =||= "throwIfFatal() now throws OnCompletedFailedException"Otherwise, if there's an error in onCompleted, the exception is
swallowed and unreported.

Fixes #3885"Daniel Lewdlew04/29/16, 05:56:57 AM
3925.03928JavaDoc needs update after last releaseFor example, `Observable.create(AsyncOnSubscribe)` [does not exist](http://reactivex.io/RxJava/javadoc/rx/Observable.html#create%28rx.observables.AsyncOnSubscribe%29)."Closed via #3928 
 =||= "Update RxJava Javadoc to  1.1.5Closes #3925Shixiong Zhuzsxwing05/11/16, 05:19:10 PM
3985.03986Proposal: Make Schedulers should be more friendly to tests"`RxJavaPlugins.reset()` was recently made public, but there was a common misconception that this would also reset schedulers. This isn't the case however since Schedulers permanently cache their resolved schedulers, so `RxJavaPlugins.reset()` actually doesn't help in this regard. 

I'd like to propose adding a `Schedulers.reset()` function as well. It comes with same caveats that `RxJavaPlugins.reset()` has in that it's dangerous to call in live code, but it would be enormously helpful in testing. This would simply null out the cached schedulers to force a re-check the next time they're used, and thus letting you change the scheduling hook and have the new one's output propagate. 

With JUnit, it could be nicely wrapped up in a rule that could be optionally dropped into test suites on the fly. Otherwise, schedulers must be set at the beginning of your whole test suite and delegate schedulers put in place that can be configured later.

If people would be open to this, I'd be happy to provide a PR. I looked for prior discussion around this but wasn't able to find any. If I missed them somewhere, please let me know.""👍 In the long term, I would like to see that `RxJavaPlugins.reset()` can reset static fields related to plugins.
 =||= Actually it wouldn't just be nulling out those fields. It would have to replace the singleton `INSTANCE` of Schedulers to re-trigger its constructor and evaluation of those scheduler instances. For just tests though, I still think this is a reasonable tradeoff since it's opt-in and doesn't change existing behavior by default.
 =||= @hzsweers That's what I meant :)
 =||= Opened a PR in #3986 for further review
 =||= "Add Schedulers.reset() for better testing"Resolves #3985

This adds a `reset()` method to `Schedulers`, with the main benefit being improved testing support. This does slightly tweak the internal API of `Schedulers` to use a `getInstance()` approach to allow lazy init. This way we don't have to replace the singleton instance during `reset()` and allow it to lazily re-evaluate upon next usage. Otherwise, if you change your scheduler hook, you'd always have to make sure you set it before you call `Schedulers.reset()`.

Will run perf tests overnight in case, I'm not sure how much of a tradeoff moving to an internal `getInstance()` approach costs, if anything.

CC @zsxwing"Zac SweersZacSweers06/06/16, 09:41:21 PM
4052.040532.x: Change SchedulerSupport to string?"In some specific uses of RxJava it's common to have other important schedulers that one cares about. If the `@SchedulerSupport` annotation was changed to use a `String` as its value and provide constants on that type for its first-party values this would allow those other schedulers to be analyzed in the same way.

This will allow static analysis tools to enforce constraints with these ""custom"" schedulers as actual named-entities instead of having to rely on the otherwise opaque `CUSTOM` value. Additionally, libraries will be able to annotate their factory methods which operate on these schedulers appropriately.

I'm thinking specifically of Android, RxAndroid, and having `""mainThread""` be a value.

Happy to make this change if it sounds like a good idea."":+1:, I'm not touching the base reactive types in the next 12 hours so go ahead with the PR.
 =||= Resolved by #4053. Not sure why it didn't auto-close. 
 =||= > Resolved by #4053. Not sure why it didn't auto-close.

Only patches merged to the `default` branch can auto-close issues.
 =||= Ah, good call.

On Tue, Jun 21, 2016, 8:36 PM Shixiong Zhu notifications@github.com wrote:

> Resolved by #4053 https://github.com/ReactiveX/RxJava/pull/4053. Not
> sure why it didn't auto-close.
> 
> Only patches merged to the default branch can auto-close issues.
> 
> —
> You are receiving this because you modified the open/close state.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4052#issuecomment-227612498,
> or mute the thread
> https://github.com/notifications/unsubscribe/AAEEEffrBjE_5NKqCcUK63DbG4JT4OBkks5qOIOlgaJpZM4I7K09
> .
 =||= "2.x: Convert SchedulerSupport annotation to accept a string value.Closes #4052.Jake WhartonJakeWharton06/21/16, 10:16:17 PM
4056.040692.x: Unify two type parameters from Subject into one?"This came up in passing in an issue or PR before (that I can't find at this moment), but the two type parameters on `Subject` seem to only be a nuisance instead of a benefit.

Should we remove them?

None of the built-in implementations allow consuming a type different than is being emitted, which makes the two type parameters on the supertype seem very out of place."":+1: RxScala uses one parameter for a long time and no one complaints.
 =||= It's a remnant of the ""Subject as a processing stage"" mentality of Rx.NET, but unlike Java, you can have classes with the same name and different number of type parameters.

:+1:, would you like to do it?
 =||= I can tomorrow! It's 3am here and that other PR I sent wore me out.

On Wed, Jun 22, 2016, 2:57 AM David Karnok notifications@github.com wrote:

> It's a remnant of the ""Subject as a processing stage"" mentality of Rx.NET,
> but unlike Java, you can have classes with the same name and different
> number of type parameters.
> 
> 👍, would you like to do it?
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4056#issuecomment-227659453,
> or mute the thread
> https://github.com/notifications/unsubscribe/AAEEETo3RW7ffxc0p3GoiOj4dKQypbsoks5qONzogaJpZM4I7ZYv
> .
 =||= "Remove second type parameter from Subject and FlowProcessor.Closes #4056.Jake WhartonJakeWharton06/22/16, 03:45:08 PM
4057.040702.x: SerialDisposable and MultipleAssignmentDisposable are exactly the sameEither one is erroneously implemented or let's pick one to keep."There is a difference:

https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/disposables/SerialDisposable.java#L33

https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/disposables/MultipleAssignmentDisposable.java#L32

Multiple doesn't dispose the previous Disposable but Serial does.

However, I'm totally for merging the two classes and have `set` and `replace` on them.
 =||= Wow super subtle! I had them open side-by-side and wasn't able to see that.

I can take this change tomorrow as well. Is there a preference for the name
of this merged type?

On Wed, Jun 22, 2016, 3:06 AM David Karnok notifications@github.com wrote:

> There is a difference:
> 
> https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/disposables/SerialDisposable.java#L33
> 
> https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/disposables/MultipleAssignmentDisposable.java#L32
> 
> Multiple doesn't dispose the previous Disposable but Serial does.
> 
> However, I'm totally for merging the two classes and have set and replace
> on them.
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4057#issuecomment-227660891,
> or mute the thread
> https://github.com/notifications/unsubscribe/AAEEEaJHuo4bnQp1ZPbnZfUMKT-u5lWXks5qON8DgaJpZM4I7bXX
> .
 =||= Open for discussion, I was leaning towards `SingleDisposable` but could get confused with `Single` in IDE content assist.
 =||= `AssignableDisposable`? `ReferenceDisposable`?
 =||= Closed by #4070.
 =||= I think `SerialDisposable` is good enough now.
 =||= "2.x: Merge SerialDisposable and MultipleAssignmentDisposable.Closes #4057 although doesn't address the name of the class.Jake WhartonJakeWharton06/22/16, 04:55:11 PM
4075.041022.x: Expose Disposable.isDisposed()?"In `Disposable.java` currently:

``` java
// TODO let's see if we really need this
// boolean isDisposed();
```

I think we should add this since `dispose()` already states:

> Dispose the resource, the operation should be idempotent.

Which means every disposable already needs a mechanism for idempotence which should trivially translate into `isDisposed()`.

There's some massive refactors that can be done if this change is made. `BooleanDisposable` can completely disappear from the public API since `Disposables.from(Runnable)` + `Disposables.empty()` mimic its behavior. Additionally a large portion of the other internal, custom disposables can be rewritten to build on an internal `BooleanDisposable` which manages both idempotence and the `isDisposed()` implementation for you.

I did some of this work last night as an experiment and it looks like a good win. The argument against the refactor would be if there's a reason we don't actually want to expose `isDisposed()` on `Disposable` directly. I'll note that `BooleanDisposable` is not unique in having an `isDisposed()` method. Most other implementations also have this method, they simply don't share it from the interface.""And I'm volunteering for this work, if that wasn't obvious...
 =||= The problem with adding `isDisposed` that it mandates stateful `Disposable` implementations for all use cases (empty can't be constant but requires newing up a new instance because it has to switch to disposed state in a visible manner). As the current 2.x demonstartes, checking for `isDisposed` is only required by a few container classes. Thus, I'd like to keep `Disposable` as is. You can introduce an interface on top of it for the container classes if you really want to.
 =||= Ok let me see how far I can get without exposing method. I did see that empty had to become a factory as a result, but I don't know how frequent the need for an empty instance is such that it would be a problem.
 =||= After more investigation it looks like `empty()` is the _only_ stateless `Disposable` in the entire lib aside from `disposed()`. Every other implementation is stateful and if it doesn't already declare `isDisposed()`, it can do so trivially.

Tell me what you think about this plan:
1. Document `DisposableHelper.DISPOSED` as a marker instance to be compared by identity (done in #4081) and `EmptyDisposable.INSTANCE` as a no-op implementation to be used internally as a value.
2. Change `Disposables.empty()` to return `new BooleanDisposable()`
3. Uncomment `isDisposed()` on `Disposable` and ensure a proper implementation on all implementations.

That said, I'm not convinced `empty()` needs to even exist as a public API. But if it does, then it's likely used so rarely that the fact that it needs to allocate a single, tiny object shouldn't matter. Internally all ""empty"" values will use `EmptyDisposable.INSTANCE` which will behave like an already-disposed `Disposable`.
 =||= Okay, go ahead with the PR.
 =||= "2.x: Expose isDisposed method on Disposable."This is a fairly ""dumb"" addition. There's lots of room for follow-up improvement in the utilization of base helper classes and even removing some now-duplicated state management.

Closes #4075."Jake WhartonJakeWharton06/24/16, 04:02:27 PM
3851.04140Completable.subscribe(onError, onComplete) design issue"This [particular overload](https://github.com/ReactiveX/RxJava/blob/3c5efaa9442ee24227b63ad039eb965b59aad774/src/main/java/rx/Completable.java#L1916) of `Completable.subscribe()` looks out of design in compare to other RxJava classes like `Observable` and `Single`.

Spent ~5 minutes trying to understand why such code didn't compile:

``` java
Completable
  .fromAction(() -> doSomething())
  .subscribe(
    () -> ui.success(), 
    error -> ui.error(error)
  );
```

And the reason is because this overload accepts `error` handler **first** and `complete` handler second.

I do understand that it comes from `Observable.subscribe(onNext, onError, onComplete)`. 

But in compare to many other overloads like:
- `Observable.subscribe(onNext, onError)`
- `Single.subscribe(onSuccess, onError)` // this one has very similar semantic to target overload.
- `Observable.subscribe(onNext)`
- `Single.subscribe(onSuccess)`

Error handler is **never first** parameter in `Observable.subscribe()` and `Single.subscribe()`.

Another point is that compiler error displayed in IDE makes it even worse:
<img width=""303"" alt=""screen shot 2016-04-12 at 00 35 50"" src=""https://cloud.githubusercontent.com/assets/967132/14443236/f19ec000-004e-11e6-95bb-178466587d52.png"">

---

`Completable` is still in `@Experimental`, so, we can change this signature as we want. We can `@Deprecate` this overload and add ""better"" alternative and then delete deprecated overload after one-two releases.""The design pattern was:

``` java
subscribe(Action0 onComplete)
subscribe(Action0 onComplete, Action1<Throwable> onError)
```
 =||= @akarnokd what do you mean by

> was

?
 =||= I mean that is your suggestion but the current is swapped for case 2 because it is in the same order as the 3 arg `Observable.subscribe` minus `onNext`. Not sure which order feels more consistent with the other classes.
 =||= Right, I pointed that in the issue description, but we do have `Single.subscribe(onSuccess, onError)` even though it's also `Observable.subscribe(onNext, onError, onComplete)` minus `onNext`.

As said before: no other overloads of `subscribe()` in any classes accept `onError` first -> makes `Completable` inconsistent.
 =||= Okay. Since Completable is experimental, lets swap the arguments as you suggested.
 =||= Oh great, will do PR soon!
 =||= "1.x: Change Completable.subscribe(onError, onComplete) to (onComplete, onError)Closes #3851, closes #4137.Artem Zinnatullin :slowpoke:artem-zinnatullin06/28/16, 01:55:19 AM
4137.04140Inverted onError and onComplete in CompletableIn completable subscribe method there is inverted order of methods (in compare to ex. Observable). In every other classes there is onNext/onSucces first, and in Completable there is onError first."Dupe of #3851 
 =||= Closing as duplicate. If you have time, you could post a PR that swaps the params as described in #3851.
 =||= "1.x: Change Completable.subscribe(onError, onComplete) to (onComplete, onError)Closes #3851, closes #4137.Artem Zinnatullin :slowpoke:artem-zinnatullin06/28/16, 01:55:19 AM
4212.04215RxJavaHooks.enableAssemblyTracking() breaks error handling"Problem:

If user enables assembly tracking then **ALL** exceptions get wrapped into `AssemblyStackTraceException` which breaks all error handling code that expects particular exceptions.

Solution:

Do not change type of original exception and modify its stacktrace directly. I'll work on that soon, both for 1.x and 2.x.

// Spent an hour today trying to figure out what was causing app misbehave, glad we have `git bisect`, was very surprised to see commit where I enabled assembly tracking…""Yeah, in [Java 8](https://github.com/reactor/reactive-streams-commons/blob/master/src/main/java/rsc/publisher/PublisherOnAssembly.java#L140) I simply add it as a suppressed exception. In Java 8, you have to find an unused slot of cause in a potentially complicated graph of exceptions and composites.
 =||= This change likely caused #4737
 =||= "1.x: fix assembly tracking replacing original exception"Modify the assembly tracking logic to not replace the exception flowing through but to attach the tracking exception to the end of the causal chain (if possible).

Fixes #4212"David Karnokakarnokd07/20/16, 09:17:11 PM
4230.04231Schedulers.io() reuses blocked threadsSome actions are not interruptible. Since Schedulers.io() reuses threads after unsubscribe, a previous uninterruptible action might block execution of new actions, causing unexpected delays or in some cases, deadlocks."Could you give an example of such non-interruptible blocking tasks?
 =||= @akarnokd A concrete example is in the test case that I added in #4231, but in general any task that is carelessly written (swallows `InterruptedException`, or busy looping, etc.) will trigger this issue. 

Example:

```
int numClients = 0;
for (Server s : servers) {
    try {
        numClients += s.queryNumClients();
    } catch (Exception e) {
        // Assume 0 clients
    }
}
return numClients;
```

The `InterruptedException` caused by `unsubscribe()` is swallowed and if the next `s.queryNumClients()` blocks for minutes, then this will block the thread for minutes.

What's worse is that this may even come from 3rd party code that also uses `Schedulers.io()` and cause extremely hard to debug problems.
 =||= I see. I'd consider the fix in #4231 as a temporary workaround because such tasks will keep blocking out threads (and leak resources). Generally, this is what `newThread()` is handy for: you get a new thread that can be blocked without the fear of reuse. Send such untrustwothy tasks to newThread() and the rest to io().
 =||= Absolutely, #4231 only prevents other tasks from being blocked by the misbehaving task, it does't prevent the thread (and potentially other resource) leaks.

I believe the thread leak would be present with `newThread()` as well and there is not much we can do about this. There is `Thread.stop()` but it introduces more problems than it solves. Hopefully the misbehaving task will complete eventually and at that point the resources will be freed up. If it never completes then it's a lost thread and the resources are leaked permanently.
 =||= I happened to face this bug today, was using RxJava 1.1.2. After half an hour of debugging went to check for newer version, and guess what - first bug fix in release notes is exactly the one I was fighting. Pulled latest, everything works like a charm. Thank you guys!
 =||= "CachedThreadScheduler should wait until the previous action (if any) ……completes before releasing a worker to the pool. Fixes #4230.Csaba Koscsabakos-zz07/23/16, 12:24:03 PM
4286.043172.x: Add fromAsync Observable factorybut potentially with a different name based on what the resolution of #4255 is."And bonus: no backpressure strategy argument needed!
 =||= I would also argue for the deletion of `Flowable.fromAsync` since it's just `Observable.fromAsync(...).toFlowable(strategy)` which isn't much longer than `Flowable.fromAsync(..., strategy)`. Plus visitor/callback-based APIs are unlikely to have built-in backpressure so it makes sense to wrap them as a backpressure-free type and then apply a strategy.
 =||= :+1:
 =||= I'll try to give this a go tomorrow. I'm afraid I've sent too many PRs already and the statistical likelihood of conflicts is approaching 100%.
 =||= I have an alternate proposal:
- Remove `Flowable.fromAsync` + `AsyncEmitter`
- Rename `Observable.create` to `Observable.unsafeCreate`
- Add `Observable.create` which wraps the incoming `Observer` in one which checks for cancelation (similar to what `BaseAsyncEmitter` is doing now).

This has a few advantages:
- It makes `Observable.create(ObservableSource)` actually usable by ""normal"" users! No more traps to fall in!
- It still allows fully-compliant `ObservableSource` implementations via `unsafeCreate` (or subclassing).
- It re-uses the same interface types and names we already have without needing new ones.
- It re-uses the existing `onBackpressure*` methods for adding backpressure to created observables.

And disadvantages:
- It removes the ability to do proper backpressure-aware implementations easily. But perhaps something similar to `AsyncOnSubscribe` could be brought along for handling requests and then using this new, safer `Observable.create` for its return values.
 =||= In terms of the last disadvantage, `Flowable.create` could be renamed to `Flowable.unsafeCreate` and `Flowable.create(BatchPublisher)` could be added where `BatchPublisher` is something like a pared down `AsyncOnSubscribe`.
 =||= This happened!
 =||= ""2.x: Rename create to unsafeCreate, add ""safe"" create methods.""This is a proposal to solve #4255 but for 2.x and closes #4286 built around one goal: make the `create` methods actually usable by developers!

Currently the advice given to most developers using 1.x is avoid `create` unless you are absolutely 100% sure you understand backpressure and cancellation, and even then avoid it if possible. This method is a trap that most new developers fall into. _The method is named ""create"", after all, so it must be how I create these things!_ I want to make that statement not only correct, but advisable (at least when the still-convenient ""from"" methods are not suitable, such as when wrapping callback-based APIs).

Because `Observable`, `Single`, and `Completable` are backpressure-free, this amounts to just suppressing downstream notifications when disposed. This doesn't seem too controversial.

The most controversial part is that I have renamed `Flowable.fromAsync` to `Flowable.create` thus making it the canonical way for users to create `Flowable`s directly. I'm much less opinionated on this change, but it felt wrong to have an `Flowable.unsafeCreate` with no associated `create` and `fromAsync` is the ""safest"" version we have."Jake WhartonJakeWharton08/09/16, 07:07:06 AM
4457.044611.x: Single and Completable are missing doOnEachBoth are missing that method. Is this one wanted?"Single is either success or error and Completable is either complete or error, and both types have doOn- methods for those events.
 =||= Yes I'm aware of that however I'd like something like a `doOnEach`. Also in Observable `doOnEach` includes terminal events.

If you want to execute some code regardless of whether it was successful or an error was thrown you'd need to call that method  in `onSuccess` and `onError`, where as with a `doOnEach` you'd call it once instead.

Again just a proposal if this is not wanted at all I'm also happy to live without it.
 =||= Oh I misread as next not each. Go for it.
 =||= Alright will do in the next few hours.
 =||= How about 2.x in this case? Both `Single` and `Completable` are also ""missing"" `doOnEach` there. Will the changes automatically be merged from 1.x to 2.x?
 =||= For 2.x, I'd imagine `Completable.doOnEvent(Consumer<? super Throwable> onEvent)` and `Single.doOnEvent(BiConsumer<? super T, ? super Throwable>)` where if the `Throwable` is null, it means the other event happened. There is a similar  API in `CompletableFuture.whenComplete(BiConsumer)` or something.
 =||= What about the Maybe type? That one would need one too, right?
 =||= I'm currently expanding Maybe so I'll add one.
 =||= "1.x: Single add doOnEach"Really not that happy with `onNotification.call(Notification.<T>createOnNext(t));` do you guys have any other way of doing this? There's no way of creating a Notification that has the `onCompleted` plus a value. A new one could be introduced there though. Also the `doOnEachSuccess` test feels clunky.

Also why does Single when using the `do` methods does the job by using an Observable? And later converting it back to a Single again. Is it due to the way Single was implemented in 1.x? With Completable there is no converting of back and forth needed.

Javadoc will follow once we sorted out the few nits here.

Fixes #4457 "Niklas Baudyvanniktech09/05/16, 12:18:01 PM
4501.045042.x: Matching DisposableObserver class for Single"How do you feel about adding a matching class for `DisposableObserver` with Single support?

Instead of `Observer` it'll implement `SingleObserver`""Sounds good; please add one for Completable and Maybe while you are at it.
 =||= Will do 👍 
 =||= Closing via #4504 
 =||= "2.x: Add Disposable Observer for Maybe, Completable & Single"Also any reason the Dispoable is called `s`? Is it still from the Subscription time?

Fixes #4501 "Niklas Baudyvanniktech09/08/16, 09:18:34 AM
4517.045182.x: ResourceSubscriber & ResourceObserver"Why is `ResourceSubscriber` using `CompositeDisposable` and `ResourceObserver` using `ListCompositeDisposable`?

Also the java documentation does not seem to fit of the disposables.
`/** The resource composite, can be null. */`

It's initialized and made final and adding a `null` Disposable will throw a `NullPointerException`.

In addition is there a need for ResourceMaybeObserver and the alike implementation for Single & Completable?""> Why is ResourceSubscriber using CompositeDisposable and ResourceObserver using ListCompositeDisposable?

By mistake, both should be `ListCompositeDisposable`

> Also the java documentation does not seem to fit of the disposables.

Used to be optional to have resource support there, the javadoc was not updated when the class was changed to always support resources.

> It's initialized and made final and adding a null Disposable will throw a NullPointerException.

Yes, that's intentional.

> In addition is there a need for ResourceMaybeObserver and the alike implementation for Single & Completable?

PR welcome.
 =||= Alright I'll get working 👍 
 =||= Closing via #4518 
 =||= "2.x: Add missing Resource Observer for Maybe, Completable & Single and adjust some JavadocFixes #4517Niklas Baudyvanniktech09/09/16, 03:49:15 PM
4521.04522[RxJava 2.0.0-RC2] Observable.delay doesn't respect the provided Scheduler"``` Java
public class DelayBug {
  public static void main(String[] args) throws Exception {
    final CountDownLatch latch = new CountDownLatch(1);

    Observable.<String>error(new Exception())
        .delay(100, TimeUnit.MILLISECONDS, Schedulers.io())
        .doOnError(throwable -> System.out.println(""onError @ "" + Thread.currentThread().getName()))
        .onErrorResumeNext(Observable.empty())
        .doAfterTerminate(latch::countDown)
        .subscribe();

    latch.await();
  }
}
```

Output:

```
onError @ main
```

Expected output:

```
onError @ RxCachedThreadScheduler-1
```""Please check the available overloads for the feature you are looking for.
 =||= I don't want to delay the error, but I still want to receive `onError` callback on the provided scheduler. This is how RxJava 1 works ([OperatorDelay.java#L66-L78](https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorDelay.java#L66-L78)). I think the following code [ObservableDelay.java#L89-L105](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/observable/ObservableDelay.java#L89-L105) should be:

``` java
@Override
public void onError(final Throwable t) {
    w.schedule(new Runnable() {
        @Override
        public void run() {
            try {
                actual.onError(t);
            } finally {
                w.dispose();
            }
        }
    }, delayError ? delay : 0, unit);
}
```
 =||= PR welcome.
 =||= Closed via #4522 
 =||= "Observable/Flowable/Completable/Single.delay should always call onError on the provided SchedulerFixes #4521 Vladimir Mironovnsk-mironov09/09/16, 08:46:53 PM
4524.04525RxJava2 `Observable.zip` taking `Iterable` and a `zipper` is broken"http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#zip-java.lang.Iterable-io.reactivex.functions.Function-

The `zipper` signature is `Function<? super T[]>, ? extends R> zipper`, where use of `T[]` breaks it. Just invoke it with non `Object` T, and a `ClassCastException` is thrown.

I checked with `Single` and `Flowable`, they have different signatures for the comparable `zip` operators. They use `Object[]` where `T[]` is used for `Observable`, which are also consistent with the 1.x zip operator.

I think this is just a bug in the signature.""Totally possible. Can you post a small unit test that fails?
 =||= ``` Java
    @Test
    public void zipIterableOfObservables() {
        List<Observable<Integer>> observables =
                new ArrayList<Observable<Integer>>();
        observables.add(Observable.just(1, 2, 3));
        observables.add(Observable.just(1, 2, 3));

        Observable.zip(observables, new Function<Integer[], Integer>() {
            @Override
            public Integer apply(Integer[] o) throws Exception {
                int sum = 0;
                for (int i : o) {
                    sum += i;
                }
                return sum;
            }
        }).test().assertResult(2, 4, 6);
    }
```

Please note that if we use lambda as a zipper, it eventually generates what the above test has.
 =||= FYI, the following works and it's what is generated with the 1.x signature:

``` Java
    @Test
    public void zipIterableOfObservables() {
        List<Observable<Integer>> observables =
                new ArrayList<Observable<Integer>>();
        observables.add(Observable.just(1, 2, 3));
        observables.add(Observable.just(1, 2, 3));

        Observable.zip(observables, new Function<Object[], Object>() {
            @Override
            public Object apply(Object[] o) throws Exception {
                int sum = 0;
                for (Object i : o) {
                    sum += (Integer) i;
                }
                return sum;
            }
        }).test().assertResult(2, 4, 6);
    }
```
 =||= Thanks. The underlying problem is that we can't do `new T[n]` and such lambdas cast the bridge `Object apply(Object[])` argument to `Integer[]` which fails since `zip` and `combineLatest` use `Object[]` internally.

Currently I can't write a PR. @vanniktech could you change all `? super T[]` signatures back to `? super Object[]` and add unit tests like above to verify there is no `ClassCastException` in a PR?
 =||= Sure 👍 
 =||= Closing via #4525.
 =||= BTW, why use array instead of `List` there? Any reason? If `List` is used, then at least it seems safe with generics, doesn't it?
 =||= Using array has reduced allocation cost and less indirection.
 =||= I've Singles of different types to run with Single.zip, and I'm getting ClassCastException as SingleZipIterable. Is it wrong zipping Singles of different type together? =||= You have to be careful which index you cast back to what type. =||= My Single.zip returns io.reactivex.internal.operators.single.SingleZipIterable but I'm expecting a Single<Object>, any Advice?
 =||= Please provide a standalone unit test that demonstrates your problem. =||= "2.x: Fix Generics T[] in Zip & CombineLatest"Fixes #4524

Test for combineLatest fill follow"Niklas Baudyvanniktech09/10/16, 12:13:54 PM
4588.045892.x: Convert Observable to Single without a default value"With the RC3 changes I don't see an easy way of converting an Observable into a Single without giving a default value.

How do you feel about adding methods for that?""@abersnaze didn't like throwing because being empty. Try your API through `Maybe` and `switchIfEmpty(Maybe.error())`.

**Edit** wrong method name, fixed.
 =||= `defaultIfEmpty(MaybeSource<T>)` does not exist
 =||= Yeah sorry, `switchIfEmpty()` (I sometimes mix the two as `defaultIfEmpty` delegates to `switchIfEmpty`).
 =||= I don't quite see how `switchIfEmpty` solves my original problem. `Maybe.switchIfEmpty()` still returns a `Maybe`.

Also I'd rather have a `NoSuchElementException` and fail early than passing in a default value when converting an Observable to Single.
 =||= You could restore `toSingle` (under `singleOrError`), only the surface API has been removed.
 =||= So basically add to Observable + Flowable:

`singleOrError`
`firstOrError`
`lastOrError`
`elementAtOrError`
 =||= Yes.
 =||= Alright cool will do
 =||= Does singleElement() error on more than one but not on empty?
 =||= Yes, that was kept and also why firstElement is there to ignore more without signalling.
 =||= This can be closed right?
 =||= "2.x: Add singleOrError, firstOrError, lastOrError & elementAtOrError to Observable and FlowableCloses #4588Niklas Baudyvanniktech09/23/16, 09:19:00 PM
4650.046512.x: Should Maybe and Single have a corresponding Transformers?"Currently, `Maybe.compose()` requires a `Function<? super Maybe<T>, ? extends MaybeSource<R>>` and `Single.compose()` requires something similar

While other types have `FlowableTransformer` and `CompletableTransformer`. Would it make sense to bring them into the same pattern? Aside from consistency, early testing for me shows that the generics gymnastics involved in `Maybe` and `Single`'s `Function` approaches is a major headache, as any parameterized stream type gets lost and requires manual specification, forfeiting the ability to  reuse APIs.

Consider RxLifecycle, which historically has just returned an implementation of the required Transformer.

``` java
someSingle
    .compose(RxLifecycle.bind(this).forSingle())
    .subscribe();
```

This works for simple unparameterized types, but breaks down when parameterized types come in.

![screenshot 2016-10-01 02 21 10](https://cloud.githubusercontent.com/assets/1361086/19012563/3ac09300-877f-11e6-8886-940e45ca4572.png)

``` java
// Same result with both Single and Maybe. Screenshot is Maybe, example below is Single.
// The type is now a List<T> of some type T
someListSingle
    .compose(Confine.to(this).forSingle())  // Compiler error because R type instance not found
    .subscribe();
```

Where `Confine.to` returns a bridging helper like this:

``` java
public static class LifecycleTransformer2<T> implements FlowableTransformer<T, T> {

  // Delegate transformer, what's currently returned by RxLifecycle.bind()
  private LifecycleTransformer<T> delegate;

  public static <T> LifecycleTransformer2<T> create(@NonNull LifecycleTransformer<T> delegate) {
    return new LifecycleTransformer2<>(delegate);
  }

  private LifecycleTransformer2(@NonNull LifecycleTransformer<T> delegate) {
    this.delegate = delegate;
  }

  public Function<Maybe<T>, MaybeSource<T>> forMaybe() {
    return source -> {
      Observable<T> o = toV1Observable(source.toFlowable());
      o = delegate.call(o);
      return RxJavaInterop.toV2Flowable(o).singleElement();
    };
  }

  public Function<? super io.reactivex.Single<T>, ? extends SingleSource<T>> forSingle() {
    return new Function<io.reactivex.Single<T>, SingleSource<T>>() {
      @Override
      public SingleSource<T> apply(io.reactivex.Single<T> source) throws Exception {
        Single<T> o = toV1Single(source);
        o = (Single<T>) delegate.forSingle().call((Single<Object>) o);
        return RxJavaInterop.toV2Single(o);
      }
    };
  }

  public CompletableTransformer forCompletable() {
    return source -> {
      Completable o = toV1Completable(source);
      o = delegate.forCompletable().call(o);
      return RxJavaInterop.toV2Completable(o);
    };
  }

  @Override
  public Publisher<? extends T> apply(Flowable<T> source) throws Exception {
    Observable<T> o = toV1Observable(source);
    o = delegate.call(o);
    return RxJavaInterop.toV2Flowable(o);
  }
}
```

`FlowableTransformer` and `CompletableTransformer` work fine, but the other two have been really tricky to nail down.""We have those kind of transformers but they are not wired up to `compose` for some reason  (forgotten?). PR welcome.
 =||= Totally missed that they already existed. Done! - https://github.com/ReactiveX/RxJava/pull/4651
 =||= Closing via #4651
 =||= "Switch Maybe and Single to use their Transformers in compose()Resolves #4650 Zac SweersZacSweers10/01/16, 08:08:37 AM
4688.046902.x: BaseTestConsumer add assertValueAt(index, Predicate<T>)"That one would check that the value at the given index matches the predicate. Also assertValue(Predicate<T>) could forward to the new method with the given index 0.

What are your thoughts?""Fine with me.
 =||= Closing via #4690 
 =||= "2.x: BaseTestConsumer add assertValueAt(index, Predicate<T>) "Fixes #4688
- adds assertValueAt(index, Predicate) to BaseTestConsumer"Niklas Baudyvanniktech10/11/16, 04:40:33 PM
4709.047102.x: Remove checked exceptions from transformer interfaces?"Now that transformers are not `Function` extensions, does it makes sense that they allow throwing checked exceptions? When a transformer is being invoked, its job is taking an observable and _transforming_ it into another observable but not actually doing any real work. Thus, it seems strange that you would ever encounter something that threw a checked exception in this operation. It would be a sign that you need to move that work into the stream pipeline instead of the observable creation pipeline.

This also makes code that has to deal with transformers annoying because they now have to handle (aka wrap and throw) these checked exceptions.

Happy to send a PR, but wanted to get some thoughts first and make sure I wasn't missing anything.""Works for me both ways so its up to the community to decide.
 =||= Ok. Sent a PR for it. No rush to merge if you want to wait for other opinions.
 =||= I'm a fan of this change, for the reason stated above - due to its nature, a transformer should rarely (never?) be throwing a checked exception.
 =||= I thought about it and couldn't find a reason to allow throwing there.

Closing via #4710.
 =||= "2.x: Remove checked exceptions from transformer interfaces."These functions are for transforming the stream shape, not doing work. Any operation that would throw a checked exception should happen inside the stream, not when shaping it.

Closes #4709."Jake WhartonJakeWharton10/19/16, 04:01:23 PM
4923.049242.x Single.flatMapCompletable expects Completable instead of CompletableSource"The signature looks like this:

`final Function<? super T, ? extends Completable> mapper`

although it should be 

`final Function<? super T, ? extends CompletableSource> mapper`"I don't think there are any `CompletableSource` implementations other than RxJava but you are welcome to send a PR. =||= Well it's mostly for consistency and I'll send one right away. =||= Closing via #4924 =||= 2.x: Change Completable to CompletableSource"Changing `Completable` to `CompletableSource`. Also found one other wrong spot that I fixed within this PR.

Fixes #4923 "Niklas Baudyvanniktech12/16/16, 05:25:07 PM
4950.049722.x: compose() generics"Migrating some of our code to RxJava 2, we've run into some issues around transformers due to the following signature change:

```java
// 1
public <R> Observable<R> compose(Transformer<? super T, ? extends R> transformer) {     
    return ((Transformer<T, R>) transformer).call(this); 
}

// 2
public final <R> Observable<R> compose(ObservableTransformer<T, R> composer) {     
    return wrap(composer.apply(this));
 }
```

Was this intentionally narrowed? If not, open to a PR to add back the `? super` semantics?""Do you have an example that doesn't compile for you without `? super`? We have to be careful with such variance changes because it may break current users. =||= Whoops just saw your response. I'll put together a sample later tonight =||= So here's an example where an observable emits `A` instances down the stream and transforms them into `B` instances.

```java
interface A<T, R> {}
interface B<T> {}

// RxJava 1
static <T> rx.Observable.Transformer<A<T, ?>, B<T>> oldStyle() {
    return new rx.Observable.Transformer<A<T, ?>, B<T>>() {
        @Override
        public rx.Observable<B<T>> call(rx.Observable<A<T, ?>> a) {
            return rx.Observable.empty();
        }
    };
}

// RxJava 2
static <T> ObservableTransformer<A<T, ?>, B<T>> newStyle() {
    return new ObservableTransformer<A<T, ?>, B<T>>() {
        @Override
        public ObservableSource<B<T>> apply(Observable<A<T, ?>> a) {
            return Observable.empty();
        }
    };
}

void test() {
    
    A<String, Integer> a = new A<String, Integer>() { };

    // RxJava 1
    rx.Observable.just(a)
            .compose(TransformersTest.<String>oldStyle())  // Yay, because Integer is irrelevant here
            .subscribe(new Action1<B<String>>() {
                @Override
                public void call(B<String> stringB) {

                }
            });

    // RxJava 2
    Observable.just(a)
            .compose(TransformersTest.<String>newStyle())   // This doesn't compile
            .subscribe(new Consumer<B<String>>() {
                @Override
                public void accept(B<String> tB) throws Exception {

                }
            });
}
```

In the RxJava 2 example, the `compose()` line there doesn't compile because of generics issues.

<img width=""1341"" alt=""screen shot 2017-01-07 at 11 55 01 pm"" src=""https://cloud.githubusercontent.com/assets/1361086/21748246/f0879672-d534-11e6-9f53-48c5b776ba89.png"">

In order to make it compile, the transformer signature needs to be changed to be like the following:

```java
static <T, R> ObservableTransformer<A<T, R>, B<T>> newStyle() {
    return new ObservableTransformer<A<T, R>, B<T>>() {
        @Override
        public ObservableSource<B<T>> apply(Observable<A<T, R>> a) {
            return Observable.empty();
        }
    };
}
```

And imposes some boilerplate on the consumer in that they now have to specify the second type even though it's irrelevant.

```java
Observable.just(a)
        .compose(TransformersTest.<String, Integer>newStyle())  // :(
        .subscribe(new Consumer<B<String>>() {
            @Override
            public void accept(B<String> tB) throws Exception {

            }
        });
``` =||= Okay, please verify that with the variance changes it compiles with Java 6, 7 and 8 targets. =||= "Improve compose() generics"Resolves #4950

I tested and built with the added tests on Java 6, 7, and 8. Not sure if you want to keep them in before merging since they're not really functional in nature, just there to make sure they compile.
"Zac SweersZacSweers01/08/17, 11:33:50 AM
4993.050022.x: Should schedulers have RxThreadFactory constructor parameters?RxJava 1 allowed for specifying a custom thread factory, but it looks like this feature did not make it to RxJava 2. Was this intentional or something that a PR would be welcome for?"Which scheduler? Computation? It was intentional. You can now configure the priority of each scheduler so there was little benefit from a customizing the factory. Use the [ParallelScheduler](https://github.com/akarnokd/RxJava2Extensions#parallelscheduler) from extensions which allows more [customization](https://github.com/akarnokd/RxJava2Extensions/blob/master/src/main/java/hu/akarnokd/rxjava2/schedulers/ParallelScheduler.java#L87).

 =||= We used it for the IO scheduler as well. It was useful for tracking our own thread naming and setting their priority to android-specific priorities. We'd like to use it for that and SingleScheduler. Can ParallelScheduler be used as a substitute for non-computation schedulers too? =||= Since scheduler implementations are internal, it is not recommended anyway to use them directly.

ParallelScheduler is an individual scheduler with a specified number of threads that doesn't change over time. So unlike io(), ParallelScheduler won't stop its threads when they become idle for too long. =||= > Since scheduler implementations are internal, it is not recommended anyway to use them directly.

I'm not sure I follow. As in we shouldn't create a new IoScheduler instance? =||= Prior discussions/work for reference - #3724 #3879 =||= Anything in the `io.reactivex.internal.*` is considered private and not part of any binary or API compatibility contracts. =||= So either use `Schedulers.from(Executor)` with your own pool or copy the internal code and change it locally. =||= I missed that they were internal now. That's disappointing to see, and seems like a bit of a step backward compared to RxJava 1. We'll just copy then :| =||= They're internal in 1.x too. The only remnants are public for binary
compatibility that no one should be using anyway. Are you referring to the
factory methods? Those could easily be replicated on 2.x.

On Fri, Jan 13, 2017, 4:22 AM Zac Sweers <notifications@github.com> wrote:

> I missed that they were internal now. That's disappointing to see, and
> seems like a bit of a step backward compared to RxJava 1. We'll just copy
> then :|
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/4993#issuecomment-272431211>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAEEERdKOOoaZajpQio5Pgsyac0sCa0Lks5rR2x0gaJpZM4LiyuF>
> .
>
 =||= Yeah I was referring to the factory methods. Basically wanted to do the same thing you added in the linked PR above =||= > Those could easily be replicated on 2.x.

@akarnokd any thoughts on this? This is what I was thinking of in opening this issue, in case I wasn't clear before =||= They will be still internal classes. However, we could expose them, for example, `Schedulers.newComputation()`, `Schedulers.newIO()` etc where extra parameters can be passed in, similar to how Project Reactor's schedulers were exposed. =||= That sounds reasonable to me.[ The APIs they expose cover pretty much everything we'd want](https://github.com/reactor/reactor-core/blob/master/src/main/java/reactor/core/scheduler/Schedulers.java), would be happy to make a PR matching those if you're up for it. =||= Sure. =||= "2.x: Add scheduler creation factories"Resolves #4993

This is a pretty vanilla copy from RxJava 1's implementation. Note that I had to tune NewThread scheduler to not be a singleton to support this.

We had talked about borrowing from project reactor's APIs for different overloads, let me know if you think we should add more fine-grained controls through these."Zac SweersZacSweers01/25/17, 08:22:00 AM
5045.050492.x: RxJavaPlugin.get/setXXX generics?"For unit tests I frequently bump into the restrictiveness of 

```java
RxJavaPlugins.setErrorHandler(Consumer<Throwable> handler);
```

I would like the signature to be 

```java
RxJavaPlugins.setErrorHandler(Consumer<? super Throwable> handler);
```

There are many more methods in `RxJavaPlugins` that could support lower and upper bounded wildcards. Can I make these changes?""setErrorHandler: yes, others would bring trouble I think. =||= I gave it a shot: https://github.com/ReactiveX/RxJava/pull/5058
Widening the generics seems to work so far

But of course I don't know about any side effects, possible problems. =||= "use bounded wildcards for errorHandler (fixes #5045)"Adding bound wildcards for error handler - fixes #5045"Johannes Schneiderjschneider02/03/17, 04:42:22 PM
5138.051461.x: unsubscribeOn for Single?"RxJava version: v1.2.7

Although Single may be unsubscribed on a different thread than subscribed one, there seems to be no `unsubscribedOn` operator for Single.

It would be nice if there is a `Single#unsubscribeOn`.
I currently convert to Observable and use subscribeOn/unsubscribeOn methods for Observable, and then convert back to Single."PR welcome. =||= Closing via #5146. =||= 1.x: add unsubscribeOn to Single type (#5138)"resolve #5138 

add unsubscribeOn to Single type."Yasuhiro SHIMIZUyshrsmz03/12/17, 11:53:47 AM
5412.05413combineLatest(Iterable<Publisher<>>, Function<>) not emitting on empty iterable "I am using RxJava 2.10 and operator

io.reactivex.Flowable#combineLatest(java.lang.Iterable<? extends org.reactivestreams.Publisher<? extends T>>, io.reactivex.functions.Function<? super java.lang.Object[],? extends R>)

 but I've seen this behavior in 1.x as well. 

Overload of combineLatests (and combineLatestsDelayError) that takes Iterable of Publishers is not emitting any items and 'combiner' function passed to it is not called when iterable is empty. For this operator I would expect it to scale linearly, that is:

- If I pass Iterable of size 2 as a first argument I expect an Array of size 2 to be passed to combiner function
- If I pass Iterable of size 1 as a first argument I expect an Array of size 1 to be passed to combiner function
- If I pass Iterable of size 0 as a first argument I expect an Array of size 0 to be passed to combiner function""Wrong expectation. If you know you have zero sources, you are using the wrong operator to trigger actions. You can pick `just`, `map` it and actually ignore the input value. If you don't know you have zero sources, you still have the option to switch to a non-empty source via `switchIfEmpty`. =||= @akarnokd Well, OK, makes sense. It took me quite a while to track this one down. Do you think it should be included in the docs? I can document it and make pull request  =||= Yes, something along the line of this:

> Providing an empty array/Iterable will result in an immediate completion without any calls to the provided combiner function.

Note that there are several overloads to be considered in both `Flowable` and `Observable`. =||= "2.x: Add empty source clauses to javadocs of combineLatest operators ……accepting unspecified number of sources. This commit resolves #5412Sroka06/28/17, 08:58:59 AM
5442.054472.x: Consumer contract is violated when using doOnEvent"The following code showcases the problem:
```java
Completable.complete()
  .doOnEvent(t -> {})
```
`t` in this case is annotated with `@NonNull` but it will be `null` since the completable completes.

This is a real pain in Kotlin since the following code crashes in runtime:
```kotlin
Completable.complete()
  .doOnEvent {}
```""BiConsumer is also violated when using `Single#subscribe`. Either value or throwable will be null. =||= Removing the annotation from `Consumer` may affect all other places where it is not-null. Can you override the annotation somehow at the call site?

@sakuna63 [BiConsumer](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/functions/BiConsumer.java#L29) doesn't have the annotations. =||= I just stumbled upon this while using Kotlin, too. However I wonder how a function argument annotated with `@NonNull` can ever be `null`? Even in Java this should be problematic as the contract is broken. =||= Maybe RxKotlin has/could have workarounds for these. /cc @thomasnield =||= Sorry, I read old source code. 
The annotations have already been removed at https://github.com/ReactiveX/RxJava/pull/5257 =||= This was introduced with #5023 =||= > Removing the annotation from Consumer may affect all other places where it is not-null. Can you override the annotation somehow at the call site?

@akarnokd If there's just one call that passes `null` to the function then *imho* the argument must be annotated with `@Nullable` and not `@NonNull`. What's the point of `@NonNull` when it can be `null`? =||= @akarnokd no, the problem cannot be remidied in kotlin which completely prevents the usage of that operator in kotlin. 
Removing the annotation won't make it nullable though, it would just mean that we don't know the nullability status which is the case too. Why is it important to keep it? I see very little harm in removing it and as @svenjacobs said the contract is broken in java too. If I were to null check it in java I would probably get lint warning telling me to remove the null check.
Ideally there should be multiple interfaces like @rharter suggested in the issue for BiFunction =||= If you can think you can resolve this with minimal changes, PR welcome. =||= By the way this issue emerged with the release of Kotlin 1.1.3. Although `@NonNull` has already been added months ago it seems that the compiler/runtime library of Kotlin 1.1.3 became stricter in regards to nullability. =||= Ah, that explains why I just recently starting having problems. =||= Huh, I thought implementing `Consumer` interface manually with correct nullability will help:

```kotlin
Completable
        .fromCallable {  }
        .doOnEvent(object : Consumer<Throwable> {
            override fun accept(t: Throwable?) { // Error: 'accept' overrides nothing
                println(""event: $t"")
            }
        })
        .subscribe()
```

But Kotlin compiler (1.1.3-eap34) does not even let such code to compile, so there is probably no clear way to solve this in Kotlin without using Java code. =||= Is `doOnEvent` the only operator that needs a `Consumer` that accepts Nullable data? If so, why remove `@NonNull` which is fairly useful annotation for most of the other operators? Why not have a different, let's say, `Consumer2` specifically for doOnEvent and such operators? =||= "Remove @NonNull annotation in Consumer method parameterThis fixes #5442 Nicklas Ansman Giertzansman06/27/17, 01:11:09 PM
5555.055682.x: BaseObserver.assertOnlyValues(T...)"I'd like to introduce `assertOnlyValues` to the `BaseObserver`. It's the counterpart to `assertResult(T...)` which does almost the same except for the fact that the type hasn't completed yet.

I'm open if anyone has a better function name. Internally it'd delegate to:

```java
  assertValues(values)
      .assertNoErrors()
      .assertNotComplete()
      .assertSubscribed();
```""assertResult will eventually fail so assertValues was generally enough. When there is a bug, you can apply the other methods on a case by case basis. =||= > assertResult will eventually fail so assertValues was generally enough.

Although `assertValues` does not check for errors nor it'll fail when the stream does complete. Basically with that method I want to test that the stream will stay alive and not terminate. =||= You can write this utility method in a class:

```java
public static <T, U extends BaseTestConsumer<T>> assertValuesOnly(U ts, T... values) {
    return ts.assertValues(values).assertNoErrors().assertNotComplete().assertSubscribed();
}
```

And IntelliJ will happily staticly import it. =||= I tend to agree with @vanniktech on this feature-request.

>When there is a bug, you can apply the other methods on a case by case basis.

It's usually too late because code was shipped…

>You can write this utility method in a class:

For sure, I'm also pretty sure @vanniktech uses Kotlin so he could add extension function.

Not a fan of naming though, but I see the pattern, `assertOnlyValues()` should fit test API design. =||= > For sure, I'm also pretty sure @vanniktech uses Kotlin so he could add extension function.

That's what I'm doing right now. However I still think a lot of other people could benefit from this and the cost of adding this is really low.

> Not a fan of naming though, but I see the pattern, assertOnlyValues() should fit test API design.

Open for any better name. =||= Okay, let's add it. 

I'd name it `assertValuesOnly` so it should show up right after `assertValues` in code completion. =||= "2.x: Add assertValuesOnly to BaseTestConsumer."Adds `assertValuesOnly` that asserts that the TestObserver/TestSubscriber received only the specified values in the specified order without terminating.

Fixes #5555 "Niklas Baudyvanniktech08/25/17, 09:54:52 AM
4544.05582Maybe.switchIfEmpty(Single) method"It would be nice to see a method like this:

public class Maybe<T> {
  public Single<T> switchIfEmpty(Single<T> single);
}

Semantically, if you switchIfEmpty to a Single from a Maybe, then it becomes a Single, as you are guaranteed either an error or a value.  It would just make it less verbose than doing this:

maybe.switchIfEmpty(single.toMaybe()).toSingle()""done....
 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one.
 =||= "implement Maybe.switchIfEmpty(Single)Adds `Maybe.switchIfEmpty(Single)`, fixes #4544.Boris Maslakovbmaslakov09/04/17, 12:28:24 PM
5698.057052.x: Improper class name of ObservableFromCompletableTestThe class `io.reactivex.internal.operators.observable.ObservableFromCompletableTest` only tests `Observable.fromCallable`. Why the class name is **Completable**?"Probably just a misnamed test file. Would you like to fix it? =||= Because there already had a class `io.reactivex.internal.operators.observable.ObservableFromCallableTest`.
So, what the new name you recommend?
Or just merge the test cases into `ObservableFromCallableTest`? =||= Just copy over the test methods. =||= "2.x: Moved tests to FromCallableTest from FromCompletableTest"Fixes #5698. There was a test class named `ObservableFromCompletableTest` which actually was targeting `ObservableFromCallableTest`. This was most likely just a naming issue. Copied all tests from `ObservableFromCompletableTest` to `ObservableFromCallableTest` and deleted the former class."Daniel Reesdsrees11/04/17, 05:05:34 PM
5711.05715Premature thread interruption when using observeOn operator"When using RxJava 2.1.3 to 2.1.6, we observed a possible racing condition which caused the observeOn thread to be interrupted prematurely.

A sample code snippet could be the following (not a complete example):
```java
Observable.fromPublisher(publisher)
.observeOn(Schedulers.computation())
.firstElement()
.map(operation)
.blockingGet();
```

In the above example, observeOn operator would create a ObservableObserveOn instance. When there is the first item coming (ObservableObserveOn.ObserveOnObserver.onNext() is called), a Runnable is scheduled via the NewThreadWorker.scheduleActual(). Inside NewThreadWorker.scheduleActual(), a ScheduledRunnable is created wrapping the given Runnable, and submit the ScheduledRunnable to the executor for execution. Then the future returned by the executor is set into ScheduledRunnable via setFuture method.

The problem lies when the ScheduledRunnable.dispose() method is called between submitting to the executor and ScheduledRunnable.setFuture method by the underlying Runnable wrapped in ScheduledRunnable (which is executed in parallel by the executor). In this case, the Runnable contains the firstElement() operator would create a ObservableElementAtMaybe instance. ObservableElementAtMaybe.onNext() method would call the dispose() method before calling actual.onSuccess(). So combining these, if ScheduledRunnable.setFuture is called after ScheduledRunnable.dispose() in ObservableElementAtMaybe.onNext(), the actual.onSuccess() would be interrupted, which is not what we want.

**tl;dr** In the sample code, if the execution order is the following, it would create a thread interruption that interfere with the processing of the chained operators.
```
Thread 1: future = executor.submit(ScheduledRunnable)
Thread 2 (executor thread): ScheduledRunnable.dispose()
Thread 1: ScheduledRunnable.setFuture(future)
Thread 2: actual callback (e.g. actual.onSuccess()) <-- Thread interrupted. Throws exception when we call some synchronization methods in a non-blocking way (e.g. Semaphore.tryAcquire(0, TimeUnit.SECONDS)). 
```

A possible solution is to change the order, i.e. call actual.onSuccess() before dispose(). I searched the code base and found out that in general, dispose() is called before the actual callback. I am not sure if there are other concerns with this specific ordering (i.e. dispose before actual callback), but it certainly sounds odd to me.""`dispose` happens before the `onNext` or `onSuccess` because these may take an arbitrary long time to execute during which the source still doesn't know it should stop producing items. This can lead to excessive memory usage with `Observable`.

Change the order of operators so the `firstElement` doesn't cancel the task performing the thread switching:

```java
Observable.fromPublisher(publisher)
.firstElement()
.observeOn(Schedulers.computation())
.map(operation)
.blockingGet();
``` =||= While this can be a workaround for this simple example, but in general, this would be a problem. Here may be a more complex example that is difficult to workaround with:
```
Observable.fromPublisher(publisher)
.firstElement()
.observeOn(Schedulers.computation())
.flatMapObservable(operation)
.firstElement()
.flatMapObservable(operation2)
.observeOn(Schedulers.io())
.map(operation3)
.blockingGet()
```

Another possible solution is in the ScheduledRunnable.run(), wait until the setFuture is called before proceeding to the actual.run(). Again, I am not sure if there is any side-effect on this. =||= RxJava aims for non-blocking operations so it can't wait for `setFuture` to be executed. So either you don't call interrupt-sensitive code or create a custom scheduler that doesn't interrupt on cancelling the `Future`. =||= I would argue that the behavior of interrupting a downstream processing thread for observeOn when the observeOn is disposed is questionable. I think it makes perfect sense to interrupt the upstream threads when an operator is disposed, but definitely not downstream threads.

If your argument stands, i.e. we should not have interrupt-sensitive code in RxJava callbacks, why cancel the future with interrupt in the first place? =||= > interrupt the upstream threads when an operator is disposed, but definitely not downstream threads

Cancellation of the upstream triggers cleanup which cancels outstanding tasks of the `Worker`. It can't know you still want to keep using that thread and it can't know what cancelled it for what purpose either.

There were experiments that scheduled the cancellation of the worker behind the currently running task but that led to extended worker lifecycle, especially with `Schedulers.io()`, and leaked threads, for example, because the task to be stopped would block afterwards.

The `ExecutorService` API **returns** the `Future` that represents the task which could be already running concurrently, thus `setFuture` is racing with the completion of the task or a `Worker`-wide cancellation. The `ScheduledRunnable` has to use a deferred cancellation schema to get around this late `Future`. I don't know any means to get a ""cancellation token"" upfront for a task before it is even able to run to avoid that race.

> why cancel the future with interrupt in the first place?

To interrupt potentially blocking code that runs in operators such as `map` or `doOnNext`. =||= Let's put aside the current `Worker` and `ScheduledRunnable` implementation, and think about what's the desired behavior for `observeOn` and the desired behavior of `dispose`. 

To my understanding, `dispose` means notifying all upstream operations including the initial publisher that we no longer want to receive more items. If this understanding is correct, the `observeOn` thread should not be disposed unless the `dispose` of the last operation in the `observeOn` thread is called. E.g.
```
Observable
.create()
.observeOn(computation)
.firstElement()
.map()
.observeOn(io)
.flatMap()
```
The first `observeOn` thread should only be canceled when the `dispose` of `map` operation is called, not when the `dispose` of `firstElement` is called. A possible easier implementation to achieve this would be the `dispose` method of the second `observeOn` would cancel the thread of the first `observeOn`.
 =||= Can't work that way. 

As I said, you need a custom scheduler that doesn't interrupt when its tasks get disposed. =||= Can you elaborate why RxJava's dispose should not work that way, conceptually speaking? I am not saying the current implementation is doing this or can be easily modified to do that. =||= > first observeOn thread should only be canceled when the dispose of map operation is called

There is nothing that would call that dispose because it is `firstElement` that disposes its source before map gets executed.

In addition, RxJava operators are independent and standalone in the sense that they know practically nothing about what their upstream or downstream is or doing, only responding to the standard Observer and Disposable method calls they can interact with. =||= >you don't call interrupt-sensitive code

This really isn't feasible, many downstream libraries outside of the callers control are rightly senstive to interrupt calls.

Debugging issues caused by this behaviour is extremely hard. Once traced back to RxJava, and traced back to issues like this and many others, which are essentially dismissed, makes it very hard to continue using the library. =||= @adrian-baker You missed the other workaround I suggested: ""create a custom scheduler that doesn't interrupt on cancelling the `Future`"".

> issues like this and many others, which are essentially dismissed,makes it very hard to continue using the library

I do the maintenance for free and I look at people's profiles to see if they or their employer do significant contribution to open-source. If they do, I'm more inclined to go beyond high level suggestion and contribute the fixes/workarounds myself to their project.

For anybody else, they have to do it by themselves or are [welcome](https://twitter.com/SwiftOnSecurity/status/1067682759592869889) to open a support contract with my employer. =||= Just wanna clarify on this. I have a case like below:
```
Single.create(...)
.observeOn(Schedulers.io())
.flatMap(Single.create(...))
.flatMap(Single.create(...))
...
```
Basically it's a change of Singles and the each single is calling onSuccess or onError. In that case, for the second single, no matter if it's calling onSuccess or onError, it means completing the task right? Then if I don't have another observeOn following it, the third single can fail because of interruption? If that's the case, does it mean when chaining singles we need to call observeOn for each single? Thanks.  =||= > I do the maintenance for free and I look at people's profiles to see if they or their employer do significant contribution to open-source

I'm not making any judgement at all on your personal contribution. Just trying making the point that this issue perhaps should not be closed without a fix, since it creates surprising and difficult to debug breakages downstream. =||= "2.x: distinguish between sync and async dispose in ScheduledRunnable"This PR adds logic to distinguish between synchronous and asynchronous dispose calls when `setFuture` is executing. It should prevent interrupting the currently running task body if it requested cancellation indirectly before the `setFuture` was executed by the Thread which scheduled the task.

Fixes #5711"David Karnokakarnokd11/15/17, 10:24:46 AM
5725.057261.x: unsubscribeOn overrides downstream backpressure requests"lib version 1.3.3

sample:
``` 
       Observable.range(0, 20)
                .doOnRequest(n -> System.out.println(""req B "" + n))
                .unsubscribeOn(io())
                .doOnRequest(n -> System.out.println(""req A "" + n))
                .observeOn(computation(), 10)
                .toBlocking()
                .subscribe();
```

output is:
```
req A 10
req B 9223372036854775807
req A 8
java.lang.RuntimeException: rx.exceptions.MissingBackpressureException
...
```

without unsubscribeOn():
```
req A 10
req B 10
req A 8
req B 8
req A 8
req B 8
```"Closing via #5726. =||= 1.x: fix broken backpressure through unsubscribeOn()"The `unsubscribeOn` did not properly forward the upstream's `Producer` to the downstream, thus the default `Subscriber` request behavior of `Long.MAX_VALUE` was incorrectly in effect.

Fixes: #5725"David Karnokakarnokd11/16/17, 08:36:47 AM
5742.057432.x: SingleFromCallable doesn't check isDisposed before calling onError or onSuccess."I was investigating a bug and I noticed that `SingleFromCallable` doesn't check `isDisposed()` before calling `onError` or `onSuccess` when comparing it to `ObservableFromCallable`.

Should it be checking `isDisposed()`? If not, why not? Or is this a bug?

My code example where I'm getting this error is Android based:
I have a HomePresenter with this code:
```
void setActivity(Activity activity) {
	Timber.d(“HomePresenter attachActivity”);
	this.activity = activity;
}
```

```
void onStart() {
	Timber.d(“HomePresenter onStart”);
	disposables.add(api.getEmail()
		.subscribeOn(Schedulers.io())
		.observeOn(AndroidSchedulers.mainThread())
		.subscribe(email -> {
			Timber.d(“email was %s”, email);
			activity.setEmail(email);
		})
	);
```
```
void onStop() {
	Timber.d(“HomePresenter onStop”);
	disposables.clear();
	activity = null;
}
```

in the logs I see:
```
Lifecycle onStart HomeActivity
HomePresenter attachActivity
HomePresenter onStart
Lifecycle onStop HomeActivity
HomePresenter onStop
email was foo@bar.com
NullPointerException: attempt to invoke virtual method Activity.setEmail(String) on null object reference
```

It seems the subscription to the observable was cleared before the `onSuccess` method was called.

Or maybe I'm missing something else completely, anyways, thanks for the help :)
""Indeed it is inconsistent with the other operators. Would you like to submit a PR? The [`MaybeFromCallable`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/maybe/MaybeFromCallable.java) should give a hint about the proper implementation.

Otherwise, the NPE is due to the line `activity.setEmail(email);` where `activity` is null. Even if `isDisposed` would have been considered, there is a race between completion of the source and stopping the activity, thus you may end up with null `activity` anyway. =||= "2.x: Check isdisposed before emitting in SingleFromCallable"Previously SingleFromCallable did not check if the subscriber was
unsubscribed before emitting onSuccess or onError. This fixes that
behavior and adds tests to SingleFromCallable, CompletableFromCallable,
and MaybeFromCallable.

Fixes #5742"Nelson Osackyrunningcode11/25/17, 05:38:03 PM
5791.057922.x: part of the stream continues after error in Flowable but not Observable."Given an `Iterable<T>` that always fails on `next()`:

```
public Iterable<String> iterableThatThrowsException()
    {
        return () -> new Iterator<String>()
        {
            @Override
            public boolean hasNext() { true; }

            @Override
            public String next()
            {
                throw new RuntimeException(""kaboom, kaboom"");
            }
        };
    }
```

and this stream:

```
Flowable.fromIterable(Arrays.asList(1, 2))
                  .doOnNext(i -> out.println(""fromIterable onNext() -> "" + i))
                  .doOnComplete(() -> out.println(""fromIterable onComplete()""))
                  .map(i -> iterableThatThrowsException())
                  .flatMap(l -> Flowable.fromIterable(l))
                  .doOnError(t -> out.println(""flatMap onError()""))
                  .subscribe(
                    i -> out.println(""subscriber onNext() -> "" + i),
                    t -> out.println(
                        ""subscriber onError() -> "" + t.getClass().getName() +
                        "" "" + t.getMessage()),
                    () -> out.println(""subscriber onComplete()"")
                );
```
the `Flowable.fromIterable(Arrays.asList(1, 2))` continues to emit items after `flatMap(l -> Flowable.fromIterable(l))` signals error.

This is the output:
```
fromIterable onNext() -> 1
flatMap onError()
subscriber onError() -> java.lang.RuntimeException kaboom, kaboom
fromIterable onNext() -> 2
fromIterable onComplete()
```

Please note that:

1. When I substitute Flowable with Observable, then it outputs what **I** think is the correct behaviour
```
fromIterable onNext() -> 1
flatMap onError()
subscriber onError() -> java.lang.RuntimeException kaboom, kaboom
```
2. When I add a ""dummy""`doOnError()` to the inner `fromIterable` it also produces ""correct"" output like in 1
```
.flatMap(l -> Flowable.fromIterable(l).doOnError(t -> {}))
```
3. The ""incorrect"" behaviour is consistent all the way down to version 2.0.0

""a JUnit test to reproduce
https://gist.github.com/anonymous/1bda662f5383a410b33bcb4c1b229476 =||= Thanks. It's a bug on the fusion path which doesn't cancel the upstream if `poll()` crashes. 

PR #5792 posted to fix it. 

Till then, you can use `.hide()` (prevents fusion thus the buggy part is skipped) or `flatMapIterable(list -> list)` (does not suffer from this problem and is a bit faster anyway). =||= Ha! I knew it was the fusion path! ;)

Thank you for the fix and suggestion of a workaround! =||= "2.x: Fix flatMap inner fused poll crash not cancelling the upstream"This PR fixes the lack of upstream `cancel()` call when an inner, fused source's `queue.poll()` crashes in a non-delayed error mode.

Unit tests were added to verify `Observable.flatMap`, `Flowable.flatMapIterable` and `Observable.flatMapIterable` as well.
  
Fixes #5791"David Karnokakarnokd01/05/18, 11:26:30 PM
5809.058112.x: FlowableBufferBoundary doesn't stop opening new windows in overlapping case"Consider an `open` source for `FlowableBufferBoundary` that never stops, like a `Flowable.interval`. In the case where the buffer opening and closing signal overlap, the opening of new windows never stops even when the source of data completes.

The second test below times out as a result:

```java
@Test
    public void bufferedCanCompleteIfOpenNeverCompletesDropping() {
        Flowable.range(1, 200)
                .zipWith(Flowable.interval(5, TimeUnit.MILLISECONDS),
                        new BiFunction<Integer, Long, Integer>() {
                            @Override
                            public Integer apply(Integer integer, Long aLong) {
                                return integer;
                            }
                        })
                .buffer(Flowable.interval(0,200, TimeUnit.MILLISECONDS),
                        new Function<Long, Publisher<?>>() {
                            @Override
                            public Publisher<?> apply(Long a) {
                                return Flowable.just(a).delay(100, TimeUnit.MILLISECONDS);
                            }
                        })
                .test()
                .assertSubscribed()
                .awaitDone(3, TimeUnit.SECONDS)
                .assertComplete();
    }

    @Test
    public void bufferedCanCompleteIfOpenNeverCompletesOverlapping() {
        Flowable.range(1, 200)
                .zipWith(Flowable.interval(5, TimeUnit.MILLISECONDS),
                        new BiFunction<Integer, Long, Integer>() {
                            @Override
                            public Integer apply(Integer integer, Long aLong) {
                                return integer;
                            }
                        })
                .buffer(Flowable.interval(0,100, TimeUnit.MILLISECONDS),
                        new Function<Long, Publisher<?>>() {
                            @Override
                            public Publisher<?> apply(Long a) {
                                return Flowable.just(a).delay(200, TimeUnit.MILLISECONDS);
                            }
                        })
                .test()
                .assertSubscribed()
                .awaitDone(3, TimeUnit.SECONDS)
                .assertComplete();
    }
```"Fix posted in #5811. =||= 2.x: Fix buffer(open, close) not disposing indicators properly"The PR fixes the resource management in the `buffer` operator that uses other reactive sources to indicate when a buffer starts and ends. Both `Flowable` and `Observable` implementations had to be fixed.

Fixes: #5809"David Karnokakarnokd01/19/18, 09:36:39 AM
5819.05820RxJavaPlugins.java should not be reading all system properties"Hi,

I am working on 1.3.4 version of Rxjava jar and there are certain methods where RxJavaPlugins.java is trying to read all the system properties while getting hooks. Not all companies give access to their system properties on server. For example, we use tomcat and have catalina policy which restricts to properties mentioned there. Due to this, i am getting access denied exceptions.

I propose 2 solutions:
1. Remove system.getproperties() and it should be able to read only properties which are required to get the hooks
2. Provide an implementation via application property which doesn't look for implementation at all.

I am okay with either solution. Please help""It was a long time ago and I'm not sure we know what keys to look for, hence the full enumeration. Besides, v1 is nearly EOL so please consider upgrading to RxJava 2 which shouldn't have this problem. =||= It came to my thought that but we are not using rxjava dependency directly. This is being referenced as a compile dependency from spring-cloud-starter-hystrix jar. If rxjava 2.x is backward compatible, i can use it. But it looks like there are quite a few enhancements =||= Workaround posted in #5820. I assume the exception happens in the `entrySet` iteration and not in the `clone` line, right? =||= No, they actually happen in the following methods of RxJavaPlugins

getErrorHandler()
getObservableExecutionHook()
getSingleExecutionHook()
getCompletableExecutionHook()
getSchedulersHook()

These methods are being currently called as default implementations if custom handlers/hooks are not available. These methods search for ""all system properties"" first to look for implementation class defined in system property instead of looking for certain system properties. =||= Please post the full stacktrace of the exception you are getting. =||= ```
25-Jan-2018 03:28:55.941 SEVERE [localhost-startStop-1] org.apache.catalina.core.ContainerBase.addChildInternal ContainerBase.addChild: start:
org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/XXX]]
        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:167)
        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:752)
        at org.apache.catalina.core.ContainerBase.access$000(ContainerBase.java:129)
        at org.apache.catalina.core.ContainerBase$PrivilegedAddChild.run(ContainerBase.java:150)
        at org.apache.catalina.core.ContainerBase$PrivilegedAddChild.run(ContainerBase.java:140)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:726)
        at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:734)
        at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:986)
        at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1857)
        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
        at java.util.concurrent.FutureTask.run(FutureTask.java:266)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'documentationPluginsBootstrapper' defined in URL [jar:file:/D:/dev/apache-tomcat-8.5.24/temp/0-contestgateway/WEB-INF/lib/springfox-spring-web-2.8.0.j
!/springfox/documentation/spring/web/plugins/DocumentationPluginsBootstrapper.class]: Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean
th name 'webMvcRequestHandlerProvider' defined in URL [jar:file:/D:/dev/apache-tomcat-8.5.24/temp/0-contestgateway/WEB-INF/lib/springfox-spring-web-2.8.0.jar!/springfox/documentation/spring/web/plugins/WebMvcRequestHandlerProvider.class]: Unsatisfied depende
y expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'endpointHandlerMapping' defined in class path resource [org/springframework/boot/actuate/autoconfigure/En
ointWebMvcManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMappi
]: Factory method 'endpointHandlerMapping' threw exception; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigu
/EndpointWebMvcManagementContextConfiguration.class]: Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/spr
gframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration$HystrixWebConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749)
        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)
        at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)
        at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543)
        at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122)
        at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693)
        at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360)
        at org.springframework.boot.SpringApplication.run(SpringApplication.java:303)
        at org.springframework.boot.web.support.SpringBootServletInitializer.run(SpringBootServletInitializer.java:154)
        at org.springframework.boot.web.support.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:134)
        at org.springframework.boot.web.support.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:87)
        at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:169)
        at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5196)
        at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)
        ... 14 more
Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'webMvcRequestHandlerProvider' defined in URL [jar:file:/D:/dev/apache-tomcat-8.5.24/temp/0-contestgateway/WEB-INF/lib/springfox-spring-web-2.8.0.jar!/
ringfox/documentation/spring/web/plugins/WebMvcRequestHandlerProvider.class]: Unsatisfied dependency expressed through constructor parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'endpoi
HandlerMapping' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationE
eption: Failed to instantiate [org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping]: Factory method 'endpointHandlerMapping' threw exception; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean wi
name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationExcep
on: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration$HystrixWebConfiguration.class]: Invocation of init method failed; nested exception is java.
ng.ExceptionInInitializerError
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749)
        at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1316)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1282)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1180)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1096)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)
        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835)
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741)
        ... 36 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'endpointHandlerMapping' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Bea
instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping]: Factory method 'endpointHandlerMapping' threw exc
tion; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]
Invocation of init method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreak
Configuration$HystrixWebConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:599)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1173)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1067)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
        at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1316)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1282)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1180)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1096)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066)
        at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835)
        at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741)
        ... 53 more
Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.boot.actuate.endpoint.mvc.EndpointHandlerMapping]: Factory method 'endpointHandlerMapping' threw exception; nested exception is org.springframework.be
s.factory.BeanCreationException: Error creating bean with name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Invocation of init method failed; nested excepti
is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration$HystrixWebConfiguration.class]: In
cation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:189)
        at org.springframework.beans.factory.support.ConstructorResolver$3.run(ConstructorResolver.java:582)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:579)
        ... 69 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'mvcEndpoints' defined in class path resource [org/springframework/boot/actuate/autoconfigure/EndpointWebMvcManagementContextConfiguration.class]: Invocation of
nit method failed; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration
ystrixWebConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1628)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)
        at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.obtainBeanInstanceFromFactory(ConfigurationClassEnhancer.java:389)
        at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:361)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f0fb20ab.mvcEndpoints(<generated>)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration.endpointHandlerMapping(EndpointWebMvcManagementContextConfiguration.java:100)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f0fb20ab.CGLIB$endpointHandlerMapping$0(<generated>)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f0fb20ab$$FastClassBySpringCGLIB$$950684e.invoke(<generated>)
        at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228)
        at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:358)
        at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f0fb20ab.endpointHandlerMapping(<generated>)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162)
        ... 72 more
Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'hystrixStreamEndpoint' defined in class path resource [org/springframework/cloud/netflix/hystrix/HystrixCircuitBreakerConfiguration$HystrixWebConfiguration.cla
]: Invocation of init method failed; nested exception is java.lang.ExceptionInInitializerError
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1628)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)
        at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)
        at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)
        at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)
        at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:519)
        at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:508)
        at org.springframework.context.support.AbstractApplicationContext.getBeansOfType(AbstractApplicationContext.java:1188)
        at org.springframework.beans.factory.BeanFactoryUtils.beansOfTypeIncludingAncestors(BeanFactoryUtils.java:261)
        at org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints.afterPropertiesSet(MvcEndpoints.java:58)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$6.run(AbstractAutowireCapableBeanFactory.java:1677)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1674)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1624)
        ... 92 more
Caused by: java.lang.ExceptionInInitializerError
        at com.netflix.hystrix.contrib.metrics.eventstream.HystrixMetricsStreamServlet.<init>(HystrixMetricsStreamServlet.java:59)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
        at java.lang.Class.newInstance(Class.java:442)
        at org.springframework.web.servlet.mvc.ServletWrappingController.afterPropertiesSet(ServletWrappingController.java:144)
        at org.springframework.cloud.netflix.endpoint.ServletWrappingEndpoint.afterPropertiesSet(ServletWrappingEndpoint.java:50)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory$6.run(AbstractAutowireCapableBeanFactory.java:1677)
        at java.security.AccessController.doPrivileged(Native Method)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1674)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1624)
        ... 107 more
Caused by: java.security.AccessControlException: access denied (""java.util.PropertyPermission"" ""*"" ""read,write"")
        at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)
        at java.security.AccessController.checkPermission(AccessController.java:884)
        at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
        at java.lang.SecurityManager.checkPropertiesAccess(SecurityManager.java:1262)
        at java.lang.System.getProperties(System.java:630)
        at rx.plugins.RxJavaPlugins.getSchedulersHook(RxJavaPlugins.java:345)
        at rx.schedulers.Schedulers.<init>(Schedulers.java:57)
        at rx.schedulers.Schedulers.getInstance(Schedulers.java:46)
        at rx.schedulers.Schedulers.computation(Schedulers.java:123)
        at rx.Observable.interval(Observable.java:2070)
        at com.netflix.hystrix.metric.consumer.HystrixDashboardStream.<init>(HystrixDashboardStream.java:41)
        at com.netflix.hystrix.metric.consumer.HystrixDashboardStream.<clinit>(HystrixDashboardStream.java:69)
        ... 119 more
``` =||= Updated the PR. =||= Thank you so much for your quick response and fix =||= Closing via #5820. =||= "1.x: Plugin lookup workaround for System.properties access restrictions"The PR adds a `try-catch` around the System property lookup inside the `RxJavaPlugins` in case a security manager prevents reading arbitrary property entries.

This mainly affects the `rxjava.plugin.[index].class` lookup which were introduced due to the 31 character key limit on Android.

However, when running in a container such as Tomcat, a security manager may prevent reading these type of prefixed entries (where `[index]` can't be known upfront), crashing the initialization.

**Update**:

The `System.getProperties()` can also fail, therefore, retrieving the properties has been factored out into a separate method that returns an empty properties.

Fixes #5819."David Karnokakarnokd01/25/18, 12:40:00 PM
5832.058332.x Observable onError does not dispose switchMap's inner ObservableSource"Hi, I'm facing an issue with Observable's switchMap/switchMapSingle where the inner source does not get disposed if the upstream emits an error. Happens on both version 2.1.6 and 2.1.9. Is this the expected behavior?

Observable version does not dispose the inner source
```        
        Observable
                .create(e -> {
                    e.onNext(true);
                    e.onError(new Throwable());
                })
                .switchMap(__ -> Observable
                        .timer(500L, TimeUnit.MILLISECONDS)
                        .doOnNext(System.out::println))
                .subscribe(__->{}, __->{});
        Thread.sleep(1000L);
```


While the Flowable version does dispose the inner source.

```        
        Flowable
                .create(e -> {
                    e.onNext(true);
                    e.onError(new Throwable());
                }, BackpressureStrategy.BUFFER)
                .switchMap(__ -> Flowable
                        .timer(500L, TimeUnit.MILLISECONDS)
                        .doOnNext(System.out::println))
                .subscribe(__->{}, __->{});
        Thread.sleep(1000L);
```"Thanks for reporting. This is a bug in the `Observable.switchMap` implementation. Fix posted in #5833. =||= 2.x: Fix Observable.switchMap main onError not disposing the current inner source"The `Observable.switchMap` had bad logic in its main `onError` handler which didn't dispose the current inner `Observable`.

The `Flowable` version didn't have this logic error. Both variants received an unit test to verify the correct behavior.

Fixes #5832."David Karnokakarnokd02/02/18, 09:56:25 AM
5882.05886Update the algorithm Observable.timeout(time) & timeout(selector)"Update the `Observable.timeout(time)` and the `Observable.timeout(selectors)` operators to the more modern atomic index tracking algorithm and get rid of `ObserverFullArbiter` and `FullArbiterObserver`.

Their `Flowable` counterparts have been updated in #5661."2.x: Upgrade the algorithm of Observable.timeout(time|selector) operators"This PR improves the algorithms of the `Observable.timeout(time)` and `Observable.timeout(selector)` operators to match their `Flowable` counterparts implemented in #5661.

In addition, coverage of the `Flowable` counterparts have been improved by synchronizing the unit tests.

Note that they were the last users of `ObserverFullArbiter` and `FullArbiterObserver` which are now removed.

Closes #5882."David Karnokakarnokd03/04/18, 01:38:27 PM
5881.05887Incorrect upstream management in window(Observable) and window(Callable)While working on coverage improvements, I've noticed `Flowable.window(Publisher<B>)` and `Flowable.window(Callable<Publisher<B>>)` (plus their `Observable` counterpart) manage the upstream incorrectly as they don't cancel it when both the main output and the current window have been cancelled.2.x: Fix window(Observable|Callable) upstream handling"This PR fixes the upstream handling in `Observable.window(ObservableSource)` and `Observable.window(Callable<ObservableSource>)` operators to make sure if both the main output and the inner windows have been disposed, the upstream is also disposed.

Fixes #5881.

*Remark:*

There are a couple of `w != null` checks showing up as partially covered. In theory, with the right interleaving, `w` can become `null`, but unfortunately the usual `TestHelper.race()` testing is unlikely to trigger that case. There would be a higher chance with 3 threads (one disposing, one completing the main and one completing the inner window) but the current CI is effectively 1.5 - 2 cores/threads that tend to not produce a thorough interleaving."David Karnokakarnokd03/04/18, 06:19:12 PM
5894.058952.x: buffer documentation incorrect for onError behaviour"The documentation for most `buffer` operators reads as follows:

> When the source ObservableSource completes or encounters an error, the resulting ObservableSource emits the current buffer and propagates the notification from the source ObservableSource.

This is incorrect; none of the `buffer` operators emit their buffer before propagating an error:

```
@Override
public void onError(Throwable t) {
    buffer = null;
    actual.onError(t);
}
```

Note that this documentation was fixed in 1.x in #3561 (this is effectively a duplicate of issue #3560)."Fix buffer() documentation to correctly describe onError behaviourFixes #5894. I just copied the sentence from the fixed docs in 1.x and updated to use ObservableSource/Publisher naming.Adam Speakmanadamsp03/07/18, 10:46:53 AM
5261.058972.x: dematerialize and completion"I do not expect `Flowable.just(Notification.createOnNext(1)).dematerialize()` to complete but it does.

Do you think this is a bug too? If so I can submit a PR.""Ditto `Observable.dematerialize` =||= It't not a bug. =||= Yes I agree that formally it's not a bug because the javadoc for `dematerialize` says:

>Returns a Flowable that reverses the effect of materialize by transforming the Notification objects emitted by the source Publisher into the items or notifications they represent.

A simpler example of the issue is that `Flowable.empty().dematerialize()` should not complete because `Notification.onComplete`/`Notification.onError` were not emitted by `Flowable.empty()`. I think the current behaviour is counter-intuitive and should be changed (will not contradict the javadoc by the way because its behaviour was undefined).

@akarnokd If you don't agree that the current behaviour should be changed then I suggest I supplement the javadoc to describe the operator's behaviour more precisely.

 =||= You can suppress the terminal event by concatenating with never. You can post a PR that adds more clarification. =||= PR welcome. =||= Will do, I'll make it this weekend.

On 6 July 2017 at 08:29, David Karnok <notifications@github.com> wrote:

> PR welcome.
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/ReactiveX/RxJava/issues/5261#issuecomment-313244494>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AATa6_G7dhJycDRIxNgPcEA6ty08s2k6ks5sLA4vgaJpZM4MxA-L>
> .
>
 =||= Do you still want to contribute the clarification? =||= "2.x: clarify dematerialize() and terminal items/signals"Specify in both `Flowable` and `Observable` that a terminal notification item or a regular terminal signal ends the flow.

Fixes: #5261"David Karnokakarnokd03/07/18, 11:06:50 AM
5903.05904Flowable.singleOrError() does not signal an exception if followed by flatMapPublisher"The following code demonstrates the expected behavior of Flowable.singleOrError() (as I understand it):
```
Flowable.empty()
    .singleOrError()
    .blockingGet(); // NoSuchElementException is thrown, as expected
```
    
However, if singleOrError() is immediately followed by Single.flatMapPublisher(...), the exception is lost:
```
Flowable.empty()
    .singleOrError()
    .flatMapPublisher(Flowable::just)
    .blockingSubscribe(); // No exception is thrown
```
    
Strangely, if anything is done between Flowable.singleOrError() and Single.flatMapPublisher(...), the exception is thrown as expected:
```
Flowable.empty()
    .singleOrError()
    .map(x -> x)
    .flatMapPublisher(Flowable::just)
    .blockingSubscribe(); // NoSuchElementException is thrown, as expected
```
    
This is with RxJava 2.1.10 and Reactive Streams 1.0.2."Thanks for reporting and sharing code to reproduce the issue. The bug is in `singleOrError` triggered by a conversion back to `toFlowable`. Fix posted in #5904. =||= 2.x: Fix Flowable.singleOrError().toFlowable() not signalling NoSuchElementException"When a `singleOrError` is followed by `toFlowable()`, the assembly process switches the `Flowable->Single` operator into a `Flowable->Flowable` operator implementing the `singleOrError` behavior (saving the back-and-forth type conversion). The backing implementation was shared with `singleElement` and as such, did not properly handle the `orError` case for an empty source. The PR fixes the lack of `NoSuchElementException` in this case.

Fixes #5903.

The `Observable` variant doesn't have such optimization but the test has been converted to make sure `Observable` is verified for this aspect in case the optimization is implemented with it in the future."David Karnokakarnokd03/09/18, 08:43:45 AM
5901.059062.x: Pulib constructor for TestScheduler that already takes the time"I'd like to have the ability to have an instantiated TestScheduler which already has a time. Internally it'd just delegate to `advanceTimeTo` and the constructor would also take the same parameters as that method.

What are your thoughts?""You can do it simply after construction:

```java
TestScheduler scheduler = new TestScheduler();
scheduler.advanceTimeBy(System.currentTimeMillis(), TimeUnit.MILLISECONDS);
```

If this is frequent, just create a static helper method:

```java
public static TestScheduler newTestScheduler(long initialTimeMillis) {
    TestScheduler scheduler = new TestScheduler();
    scheduler.advanceTimeBy(initialTimeMillis, TimeUnit.MILLISECONDS);
    return scheduler;
}
``` =||= Yeah with Kotlin it's even easier. I still feel like a constructor that takes the time would be beneficial. I'm not feeling too strong about it so I'll see what the opinions of other folks are. =||= I guess this isn't that of a maintenance intensive change so PR welcome. You could set the current time directly without wasting time by calling `advanceTimeBy`. =||= "2.x: Add public constructor for TestScheduler that takes the time."- adds a time constructor to TestScheduler
- should I make it experimental or will it just be stable?

Fixes #5901"Niklas Baudyvanniktech03/09/18, 01:22:54 PM
5916.059232.x: Javadoc syntax error"```
:javadoc
/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:6519: error: text not allowed in <dl> element
     * <dl>
           ^
/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Flowable.java:6552: error: text not allowed in <dl> element
     * <dl>
           ^
/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:5955: error: text not allowed in <dl> element
     * <dl>
           ^
/home/travis/build/ReactiveX/RxJava/src/main/java/io/reactivex/Observable.java:5984: error: text not allowed in <dl> element
     * <dl>
```"Is there any way to fail the build when those errors / warnings are present? =||= There is a property for it in [build.gradle](https://github.com/ReactiveX/RxJava/blob/2.x/build.gradle#L82). I'd leave it on not failing though. =||= 2.x: Fix JavaDoc warnings of buffer(Publisher|Callable)"Text is not allowed between `<dl>` and its child tags.

Fixes #5916."David Karnokakarnokd03/19/18, 02:26:10 PM
5927.05928[2.1.11] NPE in SpscLinkedArrayQueue.lvElement"I've seen already a couple of those after upgrading. Unfortunately I cannot give you any reproduction as I have zero idea where it might come from but here are a couple of stacktraces:

```
java.lang.NullPointerException
 at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement(SpscLinkedArrayQueue.java:249)
 at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll(SpscLinkedArrayQueue.java:154)
 at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll(SpscLinkedArrayQueue.java:144)
 at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear(SpscLinkedArrayQueue.java:184)
 at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.dispose(ObservableConcatMapMaybe.java:152)
 at io.reactivex.internal.observers.BasicFuseableObserver.dispose(BasicFuseableObserver.java:152)
 at io.reactivex.internal.observers.BasicFuseableObserver.dispose(BasicFuseableObserver.java:152)
 at io.reactivex.internal.operators.observable.ObservableTake$TakeObserver.dispose(ObservableTake.java:90)
 at io.reactivex.internal.disposables.DisposableHelper.dispose(DisposableHelper.java:125)
 at io.reactivex.internal.observers.LambdaObserver.dispose(LambdaObserver.java:100)
 at java.util.HashMap$Values.forEach(HashMap.java:981)
```

```
java.lang.NullPointerException
 at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement(SpscLinkedArrayQueue.java:249)
 at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll(SpscLinkedArrayQueue.java:154)
 at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll(SpscLinkedArrayQueue.java:144)
 at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear(SpscLinkedArrayQueue.java:184)
 at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.drain(ObservableConcatMapMaybe.java:200)
 at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.innerSuccess(ObservableConcatMapMaybe.java:165)
 at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver$ConcatMapMaybeObserver.onSuccess(ObservableConcatMapMaybe.java:290)
 at io.reactivex.internal.operators.single.SingleFlatMapMaybe$FlatMapMaybeObserver.onSuccess(SingleFlatMapMaybe.java:117)
 at io.reactivex.internal.operators.maybe.MaybeJust.subscribeActual(MaybeJust.java:36)
 at io.reactivex.Maybe.subscribe(Maybe.java:4065)
```

This didn't happen on `2.1.10` or any of the previous versions. Please tell me if I can help more.""Hi and thanks for reporting. This is a bug in the newly introduced operators of 2.1.11. As a temporary workaround, use the traditional `concatMap` with a [type conversion operator](https://github.com/ReactiveX/RxJava#converting-to-the-desired-type). =||= Thank you for the immediate support! Thanks for the great work! =||= You are welcome. Still, please keep using 2.1.11 as long as 2.1.12 comes out in case there are more mistakes such as this - you seem to be exceptionally lucky to stumble upon them as it takes about 1 minute on my desktop machine to trigger the bug by only using standard methods. =||= Hi, we're seeing a similar crash in 2.2.12:
```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 138(SpscLinkedArrayQueue.java:138)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)
       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber.cancel + 157(BasicFuseableConditionalSubscriber.java:157)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)
       at io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber.tryOnNext + 101(FlowableDistinctUntilChanged.java:101)
       at io.reactivex.internal.operators.flowable.FlowableMap$MapConditionalSubscriber.tryOnNext + 128(FlowableMap.java:128)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnConditionalSubscriber.runAsync + 649(FlowableObserveOn.java:649)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)
``` =||= @DavidDTA could you provide a code sample that reproduces this issue? =||= We just upgraded our project from 1.x, and did not see these errors in testing, but are seeing them in production.  We're working to figure out the exact cause, and will provide more information as we have it.

Here are some additional stack traces, in case you notice any pattern:
```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll + 155(SpscLinkedArrayQueue.java:155)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 145(SpscLinkedArrayQueue.java:145)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)
       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber.cancel + 157(BasicFuseableConditionalSubscriber.java:157)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.cancel + 168(FlowableConcatMapMaybe.java:168)
       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)
       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.drain + 284(FlowableConcatMapMaybe.java:284)
       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.onNext + 137(FlowableConcatMapMaybe.java:137)
       at io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber.tryOnNext + 101(FlowableDistinctUntilChanged.java:101)
       at io.reactivex.internal.operators.flowable.FlowableMap$MapConditionalSubscriber.tryOnNext + 128(FlowableMap.java:128)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnConditionalSubscriber.runAsync + 649(FlowableObserveOn.java:649)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)
```
```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll + 155(SpscLinkedArrayQueue.java:155)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 145(SpscLinkedArrayQueue.java:145)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)
       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.clear + 264(FlowableOnBackpressureBuffer.java:264)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.clear + 236(FlowableObserveOn.java:236)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated + 188(FlowableObserveOn.java:188)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync + 399(FlowableObserveOn.java:399)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)
       at io.reactivex.internal.schedulers.ScheduledRunnable.run + 66(ScheduledRunnable.java:66)
       at io.reactivex.internal.schedulers.ScheduledRunnable.call + 57(ScheduledRunnable.java:57)
```
```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 138(SpscLinkedArrayQueue.java:138)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)
       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableSkipWhile$SkipWhileSubscriber.cancel + 93(FlowableSkipWhile.java:93)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)
       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.tryOnNext + 74(FlowableFilter.java:74)
       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.onNext + 52(FlowableFilter.java:52)
       at io.reactivex.internal.operators.flowable.FlowableSkipWhile$SkipWhileSubscriber.onNext + 56(FlowableSkipWhile.java:56)
       at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.onNext + 68(FlowableMap.java:68)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync + 407(FlowableObserveOn.java:407)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)
``` =||= It crashes when it tries to clear the buffer of `onBackpressureBuffer` upon receiving cancellation. However, this particular crash would only happen when `clear` is invoked concurrently, which shouldn't be possible. Any more indications on the operator chain would be helpful because the stacktrace does not indicate the full chain. =||= The full chain for the last stack trace is:
```
Single.just(...)
  .delaySubscription(
    Completable.amb(
      listOf(
        Completable.timer(...),
        FlowableProcessor
          .map { ... }
          .onBackpressureBuffer()
          .compose { it.observeOn(...) }
          .map { ... }
          .observeOn(...)
          .map { ... }
          .skipWhile { ... }
          .filter { ... }
          .firstOrErrror()
          .ignoreElement()
      )
    )
      .toObservable<Any>()
  )
  .subscribeOn(...)
``` =||= Thanks. I have some suspicion I have to verify. In the meantime, could you see if you put `hide()` after `onBackpressureBuffer()` the crashes stop happening? =||= I can attempt this, but it will take time to collect that data. =||= Thanks. Posted #6673 to track this issue specifically. =||= For the record, using `hide()` did stop the crashes. =||= "2.x: Fix concatMapSingle & concatMapMaybe dispose-cleanup crash"This PR fixes the accidental logical mistake in the `cancel`/`dispose` logic of the new `concatMapSingle` and `concatMapMaybe` operators of both `Flowable` and `Observable` where the internal queue cleanup should happen in a serialized fashion only, which is the state when the work-in-progress counter changes from 0 to 1 ensured by a `==` check.

Fixes #5927"David Karnokakarnokd03/23/18, 10:31:48 AM
5934.059351.x OperatorTake seem to swallow Exceptions"We have a Observable that is transformed into a Single. Some unrelated changes caused a Exception in the `onSuccess` Action of the Subscriber. This exception seems to get lost. It neither gets propagated to the `onError` Action, nor to the `RxJavaHooks.setOnError` Action.

Sample that reproduces the problem:

```java
RxJavaHooks.setOnError(error -> System.out.println(""got global error "" + error));
Observable.just(""1"")
        .first()
        .toSingle()
        .subscribe(
                it -> {
                    System.out.println(""going to throw"");
                    throw new NullPointerException(""bla"");
                },
                error -> System.out.println(""got error "" + error)
        );

// Output:

going to throw

Process finished with exit code 0
```

If I change the sample to this it does propagate the error (removed the `first()` call):
```java
RxJavaHooks.setOnError(error -> System.out.println(""got global error "" + error));
Observable.just(""1"")
        .toSingle()
        .subscribe(
                it -> {
                    System.out.println(""going to throw"");
                    throw new NullPointerException(""bla"");
                },
                error -> System.out.println(""got error "" + error)
        );

// Output

going to throw
got error java.lang.NullPointerException: bla

Process finished with exit code 0

```

This is what I found out while debugging.
Exception is caught here:
https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OnSubscribeLift.java#L49-L55

`st` is in this case the OperatorTake:
https://github.com/ReactiveX/RxJava/blob/1.x/src/main/java/rx/internal/operators/OperatorTake.java#L60-L70
it is already `completed`. So the `Throwable` is just ignored.

Could be related/the same as #3571."Hi and thanks for reporting. Indeed 1.x was not too keen on reporting undeliverable errors. I'll post a fix shortly but note that support for 1.x will end on March 31 with a final release. =||= This can be closed now. =||= 1.x: Fix take() to route late errors to RxJavaHooks"If there is a late exception after take has unsubscribed from the upstream, this exception was ignored by the operator. This fix makes sure such late exceptions are routed to the `RxJavaHooks.onError` handler, just like 2.x does.

Fixes: #5934."David Karnokakarnokd03/26/18, 01:45:53 PM
5933.059472.x -- groupBy with evicting map -- seeing inconsistent behavior when eviction occurs"I am using version 2.1.11.  I'm seeing what I believe to be a bug in the groupBy operator when configured to use an evicting map.  Here is a test that demonstrates what I'm seeing:

```java
    private static class TestTicker extends Ticker {
        long tick = 0;

        @Override
        public long read() {
            return tick;
        }
    }
    
    @Test
    public void testGroupByEviction() {
        FlowableProcessor<Integer> source = PublishProcessor.create();
        TestSubscriber<Integer> subscriber1 = new TestSubscriber<>();
        TestTicker testTicker = new TestTicker();

        Function<Consumer<Object>, Map<Object, Object>> mapFactory = action -> {
            return CacheBuilder.newBuilder()
                    .expireAfterAccess(5, TimeUnit.SECONDS)
                    .removalListener(notification -> {
                        try {
                            action.accept(notification.getValue());
                        } catch (Exception ex) {
                            throw new RuntimeException(ex);
                        }
                    }).ticker(testTicker).build().asMap();
        };

        final List<String> list = Collections.synchronizedList(new ArrayList<String>());
        Flowable<Integer> stream = source.doOnCancel(() -> list.add(""Source canceled""))
                .groupBy(v -> v, Functions.identity(), false, Flowable.bufferSize(), mapFactory)
                .flatMap(group -> {
            return group
                    .doOnComplete(() -> list.add(""Group completed""))
                    .doOnCancel(() -> list.add(""Group canceled""));
        });
        stream.doOnCancel(() -> list.add(""Outer group by canceled."")).subscribe(subscriber1);
        
        // Send 3 in the same group and wait for them to be seen
        source.onNext(1);
        source.onNext(1);
        source.onNext(1);
        subscriber1.awaitCount(3);
        
        // Advance time far enough to evict the group.
        // NOTE -- Comment this line out to make the test ""pass"".
        testTicker.tick = TimeUnit.SECONDS.toNanos(6);
        
        // Send more data in the group (triggering eviction and recreation)
        source.onNext(1);
        source.onNext(1);

        // Wait for the last 2 and then cancel the subscription
        subscriber1.awaitCount(5);
        subscriber1.cancel();

        // Observe the result.  Note that right now the result differs depending on whether eviction occurred or
        // not.  The observed sequence in that case is:  Group completed, Outer group by canceled., Group canceled.
        // The addition of the ""Group completed"" is actually fine, but the fact that the cancel doesn't reach the
        // source seems like a bug.  Commenting out the setting of ""tick"" above will produce the ""expected"" sequence.
        assertEquals(Arrays.asList(
                // ""Group completed"", -- this is here when eviction occurs
                ""Outer group by canceled."", 
                ""Group canceled"",
                ""Source canceled""  // This is *not* here when eviction occurs
        ), list);
    }
```

As you can see from this when a group eviction occurs and the root subscription is canceled, the cancel dose not propagate beyond the `groupBy` (it does when there is no eviction).  I think the reason for this is that after the eviction processing (line 188 of FlowableGroupBy) the groupCount is 3 when I believe it should be 2).  This leads the groupBy to conclude that there are 2 active groups when the cancel occurs, when in fact there is only one.  This doesn't happen when there is no eviction (you can see this by commenting out the line that updates ""tick"").""Yes, looks like eviction only happens when an upstream item is coming down. I think the same eviction logic could be run in `cancel()` as well:

```java
        @Override
        public void cancel() {
            // cancelling the main source means we don't want any more groups
            // but running groups still require new values
            if (cancelled.compareAndSet(false, true)) {

                if (evictedGroups != null) {
                    GroupedUnicast<K, V> evictedGroup;
                    while ((evictedGroup = evictedGroups.poll()) != null) {
                        evictedGroup.onComplete();
                    }
                }

                if (groupCount.decrementAndGet() == 0) {
                    s.cancel();
                }
            }
        }
```

/cc @davidmoten  =||= Thanks for the report, I'll fix tomorrow =||= Sorry for the delay. I'll try to tackle this in the coming weeks. =||= "2.x: fix groupBy cancellation with evicting map factory"Fixes #5933.

When the outer stream is cancelled there may be evicted groups present in the queue to be completed.

I've added code to complete the evicted groups in the `cancel` method as suggested by @akarnokd. To protect against a race condition where the EvictionAction is called just after the evicted groups are completed in `cancel` I've added a `cancelled` check to `EvictionAction`. 

However, I am concerned about a race that I'll place in the comments on the code below."Dave Motendavidmoten05/29/18, 12:14:34 PM
5971.05972concatMapSingle ignores some onNext events"**Version used: 2.1.12**

I have a collection of interfaces. They all define a method fetching a collection of items: `Single<List<Integer>> fetchItems()`. 
Some of them perform local computations, others a network call. When concatening using `concatMapSingle`, some of the singles are not subscribed at all.

Here is a test I do think should pass. A network call is faked here using a timer. If the timer is replaced with `Single.just` instead, the test is passing.

```java
@Test
public void test() {
  TestScheduler testScheduler = new TestScheduler();

  final Single<List<Integer>> first = Single.timer(2, TimeUnit.SECONDS, testScheduler).map(u -> Arrays.asList(1, 2, 3));
  final Single<List<Integer>> second = Single.just(Collections.emptyList());
  final Single<List<Integer>> third = Single.just(Collections.singletonList(4));
  final Single<List<Integer>> fourth = Single.just(Collections.singletonList(5));

  Single<List<Integer>> subject = Observable
    .fromIterable(Arrays.asList(first, second, third, fourth))
    .concatMapSingle(single -> single)
    .reduce(new ArrayList<>(), (seed, items) -> {
      seed.addAll(items);
      return seed;
    });

    TestObserver<List<Integer>> testObserver = subject.test();
    testScheduler.advanceTimeBy(2, TimeUnit.SECONDS);

    testObserver.assertValue(list -> list.equals(Arrays.asList(1, 2, 3, 4, 5))); 
    // 5 is currently missing ; fourth was never subscribed in the first place
}
```

*It is my first issue on this repo, feel free to edit my PR if I am not respecting the contribution guidelines.*"Hi and thanks for reporting. This is a bug in the `concatMapSingle` operator. I'll post a fix shortly. =||= Fix in #5972. =||= Thanks, appreciate it! =||= 2.x: Fix Observable.concatMapSingle dropping upstream items"The internal queue of `Observable.concatMapSingle` was incorrectly the bounded one from its `Flowable` counterpart, causing it to drop upstream items if the current `Single` was delayed. The right queue for `Observable`s is the `SpscLinkedArrayQueue`.

Added unit tests to both `concatMapSingle` and `concatMapMaybe` to verify the correct behavior.

Fixes: #5971."David Karnokakarnokd04/24/18, 08:06:16 AM
4856.05979Conflate Operator"RxJava should have conflate operator. I see we have sample, debounce etc but actually they are not equivalent to conflate . 

Conflate operator should behave as Sample if updates are faster than the given interval. But if updates stops and new update comes after a long period it should push immediately. Instead of waiting for sampling period. ""Is the behavior your after equivalent to zip(stream, interval())? I too
want such an operator and I was about to file an issue tomorrow. It finally
hit my three separate use cases bar for wanting it to be first party.

On Tue, Nov 15, 2016, 7:06 PM MajorMud notifications@github.com wrote:

> RxJava should have conflate operator. I see we have sample, debounce etc
> but actually they are not equivalent to conflate .
> 
> Conflate operator should behave as Sample if updates are faster than the
> given interval. But if updates stops and new update comes after a long
> period it should push immediately. Instead of waiting for sampling period.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4856, or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEd0LKzKaRnG1inDQ8dVB6VichZr9ks5q-nNQgaJpZM4KzS88
> .
 =||= Not sure how would you achieve with zip. 

sample at timeout out interval if source is emitting too fast but if source is slower than the timeout interval emit right away. 

O.O.O.O.O...............O 
--->-->-->-->-->-->-->-->
----X-------X-------------X 
 =||= Is `throttleFirst` closer to what you are looking for?

![](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.png)
 =||= throttleFirst drops events. I believe this doesn't want that. It's like ""at
most"" every X interval.

On Tue, Nov 15, 2016, 8:25 PM George Campbell notifications@github.com
wrote:

> Is throttleFirst closer to what you are looking for?
> 
> https://camo.githubusercontent.com/fe3f3d248d4933e30866c27188277684b24cbef8/68747470733a2f2f7261772e6769746875622e636f6d2f77696b692f5265616374697665582f52784a6176612f696d616765732f72782d6f70657261746f72732f7468726f74746c6546697273742e706e67
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4856#issuecomment-260850974,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEQHZBk0SiHGv1w-cS-l-XTh92gBaks5q-oWvgaJpZM4KzS88
> .
 =||= throttleLast/Sample is what i want if source is publishing too fast but then publish the item right away don't wait for the sample timeout if it was published slower than then timeout interval. 

took stab at this  

https://github.com/mrudangit/HelloRxJava/blob/master/src/main/java/com/solutionarchitects/Conflation.java
 =||= How about this?
![image](https://cloud.githubusercontent.com/assets/406038/20335040/e0c40332-ab73-11e6-9238-17bd9ff8cbbc.png)
 =||= For my case I would need green before the blues. If that's not conflate
I'll file a separate issue.

On Tue, Nov 15, 2016, 8:43 PM George Campbell notifications@github.com
wrote:

> How about this?
> [image: image]
> https://cloud.githubusercontent.com/assets/406038/20335040/e0c40332-ab73-11e6-9238-17bd9ff8cbbc.png
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/ReactiveX/RxJava/issues/4856#issuecomment-260852854,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAEEEeugJuqKqFvD7OH2pRXgKPqcpkyfks5q-ooGgaJpZM4KzS88
> .
 =||= I was being lazy about the timing of the end of yellow's timeout and cyan's arrival. I was mostly trying to highlight that this is `throttleFirstAndLastButNotLastIfItIsTheSameAsTheFirst`
- red is not emitted twice
- blue is emitted at the end of cyan's interval
 =||= Red should output at the end of first period, Green at the end of 2nd period, dark blue at the end of 3rd period , not at the start of period as shown. How to generate diagram. probably can explain that way better 
 =||= Was I misinterpreting this statement?

> publish the item right away don't wait for the sample timeout

That seems to conflict with

> Red should output at the end of first period

The diagram source file is an OmniGraffle in the wiki repo `https://github.com/ReactiveX/RxJava.wiki.git` the file is `images/rx-operators.graffle`
 =||= ![image](https://cloud.githubusercontent.com/assets/3153622/20335764/4afb379c-ab93-11e6-8959-4ee36ccfd066.png)
 =||= If I understand correctly, you need a throttleFirst but instead of dropping the incoming values in the period, you'd want to keep the latest and emit it immediately once the period ends, starting a new period. What should happen if there is an active period plus a latest element is waiting and the main source completes?
 =||= emit the last one emitted before onComplete 
yes want to throttle first 
but if there is inactivity more than the throttle period
when source emits emit right away bcos we already waited more than the throttle periods

so in my diagram yellow is emitted right away even though it falls between the throttle period because it wait one full throttle period before 
 =||= I think this operator should go into [rxjava-extras](https://github.com/davidmoten/rxjava-extras)/[RxJava2Extensions](https://github.com/akarnokd/RxJava2Extensions) as it seems to address the needs of a small set of developers only and possibly introduce confusion with `throttleFirst`. I'm sure @davidmoten and I will accept such operator if contributed.
 =||= Yes makes sense happy to contribute any guidelines please share advise 
 =||= Just clone the respective repo, create a new branch, pick a package (`hu.akarnokd.rxjava2.operators` for RxJava2Extensions, `com.github.davidmoten.rx.internal.operators` for rxjava-extras) write the operator, create the pull request and we will review it.
 =||= i cloned created a local branch 'conflateOperator' 

try to push get error . 


remote: Permission to akarnokd/RxJava2Extensions.git denied to mrudangit.
fatal: unable to access 'https://github.com/akarnokd/RxJava2Extensions.git/': The requested URL returned error: 403

 =||= Push to your own repository. =||= pushed to 
https://github.com/mrudangit/RxJava2Conflate
 =||= Now if you go to my repo, you should see the create PR option. =||= @mrudangit, in your latest drawing, shouldn't green be emitted (immediately), and then dark-blue, and light-blue, and then purple (delayed)? =||= yes it can be looked that way also 
to convey intent i did that way but yes the first one should be output immediately and the. delay as per interval 

 =||= Did you mean this operator & behavior: [ObservableConflate.java](https://gist.github.com/akarnokd/98a1a728a89e6f8dbd1efab104c2be0f)? =||= nice. as per test looks what it should do . will take it to spin. is it with Rxjava2 ? =||= RxJava 1.x =||= I've been looking for a non-lagging rate-limiting operator like the one described here for a while now, and couldn't find it. So, after some collaboration with our in-house experts (including @JakeWharton and @loganj), we came up with a `compose`-transformer (tested with RxJava 1.2.3):

```
public static <T> Transformer<T, T> adaptiveSample(long time, TimeUnit unit, Scheduler scheduler) {
  return source -> source
      .publish(shared -> concat(
          shared.take(1),
          shared.sample(time, unit, scheduler))
          .repeatWhen(a -> shared.debounce(time, unit, scheduler)));
}
```

This must be the most natural rate-limiting operator, because at any given moment of time it's as close to the source observable as possible, given the restriction of the rate-limiting time period. For example (time period == 4 chars):

```
source: -1-2-3-45------6-7-8-
output: -1---3---5-----6---8-
```

Notice how it emits immediately after a period of quiet, and then continues to sample while source is emitting at high rate. Thus, there is no unnecessary lag, as it ""adapts"" the sampling to the source, hence the name.

It could be used to rate-limit UI updates of an ""unread message count"", or to limit frequency of metadata refresh requests to server. Basically, it's what most people expect when they start looking at `sample`, `throttle`, `throttleFirst`, and similar operators.. which unfortunately do not work too well in real-world scenarios.

@mrudangit - could you try it and see if it works for you? =||= @valeriyo  looks good in testing. noticed one thing if i have more than 1 subscribers they are not getting same values. some get one published before etc.  in conflation done on publish side all the subscribers should get the same conflated output . 

@akarnokd  I am not able to compile in Java 8 / intellij .  =||= @mrudangit what is the compiler's error message? =||= I see. Oddly, Eclipse didn't complain. I have updated the gist. =||= I get this error. 
Error:(45, 17) java: name clash: call(rx.Subscriber<? super T>) in com.xxx.. overrides a method whose erasure is the same as another method, yet neither overrides the other
  first method:  call(T) in rx.functions.Func1
  second method: call(T) in rx.functions.Action1 =||= I'm closing this issue due to inactivity. If you have further input on the issue, don't hesitate to reopen this issue or post a new one. =||= I built my 3rd instance of this for a project (next time i'm stealing David's gist!). It seems to come up a lot when building UIs. You want to be notified immediately and then no frequently than X, unless more than X has passed in which case the next notification should be immediate. This is especially true as we have a lot of sources for UI which emit synchronously upon subscribe and then connect to some asynchronously updating source.

Sometimes I just compromise and do a `take(1)` and `throttleLast` merged despite it slowing down the async data.

I'm all for keeping RxJava small. There's plenty of custom one-off custom or composite operators I've had to build that I wouldn't want in the main lib. This one seems like it could make the cut for general applicability. I was able to find 2 other people in 10 minutes who had written versions of this (aside from the two others in this thread and me).

I'm not sure how we would determine whether or not something like this makes the cut. For me, it can be thought of as a variant of existing operators rather than something wildly new, it can't be created as a composite operator with acceptibly-low overhead (Valeriy's solution works, but it allocates quite a bit), and the use case seems non-rare (based on a small sample, no pun intended).

Would love to hear what others think. =||= Hi @JakeWharton,

Thanks for bringing this issue back to life :)

In my opinion, none of the built-in throttling operators are usable ""as is"" for many common tasks (including updating UI):
  * `throttleFirst` has no latency, but loses trailing items;
  * `throttleLast` has latency, and it's lossy w.r.t very last item;
  * `sample` has latency;
  * `debounce` has latency, and suffers from ""starvation"".

The middle two operators also maintain a ""ticking"" timer, which would wake up and re-schedule each and every interval, even if there is nothing to emit... hence, wasteful with bursty streams of events.

For these reasons, my opinion is that it would be way better to have one rate-limiting operator, which works (no latency, not lossy, no starvation, no unnecessary ticking timer) than have 4+ flawed ones ;)

Heck, it took me weeks, if not months to 1) realize that none of the built-in operators do what I want, 2) formulate the desired behavior, 3) search for solution online, give up, then consult, implement, and test - it shouldn't be so difficult!

By the way, here is the revised version, without `repeatWhen` (per #5414):
```
public static <T> Transformer<T, T> adaptiveSample(long time, TimeUnit unit, Scheduler scheduler) {
  return source -> source
      .publish(shared -> shared
          .debounce(time, unit, scheduler)
          .map(a -> 0)
          .startWith(0)
          .switchMap(a -> concat(shared.take(1), shared.sample(time, unit, scheduler))));
}
```

Regarding naming, I'm not sure that ""conflate"" is a good name... it's short, but it doesn't convey the meaning well enough. Maybe ""rateLimit"" or ""naturalSample""... something more easily understandable?

Thanks for reading. =||= This is a bit old issue and I can't remember the exact pattern expected here. I guess we can add this to RxJava. For discoverability, I'd name it `throttleAndSample` so it appears along with the other `throttleX` operators. =||= "2.x: Add throttleLatest operator"This PR adds the `throttleLatest` operator to `Observable` and `Flowable`, also known as `conflate` (#4856): it is a combination of `throttleFirst` and `sample` whereby frequent items are sampled but the first item outside the sampling window will be emitted immediately:

![throttleLatest](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.png)

![throttleLatest](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLatest.se.png)

Resolves: #4856
Replaces: #5968"David Karnokakarnokd05/17/18, 08:11:13 AM
5990.05991Drain applies mappers without scheduling."Here is the test case I've created

```
val testThread = Thread.currentThread();

rx.Observable.fromCallable { 10 }
        .toV2()
        .switchMap { original -> BehaviorSubject.createDefault(2)
            .observeOn(Schedulers.io())
            .map { multiplier ->
              if (Thread.currentThread() == testThread) throw AssertionError()
              original * multiplier
            }
        }
        .subscribe { throw IllegalStateException(""nice"") }

Thread.sleep(1000)
```

This hits the assertion error as `SwitchMapObserver` `poll`s the inner query inside its drain method, running the `poll` method on `MapObserver` which ends up running on the thread the switchmap was subscribed to on (i think?). 

I dont think the interop part is necessary to reproduce this bug, but was the consistent way I was able to get the `drain` method to poll the inner query as `fromCallable` emits a completion after the relay has emitted but before the mapper has received the event."Thanks for reporting. This is a bug in the fusion code of `switchMap`: it should report itself as a boundary just like `flatMap` to prevent this type of execution. I'll post a fix shortly. Until then you can apply `hide()` after map to prevent the fusion. =||= 2.x: Fix switchMap to indicate boundary fusion"Fix `Flowable.switchMap` and `Observable.switchMap` to request for boundary fusion in order to prevent a thread-confined but otherwise fusion-capable sub-sequence from running on the unintended thread.

Fixes: #5990"David Karnokakarnokd05/04/18, 03:47:22 PM
5999.06002Add a processor with backpressure"I'm working on a rxjava 2 integration with Apache Camel and I've found difficult to find a processor supporting backpressure.

All processors in https://github.com/ReactiveX/RxJava/tree/2.x/src/main/java/io/reactivex/processors (except `SerializedProcessor` that has a special purpose) do the following call during `onSubscribe`:

```
    @Override
    public void onSubscribe(Subscription s) {
        // ...
        s.request(Long.MAX_VALUE); // <-- i.e. no backpressure
    }
```

So if we put any of those processor between a publisher and a subscriber, there's no way to slow down the publisher in case the subscriber is slow.

We need a processor because our API expect that publishers and subscribers connect to the library in independent moments. First the publisher then the subscriber(s) or the opposite, both scenarios are allowed.

So we've used with other implementations a backpressure-aware ""connector"" in the middle: the connector is subscribed to the publisher when the publisher is available and the subscriber subscribe to the connector when the subscriber is available. When both are connected the flow starts.

I don't know if there there is a way to create such a backpressure-aware ""connector"" in rx-java 2, but doesn't seem so.""Hi. The standard RxJava 2 `Processor`s are all unbounded-in, but there exists the [`MulticastProcessor`](https://github.com/akarnokd/RxJava2Extensions#multicastprocessor) in the extensions project that does support backpressure coordination between its upstream and its downstream `Subscriber`s. =||= Seems to be perfect for our case. Thanks.

Any chance that it gets included in the main lib? =||= Probably. =||= Thanks a lot :+1:  =||= "2.x: Add MulticastProcessor"This PR adds the `MulticastProcessor` from the [extensions project](https://github.com/akarnokd/RxJava2Extensions#multicastprocessor) to be a standard processor option.

This type of processor fills the gap of having a backpressure-coordinating processor type as `PublishProcessor` doesn't coordinate backpressure on its own and `Flowable.publish()` often can't be used because the upstream may not yet exist when the dowstream consumers are setup.

![MulticastProcessor](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/MulticastProcessor.png)

Example:

```java
MulticastProcessor<Integer> mp = Flowable.range(1, 10)
    .subscribeWith(MulticastProcessor.create());

mp.test().assertResult(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// --------------------

MulticastProcessor<Integer> mp2 = MulticastProcessor.create(4);
mp2.start();

assertTrue(mp2.offer(1));
assertTrue(mp2.offer(2));
assertTrue(mp2.offer(3));
assertTrue(mp2.offer(4));

assertFalse(mp2.offer(5));

mp2.onComplete();

mp2.test().assertResult(1, 2, 3, 4);
```

Resolves: #5999"David Karnokakarnokd05/17/18, 09:17:55 PM
6004.060052.x: Odd JavaDoc formatting"Since we switched to Java 8 compilation, the generated JavaDocs often lists method arguments misaligned, for example:

http://reactivex.io/RxJava/2.x/javadoc/snapshot/io/reactivex/flowables/ConnectableFlowable.html#refCount-long-java.util.concurrent.TimeUnit-

![image](https://user-images.githubusercontent.com/1269832/39810638-0647a292-5386-11e8-9656-28b2a23061bd.png)

Looks like the whole section is put into `<pre>` so those extra spaces break the layout:

```html
<pre><a href=""../../../io/reactivex/annotations/CheckReturnValue.html"" title=""annotation in io.reactivex.annotations"">@CheckReturnValue</a>
 <a href=""../../../io/reactivex/annotations/SchedulerSupport.html"" title=""annotation in io.reactivex.annotations"">@SchedulerSupport</a>(<a href=""../../../io/reactivex/annotations/SchedulerSupport.html#value--"">value</a>=""io.reactivex:computation"")
 <a href=""../../../io/reactivex/annotations/BackpressureSupport.html"" title=""annotation in io.reactivex.annotations"">@BackpressureSupport</a>(<a href=""../../../io/reactivex/annotations/BackpressureSupport.html#value--"">value</a>=<a href=""../../../io/reactivex/annotations/BackpressureKind.html#PASS_THROUGH"">PASS_THROUGH</a>)
public final&nbsp;<a href=""../../../io/reactivex/Flowable.html"" title=""class in io.reactivex"">Flowable</a>&lt;<a href=""../../../io/reactivex/flowables/ConnectableFlowable.html"" title=""type parameter in ConnectableFlowable"">T</a>&gt;&nbsp;refCount(long&nbsp;timeout,
                                                                                                                                                   <a href=""https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html?is-external=true"" title=""class or interface in java.util.concurrent"">TimeUnit</a>&nbsp;unit)</pre>
```

I wonder if it would be possible to avoid those."Found this old post on SO: https://stackoverflow.com/q/30062846/61158 =||= 2.x: Javadoc space cleanup"This PR adds a gradle task to replace the excessive whitespaces generated into the Javadocs between method arguments and after method argument annotations.

This task should run before the javadoc gets packaged up for maven and before it gets pushed back to the gh-pages.

(This was created as a repo branch so that the snapshot pushback is triggered, see the comparison links below.)

Resolves: #6004

#### Comparison

Multiple parameters before: [combineLatest](http://reactivex.io/RxJava/2.x/javadoc/2.1.13/io/reactivex/Flowable.html#combineLatest-io.reactivex.functions.Function-org.reactivestreams.Publisher...-)

![image](https://user-images.githubusercontent.com/1269832/39813943-b841e820-5392-11e8-9a01-8f79b521f76b.png)

Multiple parameters after: [combineLatest snapshot](http://reactivex.io/RxJava/2.x/javadoc/snapshot/io/reactivex/Flowable.html#combineLatest-io.reactivex.functions.Function-org.reactivestreams.Publisher...-)

![image](https://user-images.githubusercontent.com/1269832/39813959-cc80385a-5392-11e8-8084-7ca89c0686d7.png)

----------------

Newline after parameter annotation before: [as](http://reactivex.io/RxJava/2.x/javadoc/2.1.13/io/reactivex/Flowable.html#as-io.reactivex.FlowableConverter-)

![image](https://user-images.githubusercontent.com/1269832/39813894-86bc22c0-5392-11e8-8748-aba6a214d4fc.png)

Newline after parameter annotation after: [as snapshot](http://reactivex.io/RxJava/2.x/javadoc/snapshot/io/reactivex/Flowable.html#as-io.reactivex.FlowableConverter-)

![image](https://user-images.githubusercontent.com/1269832/39813906-97f7aca8-5392-11e8-981f-9ff93396c35f.png)"David Karnokakarnokd05/09/18, 05:13:18 PM
6013.06014Should we have a code check for ObjectHelper.requireNonNull on a primitive?I found a couple small instances of `ObjectHelper.requireNonNull` being used on primitive ints, which I patched in #6012 . Does the Rx codebase have a code pattern checking framework that we could augment to find other potential instances of this that could be causing unnecessary boxing? Errorprone, for example, has this check: https://errorprone.info/bugpattern/PreconditionsCheckNotNullPrimitive for a similar pattern on Guava's `Preconditions.checkNotNull`, so having one for `ObjectHelper` could be potentially useful here.You could create trap overloads that always throw then see if something does crash or shows up as dependency on that method. =||= 2.x: Fix & prevent null checks on primitives"This PR removes the accidental null checks on primitives in two `Observable` methods and adds a trap method to `ObjectHelper` to both highlight and fail the tests in case the null checks are still attempted. The method is marked as deprecated so it will also show up in (Eclipse's) problems window.

Replaces #6012 
Resolves #6013"David Karnokakarnokd05/23/18, 07:23:11 AM
6018.06019Single.takeUntil does not dispose subscription to 'other' upon disposal"Using `Single.takeUntil` does not dispose the subscription it makes to `other` when the main subscription is disposed. RxJava Version: `2.1.13`

#### Sample
```Kotlin
val control = Single.never<Nothing>()
        .doOnSubscribe { println(""Subscribe control"") }
        .doOnDispose { println(""Dispose control"") }
val disposable = Single.never<Nothing>()
        .doOnSubscribe { println(""Subscribe main"") }
        .doOnDispose { println(""Dispose main"") }
        .takeUntil(control)
        .subscribe()
disposable.dispose()
```
prints only:
```
Subscribe control
Subscribe main
Dispose main
```

#### Comparison with Observable
For comparison, `Observable.takeUntil`:
```Kotlin
val control = Observable.never<Nothing>()
        .doOnSubscribe { println(""Subscribe control"") }
        .doOnDispose { println(""Dispose control"") }
val disposable = Observable.never<Nothing>()
        .doOnSubscribe { println(""Subscribe main"") }
        .doOnDispose { println(""Dispose main"") }
        .takeUntil(control)
        .subscribe()
disposable.dispose()
```

prints:
```
Subscribe control
Subscribe main
Dispose main
Dispose control
```""Thanks for reporting. This is indeed a bug with `Single.takeUntil(Single)` and with a bunch of other variants. I'll post a fix shortly. =||= Fix posed in #6019. Since the whole `Single.takeUntil` is bugged, the workaround is to convert both to `Observable` for the duration of the call:

```kotlin
val control = ...

val main = ...

main.toObservable().takeUntil(control.toObservable()).singleOrError()
``` =||= "2.x: Fix Single.takeUntil, Maybe.takeUntil dispose behavior"Fix the dispose behavior of the `Single.takeUntil` and `Maybe.takeUntil` operators.

Tests were also added to the other 3 `takeUntil` variants (for `Completable`, it is delegated to `amb`).

Fixes: #6018"David Karnokakarnokd05/25/18, 10:35:35 AM
6015.06021Single.flatMapPublisher full implementation"I noticed `Single.flatMapPublisher` is implemented as `toFlowable().flatMapPublisher(...)` which subjects the one flowable to batched requests. I'd like to have requests go straight through to the one flowable. Can I contribute this operator?

The operator at the moment is at https://github.com/davidmoten/rxjava2-http/blob/master/src/main/java/org/davidmoten/rx2/io/internal/FlowableSingleFlatMapPublisher.java without fusion. I can add more tests, fusion (transitive as per `doOnEach`) and follow the projects's naming and visibility conventions.""Sure. =||= In case you haven't started yet, you may want to wait for #6017 so the changes can be benchmarked. =||= That's brilliant, thanks =||= A question about fusion. I notice that `timeout(Long, TimeUnit)` doesn't support fusion and I suspect the operator I'm writing is similar. The problem is that a subscription is handed to downstream while the Single emission is being calculated and the resultant mapped Flowable is unknown. Just after the subscription is handed to downstream (via `onSubscribe`) `requestFusion` is called but of course at that point the fusion characteristics of the mapped Flowable is unknown and `QueueFuseable.NONE` is returned. 

Should I chase fusion for this operator? Any suggestions?  =||= Fusion won't work here due to the delayed subscription to the Flowable. Don't bother with it. =||= Righto, ta. =||= "2.x: Single.flatMapPublisher full implementation"See discussion in #6015.

Resolves: #6015"Dave Motendavidmoten05/27/18, 10:14:19 AM
5988.060262.x: Flowable.blockingSubscribe(lambdas) is unbounded and can lead to OOME"I can't remember why, but `Flowable.blockingSubscribe(Consumer,...)` uses unbounded requests, which can lead to `OutOfMemoryError` in both synchronous and asynchronous scenarios.

The problem was raised in [this StackOverflow question](https://stackoverflow.com/questions/50106725/rx-java2-floawable-rebatchrequests-doesnt-rebatch-requests) and apart from the obvious solutions, having such unbounded operator over an asynchronous boundary can be a problem regardless.

Possible resolutions:

- **Behavior change**: bound it to `bufferSize()` in 2.x
- (and/or) Introduce overload(s) with `prefetch` but leave the existing ones unbounded

Alternatively, this could be deferred until 3.x without worrying of the behavior change.""`Flowable.blockingSubscribe(Consumer,…)` is using `Functions.MaxRequestSubscription()` which could lead to `OutOfMemoryError`. Is it the issue?
In that case, I suggest to:
* Keep existing `Flowable.blockingSubscribe(Consumer,…)` unbounded
* Deprecate existing `Flowable.blockingSubscribe(Consumer,…)`
* Introduce new overloads with `bufferSize()` and `prefetch`

WDYT? Can I work on this? =||= Create a new overload:

`blockingSubscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, int bufferSize)`

have a dedicated implementation servicing it and leave the other overloads unbounded. =||= "Fix Flowable.blockingSubscribe is unbounded and can lead to OOME"Create and bound new `blockingSubscribe` overloads to `bufferSize`.
* Create new overloads with `bufferSize`
* Create a `boundedConsumer`
* Create a `BoundedSubsciber`

Close: #5988 "Roman WuattierRomanWuattier06/14/18, 08:04:00 AM
6025.060362.x: error handling - exception swallowed after explicit .dispose()."Library verision : 2.1.7

The following code will silently swallow thrown exception without signalling to RxPlugins. 
```
        val subject = PublishSubject.create<Unit>()

        var disposable: Disposable? = null
        disposable = subject.subscribe(
                {
                    disposable?.dispose()
                    throw Exception(""test"")
                }
        )

        subject.onNext(Unit)
```

The same applies to BehaviourSubject, *Processor, but not SingleSubject or Observable.just (.range etc. ). Though sections about error handling are almost equal in [PublishSubject](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/PublishSubject.html) and [SingleSubject](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/SingleSubject.html).

The reason seems to be located in [LambdaObserver](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/observers/LambdaObserver.java), which doesn't signal onError if is disposed already.

Is it expected behaviour?""Indeed it does not. The tradeoff here is that your code explicitly indicated it doesn't want to handle further events yet there would be no opportunity to have `onError` not signal to the global error handler.

I'm open for discussion. =||= As for me the exception should still be thrown somewhere, as the code is still executed and doing something wrong. So if `.dispose()` is requested and `onError` can not be called - it seems to me that this corresponds 2.x error handling philosophy when the error falls directly into global handler. =||= Well, other implementations do route to the global error handler so for the sake of consistency, this should be fixed. PR welcome. =||= "2.X: Fix disposed LambdaObserver onError to route to global error handler"Fix the behaviour of LambdaObserver when disposed to route to the global error handler

Fixes #6025 "HansHansChua06/09/18, 11:25:55 AM
5980.060522.x: subscribeActual() accidental public"Looks like the following `protected void subscribeActual()` implementations have unintentionally become public:

- [`PublishSubject`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/subjects/PublishSubject.java#L134)
- [`PublishProcessor`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/processors/PublishProcessor.java#L95)

There is no reason to call `subscribeActual` from outside of RxJava, however, making these `protected` counts as a breaking change. However, it should be extremely unlikey somebody was actually using these methods directy.

The question is: do we take the risk and fix the visibility in 2.x or it has to wait for 3.x?

Note that many operators are also having this method as public but those are not really accessible from the outside."In this case I'd consider making the fix with version 2.2 =||= I don't know If this is still relevant, but I opened a PR for it, let me know if it helps =||= #5980 made subscribeActual protected"### Proposal

Changed `subscribeActual` from `public` to `protected`, as described in #5980.

### How I tested

Ran tests locally, please let me know if I missed part of the contributing guidelines 👼 

Fixes: #5980."Marc Bramaudsircelsius06/21/18, 07:22:21 AM
6059.06060[2.1.15] map method called with null"I have something like:

```java
observable.concatMapMaybe(...).map(x -> ...);
```

This `x` is `null` sometimes (our tests reproduce it consistently in one case). Didn't happen on `2.1.14`. I can't give more information for now, just to let you know there is a problem. If you can't figure it out soon, I'll try to create some reproduction.""Version 2.1.15 did not touch any of the operators you listed and without code demonstrating the problem (you say you have a test reliably failing), we can't do much about it. =||= OK, I tried debugging with what I thought the problem might be, no luck so far. Here's a couple of stacktraces in the meantime if you can figure out something from them:

```
NPE in my code as the value is null
        at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59)
        at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.drain(ObservableConcatMapMaybe.java:256)
        at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.innerSuccess(ObservableConcatMapMaybe.java:165)
        at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver$ConcatMapMaybeObserver.onSuccess(ObservableConcatMapMaybe.java:290)
        at io.reactivex.internal.operators.single.SingleFlatMapMaybe$FlatMapMaybeObserver.onSuccess(SingleFlatMapMaybe.java:117)
        at io.reactivex.internal.operators.maybe.MaybeJust.subscribeActual(MaybeJust.java:36)
        at io.reactivex.Maybe.subscribe(Maybe.java:4096)
        at io.reactivex.internal.operators.single.SingleFlatMapMaybe$FlatMapSingleObserver.onSuccess(SingleFlatMapMaybe.java:89)
        at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)
        at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)
        at io.reactivex.internal.operators.single.SingleDoOnSuccess$DoOnSuccess.onSuccess(SingleDoOnSuccess.java:59)
        at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)
        at io.reactivex.internal.operators.observable.ObservableToListSingle$ToListObserver.onComplete(ObservableToListSingle.java:113)
        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:378)
        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:327)
        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.onComplete(ObservableFlatMap.java:304)
        at io.reactivex.internal.observers.BasicFuseableObserver.onComplete(BasicFuseableObserver.java:119)
        at io.reactivex.internal.operators.mixed.SingleFlatMapObservable$FlatMapObserver.onComplete(SingleFlatMapObservable.java:79)
        at io.reactivex.observers.SerializedObserver.onComplete(SerializedObserver.java:181)
        at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.drain(ObservableConcatMap.java:200)
        at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onComplete(ObservableConcatMap.java:146)
        at io.reactivex.internal.operators.observable.ObservableTake$TakeObserver.onComplete(ObservableTake.java:84)
        at io.reactivex.internal.observers.BasicFuseableObserver.onComplete(BasicFuseableObserver.java:119)
        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drainLoop(ObservableFlatMap.java:378)
        at io.reactivex.internal.operators.observable.ObservableFlatMap$MergeObserver.drain(ObservableFlatMap.java:327)
        at io.reactivex.internal.operators.observable.ObservableFlatMap$InnerObserver.onComplete(ObservableFlatMap.java:590)
        at io.reactivex.internal.operators.mixed.SingleFlatMapObservable$FlatMapObserver.onComplete(SingleFlatMapObservable.java:79)
        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onComplete(ObservableCreate.java:98)
my code that calls ObservableEmitter.onComplete
```

```
NPE in my code as the value is null
        at io.reactivex.internal.operators.observable.ObservableMap$MapObserver.onNext(ObservableMap.java:59)
        at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.drain(ObservableConcatMapMaybe.java:256)
        at io.reactivex.internal.operators.mixed.ObservableConcatMapMaybe$ConcatMapMaybeMainObserver.onNext(ObservableConcatMapMaybe.java:124)
        at io.reactivex.observers.SerializedObserver.onNext(SerializedObserver.java:113)
        at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver$InnerObserver.onNext(ObservableConcatMap.java:247)
        at io.reactivex.internal.observers.DeferredScalarDisposable.complete(DeferredScalarDisposable.java:82)
        at io.reactivex.internal.operators.single.SingleToObservable$SingleToObservableObserver.onSuccess(SingleToObservable.java:73)
        at io.reactivex.internal.operators.single.SingleMap$MapSingleObserver.onSuccess(SingleMap.java:64)
        at io.reactivex.internal.operators.single.SingleJust.subscribeActual(SingleJust.java:30)
        at io.reactivex.Single.subscribe(Single.java:3313)
        at io.reactivex.internal.operators.single.SingleMap.subscribeActual(SingleMap.java:34)
        at io.reactivex.Single.subscribe(Single.java:3313)
        at io.reactivex.internal.operators.single.SingleToObservable.subscribeActual(SingleToObservable.java:36)
        at io.reactivex.Observable.subscribe(Observable.java:12036)
        at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.drain(ObservableConcatMap.java:218)
        at io.reactivex.internal.operators.observable.ObservableConcatMap$SourceObserver.onNext(ObservableConcatMap.java:128)
        at io.reactivex.internal.operators.mixed.SingleFlatMapObservable$FlatMapObserver.onNext(SingleFlatMapObservable.java:69)
        at io.reactivex.internal.operators.observable.ObservableCreate$CreateEmitter.onNext(ObservableCreate.java:67)
my code that calls ObservableEmitter.onNext
``` =||= Is dispose/cancel involved in your flows? =||= Well, we do have `dispose` here and there but they're in completely different places in the code. It IS possible that a `dispose` could reach this piece of code but... not sure, it is quite complex. I could try removing all `dispose` calls and checking if that fixes it? =||= I've identified a race condition which can happen when the flow is getting disposed the same time the Maybe succeeds, resulting in a null item being emitted. It would be great if you could check if there is a dispose/cancel happening in your test as well. =||= Can you verify the crash is resolved with the latest snapshot (give it an hour and check https://oss.jfrog.org/libs-snapshot/io/reactivex/rxjava2/rxjava/2.2.0-SNAPSHOT/ for binaries for today)?

```groovy
repositories {
    maven { url 'https://oss.jfrog.org/libs-snapshot' }
}

dependencies {
    compile 'io.reactivex.rxjava2:rxjava:2.2.0-SNAPSHOT'
}
``` =||= Sure, I'll try it out, thanks for the quick response, as always! Its funny how I seem to always be catching some horrible edge-case race conditions like this one and the one before it that you've mentioned in the PR. :D =||= @akarnokd - I can confirm that `2.2.0-SNAPSHOT` of today seemingly fixes the issue (I don't get the exception running our tests). =||= Great. How urgent is for you to have this fix in a release version (next would be in a month)?   =||= Well, I can’t upgrade as this is a big regression in our case so we’ll stay on 2.1.14 until the next release. Not a big deal but releases are free, so why not release a quick patch version? =||= I'd wait a couple of days as most bugs are reported next to a release. 

@vanniktech @artem-zinnatullin @davidmoten would you be fine with 2.1.16 as a patch release next Tuesday? =||= Sure. Releases are free.  =||= "2.x: Fix concatMap{Single|Maybe} null emission on dispose race"This PR fixes a bug in all 4 specialized `concatMap` implementation that allows `null` to be emitted when the success signal of the inner source races with the dispose signal of the sequence.

Likely fixes: #6059"David Karnokakarnokd06/22/18, 01:58:45 PM
6108.06116Gradle build error just as the error info from the part of README"Pls change the read me about the setup library into the project
The reason as below:
Configuration 'compile' is obsolete and has been replaced with 'implementation' and 'api'.
It will be removed at the end of 2018，pls see http://d.android.com/r/tools/update-dependency-configurations.html,
So pls use implementation instead of compile in the correct position...""I don't understand what you are talking about. We have `api` and `implementation` for some time now: https://github.com/ReactiveX/RxJava/blob/2.x/build.gradle#L67 =||= @akarnokd  I mean you should update the readme -about the set up library ,you write like that  compile :"""",you should change it to - implement """",it works well =||= PR welcome. =||= I believe that @MarcSteven is referring to changing the project's README's [""Setting up the dependency""](https://github.com/ReactiveX/RxJava/blob/2.x/README.md#setting-up-the-dependency) section to use `api` or `implementation` instead of `compile`.

I'll open a PR, but I'm not super familiar with the differences between `api` and `implementation`. =||= "6108 changed README to use Gradle's implementation instead of compile"fixes #6108 

Changed `README.md` to reflect Gradle's more recent version of the [library plugin](https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_separation).

I believe that RxJava should be using `implementation`, but I'm not a Gradle expert, feel free to let me know if clients should be using `api`."Marc Bramaudsircelsius07/31/18, 08:14:27 AM
6110.06117README.md: update sentence about Flowable.parallel() after release 2.2"> Alternatively, there is a **beta** operator `Flowable.parallel()` and type `ParallelFlowable` that helps achieve the same parallel processing pattern:

Alternatively, the `Flowable.parallel()` operator and the `ParallelFlowable` type help achieve the same parallel processing pattern:"2.x: Update Readme.md about the parallel() operator"Update wording on the now standard `parallel()` operator in the getting started.

Resolves: #6110"David Karnokakarnokd07/31/18, 08:04:42 AM
6082.06143concatArrayEagerDelayError documented but missing? 2.16"On 2.1.16 it is documented in the [wiki](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#1x-observable-to-2x-flowable) and on [readthedocs](https://rxjava-doc.readthedocs.io/en/latest/What's-different-in-2.0/#1x-observable-to-2x-flowable) that `concatArrayEagerDelayError` is new in RxJava 2 together with:

- [`concatArray`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Observable.java#L1259)
- [`concatArrayDelayError`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Observable.java#L1286)
- [`concatArrayEager`](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Observable.java#L1315)

Those are all there, but `concatArrayEagerDelayError` doesn't seem to be implemented:

```kotlin
Observable.concatArrayEagerDelayError()
```

Am I perhaps missing something?""Looks like `concatArrayEagerDelayError` has not been exposed so far: https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Observable.java#L1341 =||= Yes, I've overlooked that, might've been because I'm on my laptop right now and it's chugging along slowly on those large files on GitHub.

Is the plan to expose this in the future? =||= No plans and there was no feature request for them. It would require 6~8 new methods: 

`{Flowable|Observable}.concatArrayEagerDelayError([tillTheEnd[, maxConcurrency [, prefetch]]], sources...)`

and at least 2 diagrams per base class. =||= I'm up for providing a PR if that's welcome. Thank you in advance for providing me with the methods that would need to be implemented. I haven't dabbled into the RxJava source, but I guess I can figure it out. What would I need to create the diagrams?

Looking at the [tests for concatArrayEager](https://github.com/ReactiveX/RxJava/blob/ab520503925bc9cdff47d6a4ceaf8b2209b61250/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatMapEagerTest.java#L312), and [concatArrayDelayError](https://github.com/ReactiveX/RxJava/blob/ab520503925bc9cdff47d6a4ceaf8b2209b61250/src/test/java/io/reactivex/internal/operators/observable/ObservableConcatTest.java#L779-L796). I assume that I only have to implement the tests like `concatArrayDelay` but for `concatArrayEagerDelayError`. =||= I draw them in Excel but others use OmniGraffle or Inkscape.

You can try making a PR. =||= Small update. I was on holiday and am currently studying for exams for another month so it'll be more than a month till I can get to this unfortunately. =||= I've done it and the necessary marbles in #6143. =||= Too bad for me, I was looking forward to it. :(

Great to have it exposed now though. =||= "2.x: Add concatArrayEagerDelayError operator (expose feature)"This PR exposes the existing `delayError` capability of the `concatMapEager` operator as `concatArrayEagerDelayError` for both `Flowable` and `Observable`.

In addition, the `concatArrayEager` and these new methods receive marble diagrams:

#### Observable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEager.nn.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEagerDelayError.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/concatArrayEagerDelayError.nn.png)

#### Flowable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEager.nn.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatArrayEagerDelayError.nn.png)

Resolves: #6082 

*(Sidenote: one of the validators had to be adjusted due to false positive it produced.)*"David Karnokakarnokd08/07/18, 06:57:13 AM
6144.06145Using publish/share/etc leads to upstream operator running on unexpected scheduler"There appears to be a bug, or at the very least an undocumented and unexpected case,  where `FlowablePublish` causes upstream operators to be applied on the subscription scheduler rather than the upstream observation scheduler (due to `poll`ing). This is reproducible at least in `2.1.x` and `2.2.0`.

#### Sample (Kotlin)
```Kotlin
    val scheduler1 = Schedulers.from(Executors.newSingleThreadExecutor { runnable ->
        Thread(runnable, ""scheduler1"")
    })

    val scheduler2 = Schedulers.from(Executors.newSingleThreadExecutor { runnable ->
        Thread(runnable, ""scheduler2"")
    })

    val flowable: Flowable<Long> = Flowable.interval(1L, TimeUnit.MILLISECONDS)
            .onBackpressureLatest()
            .take(10_000)
            .observeOn(scheduler1)
            .map {
                val threadName = Thread.currentThread().name
                if (threadName != ""scheduler1"") {
                    throw AssertionError(""Wrong thread: $threadName"")
                }
                it
            }
            .share()

    flowable
            .observeOn(scheduler2)
            .doOnNext { Thread.sleep(10L) }
            .subscribe {
                println(""onNext on ${Thread.currentThread().name}: $it"")
            }
```

#### Expected Behavior
It should be expected that the `.map` operator is applied on the `scheduler1` scheduler since it is the scheduler supplied to `observeOn` immediately upstream.

#### Actual Behavior
After about ~100 emissions, the `map` operator is applied on the `scheduler2` scheduler. I'm not an expert in the details, but it seems to have something to do with backpressure, buffering, and polling for items upon subscription?

#### Output
```
onNext on scheduler2: 0
onNext on scheduler2: 1
onNext on scheduler2: 2
onNext on scheduler2: 3
onNext on scheduler2: 4
onNext on scheduler2: 5
onNext on scheduler2: 6
onNext on scheduler2: 7
onNext on scheduler2: 8
onNext on scheduler2: 9
onNext on scheduler2: 10
onNext on scheduler2: 11
onNext on scheduler2: 12
onNext on scheduler2: 13
onNext on scheduler2: 14
onNext on scheduler2: 15
onNext on scheduler2: 16
onNext on scheduler2: 17
onNext on scheduler2: 18
onNext on scheduler2: 19
onNext on scheduler2: 20
onNext on scheduler2: 21
onNext on scheduler2: 22
onNext on scheduler2: 23
onNext on scheduler2: 24
onNext on scheduler2: 25
onNext on scheduler2: 26
onNext on scheduler2: 27
onNext on scheduler2: 28
onNext on scheduler2: 29
onNext on scheduler2: 30
onNext on scheduler2: 31
onNext on scheduler2: 32
onNext on scheduler2: 33
onNext on scheduler2: 34
onNext on scheduler2: 35
onNext on scheduler2: 36
onNext on scheduler2: 37
onNext on scheduler2: 38
onNext on scheduler2: 39
onNext on scheduler2: 40
onNext on scheduler2: 41
onNext on scheduler2: 42
onNext on scheduler2: 43
onNext on scheduler2: 44
onNext on scheduler2: 45
onNext on scheduler2: 46
onNext on scheduler2: 47
onNext on scheduler2: 48
onNext on scheduler2: 49
onNext on scheduler2: 50
onNext on scheduler2: 51
onNext on scheduler2: 52
onNext on scheduler2: 53
onNext on scheduler2: 54
onNext on scheduler2: 55
onNext on scheduler2: 56
onNext on scheduler2: 57
onNext on scheduler2: 58
onNext on scheduler2: 59
onNext on scheduler2: 60
onNext on scheduler2: 61
onNext on scheduler2: 62
onNext on scheduler2: 63
onNext on scheduler2: 64
onNext on scheduler2: 65
onNext on scheduler2: 66
onNext on scheduler2: 67
onNext on scheduler2: 68
onNext on scheduler2: 69
onNext on scheduler2: 70
onNext on scheduler2: 71
onNext on scheduler2: 72
onNext on scheduler2: 73
onNext on scheduler2: 74
onNext on scheduler2: 75
onNext on scheduler2: 76
onNext on scheduler2: 77
onNext on scheduler2: 78
onNext on scheduler2: 79
onNext on scheduler2: 80
onNext on scheduler2: 81
onNext on scheduler2: 82
onNext on scheduler2: 83
onNext on scheduler2: 84
onNext on scheduler2: 85
onNext on scheduler2: 86
onNext on scheduler2: 87
onNext on scheduler2: 88
onNext on scheduler2: 89
onNext on scheduler2: 90
onNext on scheduler2: 91
onNext on scheduler2: 92
onNext on scheduler2: 93
onNext on scheduler2: 94
onNext on scheduler2: 95
io.reactivex.exceptions.OnErrorNotImplementedException: Wrong thread: scheduler2
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704)
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701)
	at io.reactivex.internal.subscribers.LambdaSubscriber.onError(LambdaSubscriber.java:79)
	at io.reactivex.internal.operators.flowable.FlowableDoOnEach$DoOnEachSubscriber.onError(FlowableDoOnEach.java:111)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated(FlowableObserveOn.java:207)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:392)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:176)
	at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)
	at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.AssertionError: Wrong thread: scheduler2
	at RxTestKt$main$flowable$1.apply(RxTest.kt:22)
	at RxTestKt$main$flowable$1.apply(RxTest.kt)
	at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.poll(FlowableMap.java:81)
	at io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.dispatch(FlowablePublish.java:510)
	at io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.request(FlowablePublish.java:615)
	at io.reactivex.internal.operators.flowable.FlowableRefCount$RefCountSubscriber.request(FlowableRefCount.java:216)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:407)
	... 6 more
Exception in thread ""scheduler2"" io.reactivex.exceptions.OnErrorNotImplementedException: Wrong thread: scheduler2
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704)
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701)
	at io.reactivex.internal.subscribers.LambdaSubscriber.onError(LambdaSubscriber.java:79)
	at io.reactivex.internal.operators.flowable.FlowableDoOnEach$DoOnEachSubscriber.onError(FlowableDoOnEach.java:111)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated(FlowableObserveOn.java:207)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:392)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:176)
	at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)
	at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.AssertionError: Wrong thread: scheduler2
	at RxTestKt$main$flowable$1.apply(RxTest.kt:22)
	at RxTestKt$main$flowable$1.apply(RxTest.kt)
	at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.poll(FlowableMap.java:81)
	at io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.dispatch(FlowablePublish.java:510)
	at io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.request(FlowablePublish.java:615)
	at io.reactivex.internal.operators.flowable.FlowableRefCount$RefCountSubscriber.request(FlowableRefCount.java:216)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:407)
	... 6 more
```""This a bug due to operator fusion breaking the thread-confinement expected after `observeOn`. You can work around it by applying `hide()` before `share()`. I'll post a fix shortly. =||= @akarnokd I've noticed that `.hide()` does not always solve the problem - adding a second `map` (and/or probably other operators) after the `share` causes the problem to reappear:
```Kotlin
    val scheduler1 = Schedulers.from(Executors.newSingleThreadExecutor { runnable ->
        Thread(runnable, ""scheduler1"")
    })

    val scheduler2 = Schedulers.from(Executors.newSingleThreadExecutor { runnable ->
        Thread(runnable, ""scheduler2"")
    })

    val flowable: Flowable<Long> = Flowable.interval(1L, TimeUnit.MILLISECONDS)
            .onBackpressureLatest()
            .take(10_000)
            .observeOn(scheduler1)
            .map {
                val threadName = Thread.currentThread().name
                if (threadName != ""scheduler1"") {
                    throw AssertionError(""Wrong thread on map #1: $threadName"")
                }
                it
            }
            .hide()
            .share()
            .map {
                val threadName = Thread.currentThread().name
                if (threadName != ""scheduler1"") {
                    throw AssertionError(""Wrong thread on map #2: $threadName"")
                }
                it
            }

    flowable
            .observeOn(scheduler2)
            .doOnNext { Thread.sleep(10L) }
            .subscribe {
                println(""onNext on ${Thread.currentThread().name}: $it"")
            }
```

Output:
```
onNext on scheduler2: 0
onNext on scheduler2: 1
...
onNext on scheduler2: 94
onNext on scheduler2: 95
io.reactivex.exceptions.OnErrorNotImplementedException: Wrong thread on map #2: scheduler2
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704)
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701)
	at io.reactivex.internal.subscribers.LambdaSubscriber.onError(LambdaSubscriber.java:79)
	at io.reactivex.internal.operators.flowable.FlowableDoOnEach$DoOnEachSubscriber.onError(FlowableDoOnEach.java:111)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated(FlowableObserveOn.java:207)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:392)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:176)
	at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)
	at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.AssertionError: Wrong thread on map #2: scheduler2
	at RxTestKt$main$flowable$2.apply(RxTest.kt:31)
	at RxTestKt$main$flowable$2.apply(RxTest.kt)
	at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.onNext(FlowableMap.java:64)
	at io.reactivex.internal.operators.flowable.FlowableRefCount$RefCountSubscriber.onNext(FlowableRefCount.java:193)
	at io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.dispatch(FlowablePublish.java:545)
	at io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.request(FlowablePublish.java:615)
	at io.reactivex.internal.operators.flowable.FlowableRefCount$RefCountSubscriber.request(FlowableRefCount.java:216)
	at io.reactivex.internal.subscribers.BasicFuseableSubscriber.request(BasicFuseableSubscriber.java:153)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:407)
	... 6 more
Exception in thread ""scheduler2"" io.reactivex.exceptions.OnErrorNotImplementedException: Wrong thread on map #2: scheduler2
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:704)
	at io.reactivex.internal.functions.Functions$OnErrorMissingConsumer.accept(Functions.java:701)
	at io.reactivex.internal.subscribers.LambdaSubscriber.onError(LambdaSubscriber.java:79)
	at io.reactivex.internal.operators.flowable.FlowableDoOnEach$DoOnEachSubscriber.onError(FlowableDoOnEach.java:111)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated(FlowableObserveOn.java:207)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:392)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run(FlowableObserveOn.java:176)
	at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker$BooleanRunnable.run(ExecutorScheduler.java:261)
	at io.reactivex.internal.schedulers.ExecutorScheduler$ExecutorWorker.run(ExecutorScheduler.java:226)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.AssertionError: Wrong thread on map #2: scheduler2
	at RxTestKt$main$flowable$2.apply(RxTest.kt:31)
	at RxTestKt$main$flowable$2.apply(RxTest.kt)
	at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.onNext(FlowableMap.java:64)
	at io.reactivex.internal.operators.flowable.FlowableRefCount$RefCountSubscriber.onNext(FlowableRefCount.java:193)
	at io.reactivex.internal.operators.flowable.FlowablePublish$PublishSubscriber.dispatch(FlowablePublish.java:545)
	at io.reactivex.internal.operators.flowable.FlowablePublish$InnerSubscriber.request(FlowablePublish.java:615)
	at io.reactivex.internal.operators.flowable.FlowableRefCount$RefCountSubscriber.request(FlowableRefCount.java:216)
	at io.reactivex.internal.subscribers.BasicFuseableSubscriber.request(BasicFuseableSubscriber.java:153)
	at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync(FlowableObserveOn.java:407)
	... 6 more
```

I have two questions about this:
1. Does #6145 also fix this situation?
2. Is there any alternative workaround that can also fix this situation? =||= > Does #6145 also fix this situation?

No, this is a different effect. Due to backpressure and buffering, the `publish` may service its consumer on a different thread than the generator upstream to it. 

> Is there any alternative workaround that can also fix this situation?

If you want that `map` to execute on the desired thread, you have to apply `observeOn(scheduler1)` before it. =||= Thanks for the reply, @akarnokd. That makes sense - I will keep that in mind. Are there any existing mechanisms that allow something like `publish` to preserve the observation scheduling? =||= No. It is an async boudary in which case all bets are off. You have to ensure the proper thread via observeOn. =||= "2.x: Fix boundary fusion of concatMap and publish operator"This PR fixes the lack of boundary fusion marker in the `concatMap` and `publish` operators that can break the thread-confinement expectation when using `observeOn` upstream and a thread-sensitive operator:

```java
source.observeOn(scheduler)
    .map(/* some thread-sensitive operation */)
    .publish() // or concatMap
```

By default, these operators may call `poll` from any of the participating threads which would otherwise dequeue `observeOn` and execute `map` on that thread.

The fix adds the necessary flag to both operator's `onSubscribe` logic. For a temporary workaround, one should use `hide()` before such operators to make sure fusion doesn't happen.

Fixes: #6144"David Karnokakarnokd08/08/18, 07:42:26 AM
6151.06152`BaseTestConsumer#assertValueSet` doesn't verify that all listed values were received"[`BaseTestConsumer#assertValueSet`](https://github.com/ReactiveX/RxJava/blob/e8930c2830869f1089ac7627dda044e8d861fb6b/src/main/java/io/reactivex/observers/BaseTestConsumer.java#L567) is documented and implemented as:

```java
/**
 * Assert that the TestObserver/TestSubscriber received only the specified values in any order.
 * <p>This helps asserting when the order of the values is not guaranteed, i.e., when merging
 * asynchronous streams.
 *
 * @param expected the collection of values expected in any order
 * @return this
 */
@SuppressWarnings(""unchecked"")
public final U assertValueSet(Collection<? extends T> expected) {
    if (expected.isEmpty()) {
        assertNoValues();
        return (U)this;
    }
    for (T v : this.values) {
        if (!expected.contains(v)) {
            throw fail(""Value not in the expected collection: "" + valueAndClass(v));
        }
    }
    return (U)this;
}
```

Within our team we have several tests using `assertValueSet`, each attempting to assert that _all_ of the listed values are emitted. Today we found out that `assertValueSet` verifies a weaker condition, namely that no ""unexpected"" values are emitted. It does not verify that all listed values are emitted. This took us by surprise. If this is the intended behaviour, perhaps the documentation could be clarified on this point.

NB: the RxJava code base itself contains several tests using `assertValueSet`. Some of these also seem to assume the stronger interpretation (e.g. `FlowableFlatMapSingleTest#normalAsync`), while others would surely fail under the stronger semantics (e.g.`FlowableFlatMapSingleTest#takeAsync`).

NB2: I do observe that (nearly?) all tests in the RxJava code base invoking `assertValueSet` involve some form of nondeterminism, and a benefit of the current weaker semantics is that these tests are now less likely to fail on a system under heavy load. Still, as-is `assertValueSet` also passes if _no_ values are emitted; surely these tests wish to assert something more definitive?"It is meant to assert received values are all in the collection. You can make a stronger assumption by adding assertValueCount. =||= 2.x: Clarify TestObserver.assertValueSet in docs and via tests"Clarify that `{TestObserver|TestSubscriber}.assertValueSet` checks for all received items to be in the provided set, but that set can contain additional elements that could have been received. Unit tests have been added to demonstrate the expected behavior.

Resolves: #6151."David Karnokakarnokd08/10/18, 08:15:22 AM
6156.061582.x: Why ObservableFromCallable logic differs from  FlowableFromCallable when error occurs"Currently I see source codes RxJava 2.2.0
```
        try {
            value = ObjectHelper.requireNonNull(callable.call(), ""Callable returned null"");
        } catch (Throwable e) {
            Exceptions.throwIfFatal(e);
            if (!d.isDisposed()) {
                s.onError(e);
            } else {
                RxJavaPlugins.onError(e);
            }
            return;
        }
```
In ObserableFromCallable, if error ocurrs and alreadly disposed, common error handler is used..
But FlowableFromCallable, this logic differs. 
```
        try {
            t = ObjectHelper.requireNonNull(callable.call(), ""The callable returned a null value"");
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            s.onError(ex);
            return;
        }
```
In my opinion,  it seems that there lacks consistency, but are there reasons?

"Probably just an inconsistency left behind from the early days. PR welcome. =||= 2.x: Make Flowable.fromCallable consistent with the other fromCallables"`Flowable.fromCallable` is one of [the oldest](https://github.com/ReactiveX/RxJava/commits/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowableFromCallable.java) 2.x operators and was overlooked when the handling of beyond-cancellation error delivery, aka the undeliverable exception handling was implemented across RxJava. This PR resolves this shortcoming by making it consistent with its sibling implementations.

Resolves: #6156"David Karnokakarnokd08/14/18, 12:53:55 PM
6173.061742.x: The RxJavaPlugins JavaDocs HTML should be auto-cleaned up"Some method entries of the `RxJavaPlugins` JavaDocs HTML looks misaligned, just like some other components used to:

![image](https://user-images.githubusercontent.com/1269832/44617428-50c2b880-a862-11e8-8161-59d9ae051ffc.png)

The fix is trivial: add the respective file, `plugins/RxJavaPlugins.html` to the gradle code:

https://github.com/ReactiveX/RxJava/blob/2.x/gradle/javadoc_cleanup.gradle#L13

You can verify the outcome by running `./gradlew clean javadocCleanup` and checking the respective file in your browser.

(Note that probably there is no way to fix the long signature displays, only those unnecessary newlines)."Auto-clean up RxJavaPlugins JavaDocs HTML (#6173)"Add 'plugins/RxJavaPlugins.html' to the javadocCleanup task in javadoc_cleanup.gradle. 

Resolves: #6173 "Aaron Friedmanajsf08/26/18, 08:42:57 AM
6185.06187Possible concurrency issue with .refCount()? (2.2.0)"First, I want to thank you for this wonderful library which I gladly use in many professional applications!

While I was writing a component for one of our company applications, I wrote a multithreaded stress test, because the component itself introduces shared state. Sometimes the test failed. Of course, I suspected my component to be the culprit. After further investigation I could completely rule out my own component and still reproduce the problem. 
I think there could be a problem with the `refCount()` operator.

Less words, more code:

The problem is reproducible with the following unit test (well, at least as reproducible as a test in a multithreaded manner can be...)

```
public void replayRefCountShallBeThreadSafe() {
        for (int i = 0; i < 10000; i++) {
            Observable<Object> observable = Observable.just(new Object()).replay(1).refCount();

            TestObserver<Object> observer1 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestObserver<Object> observer2 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            assertThat(observer1.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));
            assertThat(observer2.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));
        }
}
```

As you can see, I am repeating the logic 10000 times. This (mostly) guarantees that the test fails on my environment. One of the observers does NOT receive the completed event and therefore the `awaitTerminalEvent` times out.

On the other hand, the following unit test where I manually `.connect()` the `ConnectableObservable`  returned vom `.replay(1)` passes:

```
public void replayShallBeThreadSafe() {
        for (int i = 0; i < 10000; i++) {
            ConnectableObservable<Object> observable = Observable.just(new Object()).replay(1);
            Disposable connection = observable.connect();

            TestObserver<Object> observer1 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            TestObserver<Object> observer2 = observable
                    .subscribeOn(Schedulers.io())
                    .test();

            assertThat(observer1.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));
            assertThat(observer2.awaitTerminalEvent(5, TimeUnit.SECONDS), is(true));
            connection.dispose();
        }
}
```

Please tell me if I am missing something...

Version: RxJava 2.2.0
Tests are JUnit tests, with hamcrest assertions.

Thanks!
""Thanks for reporting. It does seem like a reconnection race as one observer goes out while another comes in. Also present in the `Flowable` version. I'll post a fix shortly. =||= Wow, that is what I call a fast response! :)
I am looking forward to the fix, thank you. 
If I can be of any help, just tell me. =||= "2.x: Fix refCount termination-reconnect race"This PR modifies the `refCount` operator (in both `Flowable` and `Observable` types) to avoid certain termination-reconnection races.

The original race could happen when the refCounted source terminated at the same time as new observers arrived, leaving those new observers hanging as they practically joined a dying connection and got possibly undercut by the `dispose` call.

The change involve a new internal interface `ResettableConnection` that will allow resetting the connection object inside the connectable source if it is equal to the connection object known by the initiator of the original `connect` call.

Fixes #6185 "David Karnokakarnokd08/30/18, 01:29:59 PM
6179.06193"Add an ""Error handling"" JavaDocs section to fromCallable & co""The operators of `fromCallable`, `fromAction` and `fromRunnable` in the reactive classes could use an `<dt><b>Error handling:</b></dt>` section in the JavaDocs describing the regular and canceled/disposed behavior.

> If the `{@link Callable/Action/Runnable}` throws an exception/exception/unchecked exception, the respective `{@link Throwable}` is delivered to the downstream via `{@link Subscriber/Observer/.../#onError()}`, except when the downstream has canceled/disposed this `{@code Flowable/Observable/Single/Maybe/Completable}` source. In this latter case, the Throwable is delivered to the global error handler via `{@link RxJavaPlugins#onError(Throwable)}` as `{@link io.reactivex.exceptions.UndeliverableException UndeliverableException}`.""Add ""error handling"" java docs section to from callable & co""Resolves #6179

Added JavaDocs describing the regular and canceled/disposed behavior for

- `Observable.fromCallable()`
- `Single.fromCallable()`
- `Maybe.fromAction()`
- `Completable.fromCallable()`
- `Completable.fromAction()`
- `Flowable.fromCallable()`

Did not alter `Maybe.fromCallable()` because the existing JavaDoc appears to be adequate."Luis Cortesluis-cortes09/03/18, 12:33:37 PM
6195.06197Flowable.reduce(BiFunction) does not signal NoSuchElementException"The JavaDocs of `Flowable.reduce(BiFunction)` incorrectly mentions that an empty source results in a `NoSuchElementException`. It returns a `Maybe` thus an empty source will result in an empty `Maybe`. The `Observable.reduce(BiFunction)` counterpart has the correct text.

The ""If the source is empty, a NoSuchElementException is signaled."" should be removed."#6195 Fix Flowable.reduce(BiFunction) JavaDoc"Empty source does not signal NoSuchElementException.

Resolves #6195 "Yannick Lecaillezylecaillez09/03/18, 12:05:59 PM
6196.06199Fix terminology of cancel/dispose in the JavaDocs"`Flowable`s can be **canceled** and the other reactive types can be **disposed**. Change the JavaDocs of these latter types accordingly (via careful find/replace):

- [ ] Observable
- [ ] Single
- [ ] Maybe
- [ ] Completable

(Note: `Flowable` is okay)."Fix terminology of cancel/dispose in the JavaDocs"Resolves #6196

Changing terminology from cancel -> dispose wherever appropriate in the following classes:

- `Observable.java`
- `Single.java`
- `Maybe.java`
- `Completable.java`

Areas where I did _not_ change from cancel -> disposal include: 

- where the cancellation was in reference to a `Flowable`, `Publisher`, or a `Future`
- `test()` methods where the `TestObserver` returned actually has a `cancel()` method"Luis Cortesluis-cortes09/04/18, 04:08:07 PM
6198.06200toFuture incorrect diagram/description"Both `Flowable.toFuture` and `Observable.toFuture` describes the wrong behavior: If the source has more than one element, the outcome is actually `IndexOutOfBoundsException`.

In addition, the docs should mention the source has to terminate in order for the `Future` to terminate.

Plus, the [marble](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html#toFuture--) should be updated to reflect the actual behavior (there is no dispose upon the first received item).

![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png)"2.x: Fix toFuture marbles and descriptions"This PR fixes the marble diagrams of `Flowable.toFuture` and `Observable.toFuture` to indicate:

- multi-valued sources signal `IndexOutOfBoundsException`
- Source has to be finite for the `Future` to terminate.

![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/Flowable.toFuture.png)
![image](https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/toFuture.o.png)


Resolves #6198

(also fixes the diagram for #5813)."David Karnokakarnokd09/04/18, 08:28:24 AM
6231.06232Value always true"RxJava/src/main/java/io/reactivex/internal/operators/observable/ObservableFlatMap.java

**Class:** ObservableFlatMap.java
**Line:** 450
**Statement:** if (o == null) {
**Problem:** o is always null, suggest removing the if statement and just leaving break."2.x: Cleanup Observable.flatMap drain logic"Cleanup the drain logic of `Observable.flatMap` by removing unnecessary loops and fixing the index management in case of a fused failure in one of the sources triggering another round over the same source unnecessarily.

Resolves: #6231"David Karnokakarnokd09/30/18, 09:38:07 AM
6239.06241What's-different docs reference non-existent class: io.reactivex.functions.Functions"The documentation below references a utility class, `io.reactivex.functions.Functions`, but it appears that is now `io.reactivex.internal.functions.Functions`, which I assume should not be used by third parties. Is there a public equivalent?

https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#functions"That's a mistake in the docs and we don't offer any public utilities for them.  If you need something from the internal `Functions`, they can be trivially recreated outside RxJava. =||= 2.x Wiki: Remove mention of i.r.f.Functions"The `io.reactivex.functions.Functions` utility method has been made internal a long ago and should not be mentioned.

Resolves: #6239"David Karnokakarnokd10/09/18, 01:01:05 PM
6253.06254Flaky test/operator: FlowableSampleTest backpressureOverflowWithOtherPublisher"```
io.reactivex.internal.operators.flowable.FlowableSampleTest > backpressureOverflowWithOtherPublisher FAILED
    java.lang.AssertionError: No errors (latch = 0, values = 0, errors = 0, completions = 1)
        at io.reactivex.observers.BaseTestConsumer.fail(BaseTestConsumer.java:189)
        at io.reactivex.observers.BaseTestConsumer.assertError(BaseTestConsumer.java:318)
        at io.reactivex.observers.BaseTestConsumer.assertError(BaseTestConsumer.java:303)
        at io.reactivex.observers.BaseTestConsumer.assertFailure(BaseTestConsumer.java:811)
        at io.reactivex.internal.operators.flowable.FlowableSampleTest.backpressureOverflowWithOtherPublisher(FlowableSampleTest.java:313)
```"2.x: Fix flaky sample() backpressure test, improve coverage"Use processors to trigger the `MissingBackpressureException` case instead of the timer, which could fire prematurely and stop the sequence before the first item was sent by the `BehaviorProcessor`.

Also small improvements to the code coverage of `FlowableSample`.

Fixes #6253. "David Karnokakarnokd10/19/18, 10:26:01 AM
6259.06258concatMap() invokes inner.cancel() after inner has signaled onComplete()"Reproduced with RxJava version: 2.1.9 and 2.2.3.

```java
Flowable.just(Boolean.TRUE)
        .repeat()
        .concatMap(token -> Flowable.just(""foo"").doOnCancel(() -> System.out.println(""Cancelled"")))
        .subscribe();
```

Expected behavior: ""Cancelled"" should not appear on the console
Current behavior: ""Cancelled"" is printed as a result of cancel invocation.

Note that `flatMap(token -> ..., 1)`  don't have this issue but it is significantly slower than `concatMap()`"See #6258. =||= 2.x: Fix cancel/dispose upon upstream switch for some operators"This PR extends the `SubscriptionArbiter` to optionally allow or disallow cancelling the current `Subscription` if it is replaced by a new one. Some operators do not need to cancel the current `Subscription`: `concat`, `concatMap`, `repeat`, `repeatWhen`, `retry` and `retryWhen`. 

In addition `repeatWhen` and `retryWhen` were cancelling when the handler sequence itself terminated. The code has been updated to disconnect the upstream upon the completion/failure but before signaling the handler.

The Reactive Streams specification also disallows synchronous cancellation after the terminal event anyway.

Others may actually need to cancel, such as `Timeout`. 

`Observable`s don't have a specific arbiter, they use the `DisposableHelper` methods and the relevant ones were changed to `replace()` instead of the disposing `set` call.

Some tests actually checking if the dispose/cancel happens and had to be updated.

The `Flowable.delaySubscription(Publisher)` also used `SubscriptionArbiter` but it was unnecessary. The code has been replaced with a more apt deferred requesting scheme as the downstream requests need to be delayed until the main subscription happens, the other publisher is always consumed unbounded.

Resolves: #6259"David Karnokakarnokd10/27/18, 09:08:09 PM
6226.06260Wiki: Add generate() examples to Creating-Observables.md"Wiki target:

https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md

See JavaDocs:

http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#generate-io.reactivex.functions.Consumer- +subsequent overloads

Related: #6132"Add generate examples to Creating-Observables.md in Wiki"Add documentation and example to the wiki for generate. 

Resolves: #6226"Elijah Verdoornelijahverdoorn10/26/18, 07:32:27 AM
6268.062692.x: firstOrError call on dispose twice"In  RxJava (2.2.2) if I use the next code the `onDispose` callback is called twice. I have already changed the code to not use this approach bc the `s.onNext` inside the subscribe is pretty obscure, but I report it just in case this can affect more cases. Looks like firstOrError (actually ObservableElementAtSingle) can call upstream cancelation twice.

Code that produces the problem:
```java
BehaviorSubject<Integer> s = BehaviorSubject.create();
s.doOnLifecycle(d -> out.println(""subscribe""), () -> { out.println(""dispose""); s.onNext(2); })
        .firstOrError().subscribe().dispose();
```
Console output:
```
subscribe
dispose
dispose
```"This is kind of an awkward reentrance problem. I'll have to investigate which components need to suppress dispose calls. =||= 2.x: Call the doOn{Dispose|Cancel} handler at most once"This PR makes sure the `doOnDispose`, `doOnCancel` and `doOnLifecycle` execute their cancellation handler once.

Resolves: #6268."David Karnokakarnokd10/29/18, 05:17:14 PM
6270.06275Rewrite Observable.cache() & Flowable.cache()"The current implementations of `Observable.cache()` & `Flowable.cache()` look old and have several problems:

- They dispose the upstream when they terminate, which shouldn't happen.
- They have an extra indirection for their state but not sure why. Probably a structuring remnant from 1.x.
- The general drain logic seem to use too many variables.

PR welcome.
"2.x: Improve the Observable/Flowable cache() operators"This PR rewrites the `Observable.cache` and `Flowable.cache` operators to allocate less and be more up-to-date algorithmically.

I've also added comments to help understand its inner workings in case someone is interested.

Resolves: #6270"David Karnokakarnokd11/01/18, 06:31:31 AM
6272.06278Have materialize() and dematerialize() for Maybe, Single and Completable?"`Observable` and `Flowable` already have these methods, it might be worth adding them to `Maybe`, `Single` and `Completable`.

The main benefit I see with `Maybe` and `Single` is for the `zip` operator which now could wait for all source outcomes and the `zipper` will be always invoked.

Note that `Completable.materialize()` would become `Single<Notification<T>>` as well. `T` could be `Void` or an arbitrary target type:

```java
Single<Notification<Void>> c = Completable.complete().<Void>materialize();
Single<Notification<Integer>> s = Single.just(1).materialize();
Single<Notification<Integer>> m = Maybe.<Integer>empty().materialize();

Single.zip(c, s, m, (a, b, c) -> 1);
```" 2.x: Add materialize() and dematerialize()"This PR adds the `materialize` operator to `Maybe`, `Single` and `Completable` to turn their signals into the corresponding `Notification` object. This operator has been available for `Observable`s (and `Flowable`s) from the beginning of the Rx API. The methods return `Single<Notification<T>>`.

To complement, the `dematerialize` operator is only defined for `Single` and results in a `Maybe`.

If accepted, I'll draw the correct marble diagrams for them in a separate PR.

Resolves: #6272"David Karnokakarnokd11/06/18, 07:57:06 AM
6282.06283flatMap concurrency decrease in case of simultaneous finishing in the child observables"RxJava 2.2.3

Following code reproduces the problem:

```java
public class TestObs {

    static public void main(String[] args) {

        AtomicInteger count = new AtomicInteger();

        Scheduler scheduler = Schedulers.from(Executors.newCachedThreadPool());
        Observable.range(0, 400)
                .flatMap(i -> Observable.just(i).subscribeOn(scheduler).map(x -> {
                     System.out.println(""Start "" + Thread.currentThread().getName()
                        + "" "" + x + "" concurrent "" + count.incrementAndGet());
                     Thread.sleep(1000);
                     System.out.println(""End "" + Thread.currentThread().getName()
                        + "" "" + x + "" concurrent "" + count.decrementAndGet());

                     return x;
                  }),
                  30
                ).ignoreElements().blockingGet();
    }
}
```

At the end you will see that only 1 child will be executed concurrently. At the beginning it is 30. 

It is about flatMap operator with concurrency argument. In the case if you use concurrency Integer.MAX_VALUE with fixed pool is everything ok. 
The problem happens in the case if more than one inner process are done in the same drainLoop. 
I think it is here (io.reactivex.internal.operators.observable.ObservableFlatMap 448)

```java
                        SimpleQueue<U> innerQueue = is.queue;
                        if (innerDone && (innerQueue == null || innerQueue.isEmpty())) {
                            removeInner(is);
                            if (checkTerminate()) {
                                return;
                            }
                            innerCompleted = true;
                        }
```
More then one will be removed, but innerCompleted pulls only one as replacement (io.reactivex.internal.operators.observable.ObservableFlatMap 468) 

"Thanks for reporting. This is indeed a bug in the operator which should try to sustain the concurrency level as best as it can. I'll post a fix shortly. =||= 2.x: Fix Observable.flatMap to sustain concurrency level"If the `Observable.flatMap` operator run in limited concurrency mode and multiple sources completed at the same time while the operator was in its drain loop, the operator only started with one new inner source instead of trying to run replace all the completed inner sources with new ones.

The solution is to count the completed sources and replenish them in a loop.

*(The `Flowable` variant works properly because it uses backpressure and inner source counting already to replenish those completed inner sources. The `Observable` doesn't have backpressure so it has to emulate it via the work-in-progress counting and the secondary queue for available inner sources.)*

Fixes: #6282"David Karnokakarnokd11/05/18, 10:34:15 AM
6279.06287Expose the Keep-Alive value of the IO Scheduler as System property."Currently, the Keep-Alive is 60 seconds constant: [IoScheduler.java#L37](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java#L37). 

The configuration could be done via `Integer.getInteger()` similar to how `priority` is configurable: [L52](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/schedulers/IoScheduler.java#L52).

The documentation of [Schedulers.java#L32](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/schedulers/Schedulers.java#L32) and [Schedulers.java#L158](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/schedulers/Schedulers.java#L158) should also describe this option."2.x: Expose the Keep-Alive value of the IO Scheduler as System property. (#6279)"Configuring Keep-Alive through System property.

Resolves: #6279"Paweł Łozińskipawellozinski11/05/18, 12:41:01 PM
6296.062972.x: refCount doesn't reset its source if one of its subscribers cancels immediately"The following tests fail because the cancel/dispose from the downstream comes before the actual connection is established which leaves the connectable source in a disposed state, refusing to take in new subscribers/observers:

```java
@Test
public void test() {
    BehaviorSubject<Integer> subject = BehaviorSubject.create();

    Observable<Integer> observable = subject
            .replay(1)
            .refCount();

    observable.takeUntil(Observable.just(1)).test();

    subject.onNext(2);

    observable.take(1).test().assertResult(2);
}


@Test
public void test2() {
    BehaviorProcessor<Integer> processor = BehaviorProcessor.create();

    Flowable<Integer> flowable = processor
            .replay(1)
            .refCount();

    // This line causes the test to fail.
    flowable.takeUntil(Flowable.just(1)).test();

    processor.onNext(2);

    flowable.take(1).test().assertResult(2);
}
```""Thanks for letting us know. Was this discovery prompted by a report or a flash of realization? =||= @davidmoten This was a bug we found during development. Our actual use case was more complicated but this is what it simplified to.
@akarnokd Thanks for the quick response! =||= It is from a StackOverflow question: https://stackoverflow.com/questions/53216329/refcount-observable-does-not-emit-on-second-subscription =||= +1 to @davidmoten 's comment, this is how open source projects should tackle bugs

👍 @akarnokd  =||= Fix posted in #6297. =||= "2.x: Fix refCount eager disconnect not resetting the connection"This PR fixes the case when an observer/subscriber disposes/cancels immediately upon subscribing to a `refCount` operator before it establishes the connection and ends up with a disposed but non-reset connection, preventing further interactions with the connectable source.

The fix is to detect this case and reset the connection when the `connect()` method signals the dispose handler.

Both `ConnectableFlowable.refCount` and `ConnectableFlowable.refCount` is affected.

Fixes: #6296"David Karnokakarnokd11/12/18, 09:26:15 AM
6302.06303Javadoc: Flowable::zipWith image is displayed incorrectly"There is a small problem with the images in the current Javadoc (2.2.3) of the following operators:

- [`Flowable::zipWith(Publisher, BiFunction)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#zipWith-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-)
- [`Flowable::zipWith(Publisher, BiFunction, boolean)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#zipWith-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-boolean-)
- [`Flowable::zipWith(Publisher, BiFunction, boolean, int)`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#zipWith-org.reactivestreams.Publisher-io.reactivex.functions.BiFunction-boolean-int-)

If the Javadoc is viewed on a wide screen, the images are displayed on the right side instead of the left. I have a screenshot attached where the problem can be seen.

The problem can be resolved by adding `<p>` before the image element.

![screenshot_2018-11-11 flowable rxjava javadoc 2 2 3](https://user-images.githubusercontent.com/12369767/48316512-ec073680-e5e4-11e8-8d20-566b63d32a3e.png)"PR welcome =||= Javadoc: Fix incorrect image placement"Add `<p>` before image elements in Javadoc.

Resolves: #6302 "Lorenz Pahllorenzpahl11/11/18, 08:58:03 PM
6299.06305Javadoc: Explain explicitly that the Emitter methods should be called non-concurrently with generate"The Javadocs of the `generate` methods as well the `Emitter` interface should explicitly mention that the methods should be called non-concurrently. Generate can be found in both `Flowable` and `Observable`.

#### generate:

```html
<p>
Note that the {@link Emitter#onNext}, {@link Emitter#onError} and 
{@link Emitter#onComplete} methods provided to the function should be called synchronously,
never concurrently and only while the method is executing. Calling them from multiple threads 
or outside the function call is not supported and leads to an undefined behavior.
```

#### Emitter:

```html
<p>
Note that the {@link Emitter#onNext}, {@link Emitter#onError} and 
{@link Emitter#onComplete} methods provided to the function should be called synchronously,
never concurrently. Calling them from multiple threads is not supported and leads to an 
undefined behavior.
```""I believe calling from multiple threads is supported if there is a happens-before relationship between calls. Perhaps this:
```
<p>
Note that there must be a <i>happens-before</i> relationship between calls to the {@link Emitter#onNext}, {@link Emitter#onError} and 
{@link Emitter#onComplete} methods. Calling those methods from multiple threads without establishing that relationship is not supported and leads to undefined behavior.
``` =||= Fundamentally, the calls should not escape the callback method and one would have to block the callback if the `onNext` happens asynchronously to the method. Still you can only call it once and the blocking implicitly establishes this relationship. =||= Sounds good, thanks @akarnokd  =||= "Javadoc : Explain explicitly about using Emitter interface methods synchronously"Add note in Javadoc explicitly explaining about using Emitter interface methods synchronously.

- Add notes for `generate` methods in Observable and Flowable.
- Plus, add the similar note to Emitter interface.

Resolves: #6299 

"PunitDpunitda11/13/18, 02:16:51 PM
6290.06311Javadoc: explain that distinctUntilChanged requires non-mutating data to work as expected"`distinctUntilChanged` keeps the last value/key (depending on the overload) so it can compare it agains the newer value/key via `Object.equals`. However, if the value/key is mutable and gets mutated in between elements, the operator may not work as expected and filter out the seemingly same data:

```java
PublishSubject<List<Integer>> subject = PublishSubject.create();
List<Integer> list = new ArrayList<Integer>();
list.add(1);

subject.distinctUntilChanged().subscribe(System.out::println);

subject.onNext(list);
// prints [1]

list.add(2);

subject.onNext(list);
// does not print anything, but [1, 2] was expected.
```

In the example, the same reference is passed to `distinctUntilChanged` thus two subsequent items evaluate as same. This mistake by the user is also very common on Android and with text components using a mutable `CharSequence`.

I suggest adding a section to every `distinctUntilChanged` variant explaining the situation in short, something along the lines:

```
<p>
Note that if the element type of the flow is mutable, the comparison of the previous and current 
item may yield unexpected results if the items are mutated externally. Common cases are mutable
{@code CharSequence}s or {@code List}s where subsequent objects are actually the same 
references modified before/after {@code distinctUntilChanged}. It is recommended mutable data is
converted to an immutable one, such as `map(CharSequence::toString)` or 
`map(Collections::unmodifiableList)` for example, to avoid the situation.
```""Nice. Never actually thought of this case. Very valid. :tada: 

Few questions before the PR. 
1. This should reflect on withLatestForm variants for `Observable` & `Flowable` types right?
2. Additionally, will it be okay to link this issue to the doc for clarity? =||= Hi.

1. It's about the `distinctUntilChanged` where this mutation is most obviously affecting a flow. All overloads in both `Observable` and `Flowable` should be updated.
2. We don't link to issues in the main javadoc. =||= "Javadoc: explain that distinctUntilChanged requires non-mutating data to work as expected"- Add note in javadoc for all `distinctUntilChanged()` methods in `Flowable` and `Observable` class explaining about unexpected results to expect when using mutable data sources like **Mutable CharSequence** or **Lists**.

Resolves: #6290 "PunitDpunitda11/16/18, 05:00:18 PM
6309.06313Lack of NonNull anotations in factory methods"I was wondering if there shouldn't be an `@javax.annotation.Nonnull` it methods like:
`Single.just`
`Observable.just`
`Observable.fromX`
etc?

It would improve code quality on client side, since IDE might help detect early and compiler would print warning.""JSR 305 where that annotation lives is incompatible with Java 9 modules so we use our own annotations. Most ide will let you define RxJava's annotations as custom nullability annotations or are supported out of box.

PR welcome. =||= True, there are RxJava custom annotations and I see that most value for clients rely in `io.reactivex.functions` package. In order to make great improvements we should change 
`    R apply(@NonNull T t) throws Exception;`
to 
`    @NonNull R apply(@NonNull T t) throws Exception;`

Do you think that this is allowed? =||= The `functions` are a special case because some usages could work with nulls and they just create warnings. This has been discussed before:

https://github.com/ReactiveX/RxJava/issues?utf8=%E2%9C%93&q=is%3Aissue+nullable+is%3Aclosed+annotation =||= Hi. Can I take this up? =||= @freakomonk Fine by me. Nobody else seems to be working on this at the moment. =||= Sure @akarnokd . Any pointers to know before I start this up? =||= Beyond this issue, nothing specifically. We'll review the PR anyway and give you feedback if something needs changing. =||= "Adding NonNull annotations to Observable & Single"Adding NonNull annotations in factory methods for improved code compilation

Resolves: #6309"Abhimithra Karthikeyafreakomonk12/19/18, 10:23:44 AM
6320.063212.x Correct Flowable#toObservable BackpressureSupportLike in `Observable.fromPublisher` the `@BackpressureSupport` annotation should be more explicit in reflecting that the kind of backpressure that `ObservableFromPublisher` implements is in fact unbounded as opposed to none. Fix Flowable#toObservable backpressure supportResolves #6320Philip Leonardphilleonard11/23/18, 07:41:08 AM
6331.06351Outdated java example in wiki "Outdated java example in [wiki](https://github.com/ReactiveX/RxJava/wiki/How-To-Use-RxJava) page :


```
public static void hello(String... names) {
    Observable.from(names).subscribe(new Action1<String>() {

        @Override
        public void call(String s) {
            System.out.println(""Hello "" + s + ""!"");
        }

    });
}
```

Change it to 

```
public static void hello(String... names) {
        Observable.fromArray(names).subscribe(s -> System.out.println(""Hello "" + s));
    }
```"java8...... =||= Hello, I've created a pr about this issue. =||= Update outdated java example in wiki #6331"Updated java example in docs/How-To-Use-RxJava.md file with java 8 version.

Resolves: #6331"Kemal Özcanyekeoe12/28/18, 10:11:53 PM
6358.063592.x: Disposable already set! using delaySubscription with takeUntil/repeatWhen"Issue encountered in: io.reactivex.rxjava2:rxjava:2.2.4

When using a combination of takeUntil/repeatWhen operators on an Observable with delaySubscription operator applied, it is possible to encounter a ProtocolViolationException: Disposable already set! thrown by RepeatWhenObserver#onSubscribe. It appears that if delaySubscription uses an ObservableSource which rapidly/concurrently emits multiple notifications a rare race condition leads to a double subscription issue.

I am not sure if this issue is a user error (take(1) on ObservableSource supplied to delaySubscription alleviates it) or a bug in RxJava however the following, slow unit test demonstrates it:

```java

    @Test
    public void delaySubscriptionWithRepeatWhen() {
        List<Throwable> errors = TestHelper.trackPluginErrors();

        ExecutorService executor = Executors.newFixedThreadPool(2);
        try {
            Observable<Object> subscriptionSignal = Observable.merge(
                    Observable.just(new Object()).delay(0, TimeUnit.MILLISECONDS),
                    Observable.just(new Object()).delay(0, TimeUnit.MILLISECONDS)
            );

            final Subject<Boolean> boolStream = PublishSubject.<Boolean>create().toSerialized();

            Observable<Boolean> brokenStream = boolStream
                    .delaySubscription(subscriptionSignal)
                    .takeUntil(new Predicate<Boolean>()  {
                        @Override
                        public boolean test(Boolean state) throws Exception {
                            return state;
                        }
                    })
                    .repeatWhen(new Function<Observable<Object>, ObservableSource<?>>() {
                        @Override
                        public ObservableSource<?> apply(Observable<Object> objectObservable) throws Exception {
                            return boolStream.filter(new Predicate<Boolean>() {
                                @Override
                                public boolean test(Boolean state) throws Exception {
                                    return !state;
                                }
                            });
                        }
                    });

            final Random random = new Random();
            for (int i = 0; i < 1000000; i++) {
                final TestObserver<Boolean> testObserver = brokenStream.test();
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        boolStream.onNext(random.nextBoolean());
                        testObserver
                                .assertNoErrors()
                                .dispose();
                    }
                });
                if (!errors.isEmpty()) {
                    fail(""Uncaught fatal errors: "" + errors);
                }
            }
        } finally {
            executor.shutdown();
            try {
                executor.awaitTermination(30, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
            }
        }
    }
```""I've tried the test provided but didn't get any protocol violations with 2.2.5. Please provide a stacktrace of the actual error. =||= @akarnokd here is the stacktrace:

```
java.lang.AssertionError: Uncaught fatal errors: io.reactivex.exceptions.ProtocolViolationException: Disposable already set!
	at io.reactivex.internal.disposables.DisposableHelper.reportDisposableSet(DisposableHelper.java:156)
	at io.reactivex.internal.disposables.DisposableHelper.setOnce(DisposableHelper.java:82)
	at io.reactivex.internal.operators.observable.ObservableRepeatWhen$RepeatWhenObserver.onSubscribe(ObservableRepeatWhen.java:95)
	at io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate$TakeUntilPredicateObserver.onSubscribe(ObservableTakeUntilPredicate.java:49)
	at io.reactivex.internal.operators.observable.ObservableDelaySubscriptionOther.subscribeActual(ObservableDelaySubscriptionOther.java:39)
	at io.reactivex.Observable.subscribe(Observable.java:12246)
	at io.reactivex.internal.operators.observable.ObservableTakeUntilPredicate.subscribeActual(ObservableTakeUntilPredicate.java:32)
	at io.reactivex.Observable.subscribe(Observable.java:12246)
	at io.reactivex.internal.operators.observable.ObservableRepeatWhen$RepeatWhenObserver.subscribeNext(ObservableRepeatWhen.java:151)
	at io.reactivex.internal.operators.observable.ObservableRepeatWhen.subscribeActual(ObservableRepeatWhen.java:60)
	at io.reactivex.Observable.subscribe(Observable.java:12246)
	at io.reactivex.Observable.test(Observable.java:15441)
	at io.reactivex.internal.operators.observable.ObservableDelayTest.delaySubscriptionWithRepeatWhen(ObservableDelayTest.java:1020)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)

``` =||= Thanks. This is a race condition due to that flooding ""repeat"" signal and `active` set to false before the previous `Disposable` is cleared. The `retryWhen` is implemented correctly in this regard. I'll post a fix shortly. =||= "2.x: Fix the error/race in Observable.repeatWhen due to flooding repeat signal"This PR fixes a race condition in the `ObservableRepeatWhen` operator for the case when the repeat signal is not 1-for-1 and a new subscription may race with the clearing of the previous disposable because `active` is set to `false` too early. The fix is to swap the two operations. 

`Observable.retryWhen` and the `Flowable` versions do not have this bug. Unit tests were added to all 4 operators to verify the correct behavior regardless.

Fixes: #6358 "David Karnokakarnokd01/04/19, 11:39:21 PM
6363.063642.x: Deadlock when adding doOnSubscribe to Flowable"For some time, I [have been investigating a deadlock that occurs in my codebase](https://stackoverflow.com/q/54116679/590790), seemingly after the default backbuffer size has been filled. While trying to create a repro, I ran into a similar issue which shows the same symptoms with a minimum amount of code. I see no obvious cause, and therefore believe this might be a potential RxJava 2.x bug (reproducible so far on 2.2.0 and 2.2.5).

```
fun main( args: Array<String> )
{
    // Override the default buffer size of 128 to 10 for easier testing.
    System.setProperty( ""rx2.buffer-size"", ""10"" )

    val numbers = Flowable
        .range( 0, Int.MAX_VALUE )
        // Commenting out '.doOnSubscribe' here prevents the deadlock.
        .doOnSubscribe { println( ""Subscribed."" ) }
        .share()
    val evenNumbers = numbers
        .filter { number -> number % 2 == 0 }
    val oddNumbers = numbers
        .filter { number -> number % 2 != 0 }
    val getNextOdd = oddNumbers.first( 0 )
    evenNumbers
        .concatMap { even ->
            Single.zip(
                Single.just( even ), getNextOdd,
                BiFunction { a: Int, b: Int -> Pair( a, b ) }
            ).toFlowable()
        }
        .takeWhile { it.first < 1000 }
        .doOnComplete { println( ""Done."" ) }
        .subscribe { println( it ) }

    readLine()
}
```
This halts depending on the backbuffer size. In the code example at:

> Subscribed.
> (0, 1)
> (2, 3)
> (4, 5)
> (6, 7)
> (8, 9)

As commented in the above code, commenting out the `doOnSubscribe` line will prevent the deadlock from occurring.

Is this a bug, or am I doing something inherently wrong? E.g., I imagine things get complicated the way I reuse the same stream to 'zip', but this is the use case which also is needed in my actual codebase. Regardless, I do not understand what `doOnSubscribe` would have to do with anything here.""Hi and thanks for reporting. This is a bug in the `publish` operator (part of `share`) not requesting more if there was a change in the subscriber array (due to `first` in your example). The reason it didn't happen without `doOnSubscribe` is that `range` and `publish` operators fuse together when adjacent to each other and there is no request management involved there as an optimization. Preventing this fusion resulted in the request mismanagement bug. I'll post a fix shortly.

*(Ps. Please next time, post a Java code example as not only there isn't an IntelliJ option to paste Kotlin code as Java, but I have to manually battle the lambdas for it to be Java 6 compatible. Thanks.)* =||= Thank you for the amazingly quick fix! At a glance, it might in fact be [the same deadlock I initially observed](https://stackoverflow.com/questions/54116679/avoiding-same-pool-deadlocks-when-using-flowable-in-reactive-extensions). I will keep you informed, and make sure to post Java code samples in the future.

In case upgrading to a temporary release would not be an option, would you know of any potential workaround which does not require a change to the 'publish' operator?

I believe for my use case, I might be able to call `publish( expectedMaxItems ).refCount()`. Would this imply `expectedMaxItems` would be kept in memory, or is this unrelated? =||= "2.x: Fix publish not requesting upon client change"Due to a bug in the `Flowable.publish` operator, it is not requesting more if there was a change in the subscriber array during an emission run in the non-fused operation mode.

Fixes: #6363"David Karnokakarnokd01/15/19, 10:37:23 AM
6368.06370Interruption does not happen when timing out a task scheduled on `Schedulers.from(executor)`"It looks like when using a scheduler created from `Schedulers#from` using timeout will not interrupt the task:

Version 2.2.5

```java
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);
        Scheduler schedulerFromExecutor = Schedulers.from(scheduledExecutorService);

        Flowable<Integer> results = Flowable.fromIterable(()-> {

            return new Iterator<Integer>() {
                @Override
                public boolean hasNext()
                {
                    try
                    {
                        Thread.sleep(1000);
                        return false;
                    }
                    catch (InterruptedException e)
                    {
                        System.out.println(""Interrupted! "" + e);
                        return true;
                    }
                }

                @Override
                public Integer next()
                {
                    return 2;
                }
            };

        }).subscribeOn(schedulerFromExecutor);//change to Schedulers.io() to make it work.

        results.timeout(500, TimeUnit.MILLISECONDS, Schedulers.single(), Flowable.error(new TimeoutException(""Timed out"")))
                .doOnTerminate(()-> System.out.println(""Finished""))
                .subscribe(r-> System.out.println(""Got "" + r), e-> System.out.println(""Error "" + e));

        Thread.sleep(2000);
```

Output when using `schedulerFromExecutor`
```
Finished
Error java.util.concurrent.TimeoutException: Timed out
```

Output when using `Schedulers.io()`
```
Finished
Interrupted! java.lang.InterruptedException: sleep interrupted
Error java.util.concurrent.TimeoutException: Timed out
```""Hi and thanks for reporting. Looks like we don't have support for interrupting immediate tasks of `Schedulers.from`. Currently, there is no 1:1 mapping of a cancelable `Future` and RxJava tasks as every immediate task is coalesced into a trampolined execution, thus a `Future` is covering arbitrary tasks, not just 1 specifically like with the standard schedulers.

The solution is replicate the interruption logic of `FutureTask` but I have to think about a bit in context of our Scheduler requirements. =||= Thanks for looking in to this so quickly.
In the meantime I am looking at using your implementation of ParallelScheduler https://github.com/akarnokd/RxJava2Extensions#parallelscheduler
 =||= /cc @artem-zinnatullin @vanniktech 

I think making the implementation interruptible by default is a change that could affect current users relying on it not being interruptible. I suggest adding a mode selector overload to `Schedulers.from`. =||= Yes. Let's keep the current behavior and add a flag to opt into the new one. =||= Sounds reasonable to me to make it opt-in while keeping current behavior as is. =||= Hi,
out of curiosity, do you remember the reason for not using FutureTask, and instead writing InterruptibleRunnable ?
Cheers,
Jon =||= Because we needed to have cleanup running correctly with respect of the interrupt and normal termination without the extra feature baggage overhead of `FutureTask`:

https://github.com/ReactiveX/RxJava/blob/a1693ecc9215027a7a3eae75272979ebb4d79a27/src/main/java/io/reactivex/rxjava3/internal/schedulers/ExecutorScheduler.java#L358

https://github.com/ReactiveX/RxJava/blob/a1693ecc9215027a7a3eae75272979ebb4d79a27/src/main/java/io/reactivex/rxjava3/internal/schedulers/ExecutorScheduler.java#L385

 =||= "2.x: Add interruptible mode to Schedulers.from"By default, the `Schedulers.from` uses a trampoline to ensure worker tasks are executed FIFO and non-overlappingly on any potentially multi-threaded `Executor`. This old setup didn't allow task interruption due to this disconnect between the trampoline task and the operator task. (In contrast, the standard schedulers use single threaded executors and their `Future` is linked and interruptible when the operator task is cancelled).

This PR add an interruptible mode to the `Schedulers.from` via a paramerer in a new overload and some internal dispatching based on this mode selector. Existing `Schedulers.from(Executor)` users should still behave the same.

Resolves: #6368"David Karnokakarnokd01/17/19, 01:41:03 PM
6373.06375Single.observeOn wrongly interrupt thread"I tested issue on RxJava 2.2.5

I encountered the issue when Single.observeOn interrupt the thread, that performs downstream operation.

Below code of unit test and a slightly modified for test purposes ""SingleObserveOn"" class.

```
@Test
public void test() throws InterruptedException
{
    Single.ambArray
            (
                    Single
                            .fromCallable(() ->
                            {
                                System.out.println(System.currentTimeMillis() + "" "" + ""Callable1! "" + Thread.currentThread());
                                return ""Qqq"";
                            })
                            .subscribeOn(Schedulers.newThread())
                            .observeOn(Schedulers.newThread())
                    ,
                    Single.never()
            )
          .subscribe((s, throwable) ->
          {
              System.out.println(System.currentTimeMillis() + "" "" + ""Subscribe1 and blocking await! "" + Thread.currentThread());

              Completable.timer(1000, TimeUnit.MILLISECONDS).blockingAwait();

              System.out.println(System.currentTimeMillis() + "" "" + ""Subscribe2! "" + Thread.currentThread());
              System.out.println(s);
          });

    Thread.sleep(10000);
}
```

```
public final class SingleObserveOn<T> extends Single<T>
{

    final SingleSource<T> source;

    final Scheduler scheduler;

    public SingleObserveOn(SingleSource<T> source, Scheduler scheduler)
    {
        this.source = source;
        this.scheduler = scheduler;
    }

    @Override
    protected void subscribeActual(final SingleObserver<? super T> observer)
    {
        source.subscribe(new ObserveOnSingleObserver<T>(observer, scheduler));
    }

    static final class ObserveOnSingleObserver<T> extends AtomicReference<Disposable>
            implements SingleObserver<T>, Disposable, Runnable
    {
        private static final long serialVersionUID = 3528003840217436037L;

        final SingleObserver<? super T> downstream;

        final Scheduler scheduler;

        T value;
        Throwable error;

        ObserveOnSingleObserver(SingleObserver<? super T> actual, Scheduler scheduler)
        {
            this.downstream = actual;
            this.scheduler = scheduler;
        }

        @Override
        public void onSubscribe(Disposable d)
        {
            if (DisposableHelper.setOnce(this, d))
            {
                downstream.onSubscribe(this);
            }
        }

        @Override
        public void onSuccess(T value)
        {
            this.value = value;

            System.out.println(System.currentTimeMillis() + "" "" + ""ObserveOnSingleObserver.onSuccess1! "" + Thread.currentThread());

            Disposable d = scheduler.scheduleDirect(this);
            //I added this loop for simulate ""busy"" thread situation.
            for (int i = 0; i < 1_000_000; i++)
            {
            }

            System.out.println(System.currentTimeMillis() + "" "" + ""ObserveOnSingleObserver.onSuccess2! "" + Thread.currentThread());

            DisposableHelper.replace(this, d);
        }

        @Override
        public void onError(Throwable e)
        {
            this.error = e;
            Disposable d = scheduler.scheduleDirect(this);
            DisposableHelper.replace(this, d);
        }

        @Override
        public void run()
        {
            System.out.println(System.currentTimeMillis() + "" "" + ""ObserveOnSingleObserver.run! "" + Thread.currentThread());

            Throwable ex = error;
            if (ex != null)
            {
                downstream.onError(ex);
            }
            else
            {
                downstream.onSuccess(value);
            }
        }

        @Override
        public void dispose()
        {
            System.out.println(System.currentTimeMillis() + "" "" + ""ObserveOnSingleObserver.dispose! "" + Thread.currentThread());
            DisposableHelper.dispose(this);
        }

        @Override
        public boolean isDisposed()
        {
            return DisposableHelper.isDisposed(get());
        }
    }
}
```

Result of run this test next:
```
1547699583389 Callable1! Thread[RxNewThreadScheduler-1,5,main]
1547699583389 ObserveOnSingleObserver.onSuccess1! Thread[RxNewThreadScheduler-1,5,main]
1547699583390 ObserveOnSingleObserver.run! Thread[RxNewThreadScheduler-2,5,main]
1547699583390 ObserveOnSingleObserver.dispose! Thread[RxNewThreadScheduler-2,5,main]
1547699583390 Subscribe1 and blocking await! Thread[RxNewThreadScheduler-2,5,main]
1547699583393 ObserveOnSingleObserver.onSuccess2! Thread[RxNewThreadScheduler-1,5,main]
io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | java.lang.RuntimeException: java.lang.InterruptedException
	at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)
	at io.reactivex.internal.observers.BiConsumerSingleObserver.onSuccess(BiConsumerSingleObserver.java:60)
	at io.reactivex.internal.operators.single.SingleAmb$AmbSingleObserver.onSuccess(SingleAmb.java:110)
	at io.reactivex.internal.operators.single.SingleObserveOn$ObserveOnSingleObserver.run(SingleObserveOn.java:112)
	at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578)
	at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)
	at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.RuntimeException: java.lang.InterruptedException
	at io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:46)
	at io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:93)
	at io.reactivex.Completable.blockingAwait(Completable.java:1219)
	at com.multibrains.InterruptedExceptionTest.lambda$test$1(InterruptedExceptionTest.java:44)
	at io.reactivex.internal.observers.BiConsumerSingleObserver.onSuccess(BiConsumerSingleObserver.java:57)
	... 11 more
Caused by: java.lang.InterruptedException
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302)
	at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
	at io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:90)
	... 14 more
Exception in thread ""RxNewThreadScheduler-2"" io.reactivex.exceptions.UndeliverableException: The exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with. Further reading: https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling | java.lang.RuntimeException: java.lang.InterruptedException
	at io.reactivex.plugins.RxJavaPlugins.onError(RxJavaPlugins.java:367)
	at io.reactivex.internal.observers.BiConsumerSingleObserver.onSuccess(BiConsumerSingleObserver.java:60)
	at io.reactivex.internal.operators.single.SingleAmb$AmbSingleObserver.onSuccess(SingleAmb.java:110)
	at io.reactivex.internal.operators.single.SingleObserveOn$ObserveOnSingleObserver.run(SingleObserveOn.java:112)
	at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578)
	at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)
	at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: java.lang.RuntimeException: java.lang.InterruptedException
	at io.reactivex.internal.util.ExceptionHelper.wrapOrThrow(ExceptionHelper.java:46)
	at io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:93)
	at io.reactivex.Completable.blockingAwait(Completable.java:1219)
	at com.multibrains.InterruptedExceptionTest.lambda$test$1(InterruptedExceptionTest.java:44)
	at io.reactivex.internal.observers.BiConsumerSingleObserver.onSuccess(BiConsumerSingleObserver.java:57)
	... 11 more
Caused by: java.lang.InterruptedException
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(AbstractQueuedSynchronizer.java:1302)
	at java.util.concurrent.CountDownLatch.await(CountDownLatch.java:231)
	at io.reactivex.internal.observers.BlockingMultiObserver.blockingGet(BlockingMultiObserver.java:90)
	... 14 more
```


**explanation:**

```Callable1! Thread[RxNewThreadScheduler-1,5,main]``` - just return value

```ObserveOnSingleObserver.onSuccess1! Thread[RxNewThreadScheduler-1,5,main]``` - after this line value scheduled to ```RxNewThreadScheduler-2```, and sometime in the future will be excuted. And current thread  ```RxNewThreadScheduler-1``` stuck for any reason.

``` ObserveOnSingleObserver.run! Thread[RxNewThreadScheduler-2,5,main]``` - scheduled value ecxecuting

```ObserveOnSingleObserver.dispose! Thread[RxNewThreadScheduler-2,5,main]``` - ObserveOnSingleObserver is disposing, cause value was throw to the donwstream

```Subscribe1 and blocking await! Thread[RxNewThreadScheduler-2,5,main]``` - we get value in subscribe callback and do some long operaion (for example blocking await)

```ObserveOnSingleObserver.onSuccess2! Thread[RxNewThreadScheduler-1,5,main]``` - ```RxNewThreadScheduler-1``` revive and continue do his work...so it replace disposable, and see than current disposable have already disposed...and he cancel future (that related long operation started in ```RxNewThreadScheduler-2```), and interrupt ```RxNewThreadScheduler-2``` thread.


""Could you post the stacktrace of the dispose! call? =||= ```
at io.reactivex.internal.operators.single.SingleObserveOn$ObserveOnSingleObserver.dispose(SingleObserveOn.java:99)
	  at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:235)
	  at io.reactivex.disposables.CompositeDisposable.dispose(CompositeDisposable.java:80)
	  at io.reactivex.internal.operators.single.SingleAmb$AmbSingleObserver.onSuccess(SingleAmb.java:109)
	  at io.reactivex.internal.operators.single.SingleObserveOn$ObserveOnSingleObserver.run(SingleObserveOn.java:92)
	  at io.reactivex.Scheduler$DisposeTask.run(Scheduler.java:578)
	  at io.reactivex.internal.schedulers.ScheduledRunnable.run(ScheduledRunnable.java:66)
	  at io.reactivex.internal.schedulers.ScheduledRunnable.call(ScheduledRunnable.java:57)
	  at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:266)
	  at java.util.concurrent.FutureTask.run(FutureTask.java:-1)
	  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)
	  at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)
	  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	  at java.lang.Thread.run(Thread.java:745)

```

Below screenshot from Idea with Async Stacktrace...maybe it will more usefull
<img width=""965"" alt=""screenshot 2019-01-17 17 47 09"" src=""https://user-images.githubusercontent.com/5120540/51309854-4a86e000-1a80-11e9-9b3c-791fc380134b.png"">
 =||= Indeed, the winnner should not be disposed. I'll post a fix shortly. =||= " 2.x: Don't dispose the winner of {Single|Maybe|Completable}.amb()"This PR fixes the `Single.amb`, `Maybe.amb` and `Completable.amb` operators to not dispose the winner source, causing potential interruptions as a side-effect on the current thread.

The fix is to [delete](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/disposables/CompositeDisposable.html#delete-io.reactivex.disposables.Disposable-) the winner from the composite before disposing the rest to avoid the interruption race.

Unit tests were added to verify this behavior on all `amb` implementations. `Flowable` and `Observable` were already working correctly.

Fixes: #6373"David Karnokakarnokd01/17/19, 02:28:31 PM
6288.06377Javadoc: expand debounce() docs to explain possible interruption"`debounce` schedules a timeout which then emits the last item if no newer item arrives in the meantime. However, if the processing takes too long, a newer item may arrive and the previous task will get disposed, possibly interrupting the long running work.

The `Flowable.debounce` and `Observable.debounce` JavaDocs should mention this property for clarity, something along the lines:

```html
<p>
Delivery of the item after the grace period happens on the (default|given) {@code Scheduler}'s 
{@code Worker} which if takes too long, a newer item may arrive from the upstream, causing the 
{@code Worker}'s task to get disposed, which may also interrupt any downstream blocking operation
(yielding an {@code InterruptedException}). It is recommended processing items
that may take long time to be moved to another thread via {@link #observeOn} applied after 
{@code debounce} itself.
```"Expand `Observable#debounce` and `Flowable#debounce` javadoc"Mention that if the processing of a task takes too long
and a newer item arrives then the previous task will
get disposed interrupting a long running work.

Fixes: #6288 "Roman WuattierRomanWuattier01/23/19, 12:33:31 PM
6379.06386Add doOnTerminate to Single/Maybe for consistency"As mentioned in #5814, there is no `doOnTerminate` operator on `Single` or `Maybe`, but there is on `Observable`, `Flowable` and `Completable`. There doesn't seem to be any reason for this inconsistency, other than it's just an omission. 

Yes, you can workaround this using `donOnEvent`, but can we instead get this operator added just for API consistency?"Okay, PR welcome. =||= @akarnokd, I would like to contribute to this feature, is this issue free to work on? However, even though it seems pretty straightforward, I'm new to this project and it may take some time for me to submit a final PR, is it acceptable? I don't want to block if it's an urgent need and can be done by somebody else in a faster manner. Thanks. =||= Nobody has started working on this to my knowledge. I suggest you do it either way so you gain experience with doing PRs as well as creating RxJava operators. =||= Thanks for the tip. Will do. =||= Add doOnTerminate to Single/Maybe for consistency"This PR adds doOnTerminate operator to Single and Maybe.

Resolves: #6379."Sergey Kryvetsskryvets01/29/19, 12:45:38 PM
6397.06398[2.2.6] window() operator leaks subscriptions"Hi,

I believe I encountered `window` operator leaking observable subscriptions. Here is a small test to reproduce the issue:
```
fun main(args: Array<String>) {
    observable(1).window(observable(2).filter { it == 1 }, Function { _: Int -> observable(3).filter { it == 1 } }, 1)
            .subscribe()
            .dispose()
}

private fun observable(n: Int): Observable<Int> {
    return Observable.create<Int> { emitter ->
        println(""Subscribed! $n"")
        emitter.onNext(1)
        emitter.onNext(2)
        emitter.onNext(3)
        emitter.setCancellable { println(""Cancelled! $n"") }
    }
}
```

The output is:
```
Subscribed! 2
Subscribed! 3
Cancelled! 3
Subscribed! 1
```

From the output you can see that cancellables for `observable(1)` and `observable(2)` are never called.

This may be severe if cancellables are used to dispose some (possibly) critical resources upon subscription disposal."The operator will not dispose the inner windows if you dispose the outer sequence of windows. You should not ignore the inner windows produced by the operator. Most use cases have `flatMap` to merge the windows back which will dispose all of them as you expected. =||= The printout is certainly odd. I'll investigate further. =||= 2.x: Fix window() with start/end selector not disposing/cancelling properly"This PR fixes the start-end selector variant of `Observable.window` and `Flowable.window` to properly 

- dispose the window-opening sequence upon disposing the main output flow and 
- disposing the main upstream upon disposing the main output flow provided there are no windows open.

Fixes: #6397"David Karnokakarnokd02/13/19, 08:51:09 AM
6404.06405concatEager does not unsubscribe from sources"Hi, I have a question regarding the behaviour of concatEager in version 2.2.6.

We were caught out recently by the behaviour of concatEager when the downstream unsubscribes before the upstream sources have completed, namely that the upstream sources are not unsubscribed from when this happens. This left us with a rather nasty memory leak in our application due to some downstream periodical resubscription logic.

Consider the following two tests (apologies for the Kotlin, I can convert to Java on request, but I hope it makes sense)

```
    @Test
    fun concat() {
        val _publisher1 = PublishProcessor.create<Unit>()
        val _publisher2 = PublishProcessor.create<Unit>()
        val publisher1 = _publisher1.doOnSubscribe { println(""1 Subscribed"") }.doOnCancel { println(""1 Cancelled"") }
        val publisher2 = _publisher2.doOnSubscribe { println(""2 Subscribed"") }.doOnCancel { println(""2 Cancelled"") }

        assertFalse(_publisher1.hasSubscribers())
        assertFalse(_publisher2.hasSubscribers())

        val testSubscriber = Flowable.concat(Flowable.just(publisher1, publisher2))
            .subscribe()

        assertTrue(_publisher1.hasSubscribers())
        assertFalse(_publisher2.hasSubscribers())

        testSubscriber.dispose()

        assertFalse(_publisher1.hasSubscribers())
        assertFalse(_publisher2.hasSubscribers())
    }

    @Test
    fun concatEager() {
        val _publisher1 = PublishProcessor.create<Unit>()
        val _publisher2 = PublishProcessor.create<Unit>()
        val publisher1 = _publisher1.doOnSubscribe { println(""1 Subscribed"") }.doOnCancel { println(""1 Cancelled"") }
        val publisher2 = _publisher2.doOnSubscribe { println(""2 Subscribed"") }.doOnCancel { println(""2 Cancelled"") }

        assertFalse(_publisher1.hasSubscribers())
        assertFalse(_publisher2.hasSubscribers())

        val testSubscriber = Flowable.concatEager(Flowable.just(publisher1, publisher2))
            .subscribe()

        assertTrue(_publisher1.hasSubscribers())
        assertTrue(_publisher2.hasSubscribers())

        testSubscriber.dispose()

        assertFalse(_publisher1.hasSubscribers())
        assertFalse(_publisher2.hasSubscribers())
    }
```

The first test (concat) completes successfully with the following output:
```
1 Subscribed
1 Cancelled
```
As we expected, `_publisher1` was unsubscribed from when the `testSubscriber` is disposed.

The second test (concatEager) fails however with the following output:
```
1 Subscribed
2 Subscribed
2 Cancelled
```
This doesn't behave as we expected, with the current active publisher `_publisher1` not having been unsubscribed from when the `testSubscriber` is disposed.

Now the wording on the documentation is different - concat:

> Returns a Flowable that emits the items emitted by each of the Publishers emitted by the source Publisher, one after the other, without interleaving them.

vs concatEager:

> The operator buffers the values emitted by these Publishers and then drains them in order, each one after the previous one completes.

But this was not enough to convey the rather large difference in behaviour with the upstream dispose, to us at least, if this is indeed what it was attempting to convey.

So my questions really are
Is this behaviour expected, or should concatEager dispose all of the upstream sources, including the active one, when it is itself disposed?
If this is the expected behaviour, do you think the documentation should/could be improved here?"`concatEager` is supposed to dispose all sources. I'll investigate it. =||= Thanks, I appreciate it =||= This is a bug in the operator. I posted a fix in #6405. =||= 👍 That was very quick, thanks again =||= 2.x: Fix concatEager to dispose sources & clean up properly."This PR fixes the `concatMapEager` operator (which drives the static variants as well) to properly dispose and clean up the state of the operator upon cancelling/disposing the sequence.

- `Flowable.concatMapEager` did not cancel the current active inner consumer, only the ones coming after
- `Observable.concatMapEager` did not dispose the main source of the inner observables.

Both variants have received the same two unit tests to verify their behavior.

Fixes: #6404"David Karnokakarnokd02/12/19, 10:24:47 PM
6276.06408flattenAsFlowable wrong wording in Javadocs"The wording of `Single.flattenAsFlowable` is a bit off:

> ""Returns a Flowable that **merges each item emitted by the source Single with the values in an Iterable corresponding to that item that is generated by a selector.**""

In contrast, `flattenAsObservable` is somewhat better:

> ""Returns an Observable that maps a success value into an Iterable and emits its items.""

I'd say something along the lines of:

""Maps the success value of the upstream `{@code Single}` into an `{@link Iterable}` and emits its items as an `{@link Observable}` sequence.""

The `Maybe` variants have the same issues (they were copy-pasted back then).""Hi @akarnokd  I would like to start working on this. Could you please give me some heads up ?  =||= > Could you please give me some heads up ?

Nobody has started working on this yet so go ahead. =||= @dilantha111 Have you finished working on this? =||= @freakomonk  Nope. Just got some other things coming up. If you are willing to do that, please go ahead. At the moment stuck with some other stuffs.  =||= @dilantha111 Since I have finished some other issue as my first bug, I don't think its fair for me to take this up too. So leaving it open for others to take it. =||= @freakomonk Unfortunately, people are not lining up to work on issues right now so I suggest you do as much as you like and not worry about taking away opportunities. =||= @akarnokd Sure David. Will take it up tomorrow. =||= @akarnokd I would like to work on this =||= @thiyagu-7 Sure! =||= "Improving Javadoc of flattenAsFlowable and flattenAsObservable method"Improving the javadoc of the `flattenAsFlowable` and `flattenAsObservable` methods of `Single` and `Maybe` classes.

Resolves: #6276 "Thiyagarajanthiyagu-702/16/19, 07:02:31 PM
6430.06432"2.x ""d is null"" message for CompositeDisposable add and addall""Affects version: 2.2.7 (and before)

Message ""d is null"" for errors in CompositeDisposable's add and addall methods is not very helpfull."2.x composite disposable docs"On CompositeDisposable add and addAll methods, if the param is null, currently the NPE error message (produced by ObjectHelper) is ""d is null"" which is not very helpful.

This is a small refactor for making the message a bit more helpful.

Resolves #6430 "Vasileios Chroniadischronvas03/15/19, 06:21:26 PM
6435.06436Wiki improve: Observable.fromArray()"Hey guys just  a little suggestion over the use of
 `Observable.fromArray()` 
in wiki pages,
 seems to have used the
 `Observable.fromIterable(list);` instead of `Observable.fromArray(array);`
Here is link to page 
https://github.com/ReactiveX/RxJava/wiki/Creating-Observables#fromarray
Please change if applicable thanks.""Hi, you can post a PR against https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md =||= I would like to add that there are more issues on that wiki page that could be resolved along with the mentioned problem:

- Missing parentheses in the second [`just`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#just) example: `error.printStackTrace` instead of `error.printStackTrace()`.
- [`fromFuture`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#fromfuture-example), [`create`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#create-example): `Executors.newSingleThreadedScheduledExecutor()` instead of `Executors.newSingleThreadScheduledExecutor()`.
- [`range`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#range-example): typo `erro`. `Char` should be `Character`.
- [`error`](https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md#error-example): variable `error` is defined twice. =||= hey @akarnokd  i just opened a PR with included suggestions from @lorenzpahl also.
https://github.com/ReactiveX/RxJava/pull/6436
Please merge them.
Thanks 😃  =||= "refactor: improves Creating-Observables wiki doc"This PR improves the documentation for creating observables 
https://github.com/ReactiveX/RxJava/blob/2.x/docs/Creating-Observables.md
suggestions from @lorenzpahl also included. 
Closes: #6435 "vikas kumarworstkiller03/21/19, 01:45:53 PM
6451.06452Unnecessary dependency on Schedulers.trampoline() for non-time-based refcount operator"In the constructor of `ObservableRefCount` that takes `ConnectableObservable<T> source` as the argument, we set `timeout` to `0L`. In that specific use case of `ObservableRefCount`, `scheduler` is never needed. It's only referenced in `cancel()` method but if `timeout` is 0, it won't be triggered at all because there is early return. I am wondering if we could avoid referencing `Schedulers.trampoline()` in that specific use case of `ObservableRefCount` to keep the dependency clear.

https://github.com/ReactiveX/RxJava/blob/4a78cfcbf2f0d7008042c15ea8bb6797fcd2b06e/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java#L48-L50
https://github.com/ReactiveX/RxJava/blob/4a78cfcbf2f0d7008042c15ea8bb6797fcd2b06e/src/main/java/io/reactivex/internal/operators/observable/ObservableRefCount.java#L92-L112
The reasons are the following:

1. In projects that don't depend on `Schedulers` class, if there is no reference to `Schedulers`, the whole `Schedulers` can be stripped out of the library after optimizations (e.g., proguard). With constructor that references `Schedulers`, the optimizer can't properly strip it out. In our quick test of our Android app, we were able to reduce the RxJava library size dependency from 51KB to 37KB (after optimization but before compression) by simply avoiding access to `Schedulers` in `ObservableRefCount`.
2. In terms of modularity, `ObservableRefCount` is just an operator so it by itself should probably not have dependency on what available pool of schedulers (`Schedulers`) there are. It should just know that there is some `Scheduler` that could be passed to `ObservableRefCount` when `ObservableRefCount` needs it.
"Yes, it can be replaced by `null`. PR welcome. =||= Remove dependency of Schedulers from ObservableRefCount"Resolves #6451.

In the constructor of `ObservableRefCount` that takes `ConnectableObservable<T> source` as the argument, we set `timeout` to `0L`. In that specific use case of `ObservableRefCount`, `scheduler` is never needed. It's only referenced in `cancel()` method but if timeout is 0, it won't be triggered at all because there is early return. This commit removes the need to depend on `Schedulers.trampoline()` and instead passes null to be scheduler when the ref count is not time-based. Similarly, applies the same change to `FlowableRefCount`.

The reasons for this change are the following:

1. In projects that don't depend on `Schedulers` class, if there is no reference to `Schedulers`, the whole `Schedulers` can be stripped out of the library after optimizations (e.g., proguard). With constructor that references `Schedulers`, the optimizer can't properly strip it out. In our quick test of our Android app, we were able to reduce the RxJava library size dependency from 51KB to 37KB (after optimization but before compression) by simply avoiding access to `Schedulers` in `ObservableRefCount`.
2. In terms of modularity, `ObservableRefCount` is just an operator so it by itself should probably not have dependency on what available pool of schedulers (`Schedulers`) there are. It should just know that there is some `Scheduler` that could be passed to `ObservableRefCount` when `ObservableRefCount` needs it."Kuan-Yu Tsengmycallmax04/04/19, 06:37:17 PM
6468.06469ObservableSampleWithObservable redundant methods"
Inspected ObservableSampleWithObservable today, just to see how the resulting Observable acts if the sampler Observable completes, and found these method abstraction.

https://github.com/ReactiveX/RxJava/blob/deeb14150ac21ad8c7b38c1ac692be487375faf5/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java#L195

https://github.com/ReactiveX/RxJava/blob/deeb14150ac21ad8c7b38c1ac692be487375faf5/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java#L204

https://github.com/ReactiveX/RxJava/blob/deeb14150ac21ad8c7b38c1ac692be487375faf5/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java#L166

https://github.com/ReactiveX/RxJava/blob/deeb14150ac21ad8c7b38c1ac692be487375faf5/src/main/java/io/reactivex/internal/operators/observable/ObservableSampleWithObservable.java#L171

I don't see any point of them being separated if both methods just do the same thing, or am I missing something?"They can probably simplified. PR welcome. =||= Remove redundant methods from Sample(Observable)Resolves: #6468Alexis H. MunsayacLXSMNSYC04/26/19, 10:49:28 AM
6481.06483Maybe.count doc typo"![Screenshot from 2019-05-20 10-07-12](https://user-images.githubusercontent.com/4783372/57992533-467ad580-7ae7-11e9-8e17-6964b841c8b5.png)

Says here that it ""returns a Maybe"" when in fact it returns a Single."PR welcome. =||= Correction for Maybe.count doc typoResolves #6481 Alexis H. MunsayacLXSMNSYC05/20/19, 09:01:04 AM
6487.06488Multiple errors in zip'ed observables with flatMap"While reading [Error handling on wiki](https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling)  I realized that in a zip operator with a multiple network calls, it's possible to receive a crash with an UndeliverableException. I tried to reproduce this behavior:
 
RxJava version: 2.2.0

Reproduce code:

```
    @Test
    public void testUncaughtException() throws InterruptedException {
        Observable first = Observable.create(e -> {
            System.out.println(""first"");
            throw new HelperException(""first exception"");
        });

        Observable second = Observable.create(e -> {
            System.out.println(""second"");
            throw new HelperException(""second exception"");
        });

        List<Observable<?>> observableList = new ArrayList<>();
        observableList.add(first);
        observableList.add(second);

        Observable.zip(observableList, objects -> ""result"")
                .subscribeOn(Schedulers.io())
                .subscribe(
                        System.out::println,
                        t -> {
                            System.out.println(""exception caught!"");
                        }
                );
        Thread.sleep(2000);
    }
```
The output as expected:

```
first
exception caught!
second
io.reactivex.exceptions.UndeliverableException: ... HelperException: second exception ...
```

And the second test:

```
    @Test
    public void testUncaughtExceptionWithFlatMap() throws InterruptedException {
        Observable testObservable = Observable.create(e -> e.onNext(""""))
                .flatMap((Function<Object, ObservableSource<?>>) o -> {

                    Observable first = Observable.create(e -> {
                        System.out.println(""first"");
                        throw new HelperException(""first exception"");
                    });

                    Observable second = Observable.create(e -> {
                        System.out.println(""second"");
                        throw new HelperException(""second exception"");
                    });

                    List<Observable<?>> observableList = new ArrayList<>();
                    observableList.add(first);
                    observableList.add(second);

                    return Observable.zip(observableList, objects -> ""result"");
                });

        testObservable
                .subscribeOn(Schedulers.io())
                .subscribe(
                        System.out::println,
                        t -> System.out.println(""exception caught!"")
                );

        Thread.sleep(2000);
    }
```
And I expected an UndeliverableException too, but the output is:

```
first
exception caught!
```

Is this behavior correct? Why there is no UndeliverableException in the second test?

Thanks!

""In the second case, you crash synchronously when `zip` subscribes to the first source and it will never subscribe to the second source. =||= @akarnokd thank you for quick response! Can you explain, please, why in the second case crash happens synchronously and in the first not? =||= Correction. In both cases, you shouldn't see any undeliverable exceptions. What happens is that `flatMap` issues a cancel when it detects the error which then stops the subscription to the second source. I'll investigate this further. =||= The `Flowable.zip` works properly so this is an inconsistency with `Observable.zip`. I'll post a fix shortly. =||= @arkanokd

https://github.com/ReactiveX/RxJava/issues/6487#issuecomment-496018889

So, you saying that the correct one is not return an error right?

 =||= In this synchronous case, the process should stop after the first error and the second subscription should not happen. =||= @akarnokd thanks for explanations!

i am currently using `onErrorResumeNext` to tweak that part. so, whenever error occurs in observable i return default value. =||= "2.x: Fix zip not stopping the subscription upon eager error"The `Observable.zip` did not stop subscribing to the next sources if the previous one failed with an `onError`. `Flowable.zip` works as intended.

Fixes #6487"David Karnokakarnokd05/27/19, 08:23:33 AM
6501.06505publish().refCount() race may leave observers hanging"This test eventually times out because one of the sources will not complete or trigger a reconnection:

```java
for (int i = 0; i < 10_000; i++) {
    Observable<Integer> observable = Observable.just(1).publish().refCount();

    TestObserver<Integer> observer1 = observable
        .subscribeOn(Schedulers.computation())
        .test();

        TestObserver<Integer> observer2 = observable
        .subscribeOn(Schedulers.computation())
        .test();

    observer1
        .withTag(""observer1 "" + i)
        .awaitDone(5, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();

    observer2
        .withTag(""observer2 "" + i)
        .awaitDone(5, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();
}
```

(Originally reported as a [comment](https://github.com/ReactiveX/RxJava/pull/6187#issuecomment-501879711).)""In our anecdotal case, it's an observable that gets disposed and therefore cancels the HTTP request, while the next subscriber receives the immediately-canceled stream from the first subscriber.

Something like:

    val apiRequest: Observable<Foo> = retrofit.apiRequest()...share()

    // subscriber 1, main thread:
    val disposable = apiRequest....subscribeOn(Schedulers.io()).subscribe(...)
    ...
    disposable.dispose()
    
    // subscriber 2, also main thread:
    val disposable = apiRequest....subsribeOn(Schedulers.io()).subscribe(...)

Subscriber 1 for one reason or another, disposes before the API request responds.  Nearly the same time as the first one disposing, Subscriber 2 subscribes, and only receives the InterruptedIOException from the first request being canceled.

As I understood, when the first subscriber disposes, it should cancel the API request and also removes itself as a subscriber, so the refCount() should cause the upstream observable to dispose.  When the 2nd subscriber attaches, it should be starting a brand new request to the upstream API source, rather than receiving the first error.

So it's slightly different because it's not actually a timeout (as if the stream had zero events), it's actually receiving the error from the first subscriber's canceled attempt. =||= We were able to track down the part of our code that was triggering this issue, but I still believe that it is a race condition in `.share()`. Where your original suspicion was ""one of the observers connect right between onNext and onComplete"", in our case RefCount is dispatching the dispose/cancel upstream to the original request, but is not decrementing the RefCount quickly enough, so that the 2nd request is coming in as if it is refCount=2, even though it has already terminated the upstream (and therefore should have already become refCount=0 and the ConnectableObservable should already have been disconnected).

In our case (Android), we had 2 separate Fragments being added approximately simultaneously. Fragment 1 makes a request for configuration (which is implemented with `share()` and intended to be shared across multiple requests for the same configs), and then shortly after also disposes that request (this was a mistake, and that's what has been fixed on our end -- short version is, we were using `CompositeDisposable.clear()`, but we should have only been disposing a _single_ unrelated observable).  Fragment 2 also makes the same request for configurations.

As a result of CompositeDisposable.clear(), Fragment 1's config request got disposed, and rather than allowing Fragment 2's request to continue operating due to the refCount, Fragment 2 only receives the OkHttp InterruptedIOException from the canceled operation and never receives a completed successful response. =||= share() is generally tricky, even without this bug, because people have a sense of it staying alive a bit longer and also receiving onNext events in time, which is not guaranteed with it. You could try using `replay(1).refCount()` or `publish().refCount(1, TimeUnit.SECONDS)` to give it some wiggle room until I find a way to fix this bug (my attempts this far have broken other unit tests so it may take a few days). =||= This is a tough one.

What happens is that the termination happens when a new observer subscribes, which makes `refCount=2` but the new observer gets assigned to a fresh publishing instance, ready to be connected. However, the refCount's termination management sees `refCount=2` and won't reset nor will it reconnect. If it reset though, that would clear the new observer and still result in a hang too.

This could be resolved if a late observer wasn't assigned to a fresh publishing instance, but receive the terminal signal instead (thus making refCount get down to zero and reset/reconnect). Unfortunately, this is a behavior change that, in addition, requires API change to allow manual resetting for those who work with `ConnectableObservable` directly. I already planned to resolve the underlying issue in 3.x: #5628

I'll keep thinking about this problem, until then, you could use the workarounds above, or use `timeout().retry()` to detect the hang and make it cancel/reconnect. =||= I tried using `.retry()` and the problem with that seemed to be that the `.share()` caused it to keep the existing InterruptedIOException error, so it just kept re-emitting the same error on each retry.

I don't think I tried `.replay(1).refCount()`, but that is worth testing - thanks!  I thought I was avoiding replay for some some reason, but now I can't think of any reason why I would need to avoid that... =||= "2.x: Fix publish().refCount() hang due to race"This PR adds a workaround implementation to the `publish()` implementations `ObservablePublish` and `FlowablePublish` so that when used with `refCount`, a connection-disconnection race won't leave consumers hanging in certain situations.

This was necessary to avoid the behavior change with the classic implementations used without `refCount`. In the alternate implementation, when the connectable terminates, the terminal event is signaled to late consumers until the operator is reset via the `ResettableConnectable`.

The `refCount` operator detects the classic implementations through the `ObservablePublishClassic` and `FlowablePublishClassic` internal interfaces and replaces them via the new implementations. The introduction of these interfaces were necessary to support 3rd party hooks that would intercept the classic connectable implementations via an arbitrary class which `refCount` wouldn't recognize or replace.

Fixes #6501 "David Karnokakarnokd06/20/19, 07:30:05 PM
5654.065143.x: Proposal: `ObservableConverter` interface and friends"For the `compose()` operators, `ObservableTransformer` was introduced to allow for classes to implement multiple transformer interfaces for composite implementations. I'd like to propose doing the same for the `to()` operator by introducing `ObservableConverter` (and corresponding ones for others).  This would allow for composite converters as well.

If you're open to this, I can contribute a PR!""That would break binary compatibility and otherwise `to(Function<? super Observable<T>, R>)` isn't that much of a type mess as `lift` or `compose` is. =||= This would be an alternative to, not a replacement for. I'm not sure what type mess means, the larger issue is that you can't have something implement `Function` multiple times with different generics =||= A `to` overload will lead to type ambiguity when one writes `to(f -> somefunc(f))`. =||= ah, good point. Would you be against a different name? Like `convertTo`? Or would this be more of an RxJava 3.0 discussion? =||= Yes, 3.x API cleanup can include this type of change. I otherwise always have separate converters for the base reactive classes.

/cc @JakeWharton, @vanniktech, @artem-zinnatullin  =||= I remember we had the discussion about `to()` already in 2.0.0-RC days. The closed I could find is - https://github.com/ReactiveX/RxJava/pull/4672 - if I recall correctly it was decided to not change the `to` operator. 

I don't have a strong opinion about changing it in 3.x though. =||= In general, I'd like RxJava to have as less interfaces as possible, especially if generic ones like `Function` can be used instead.

But Java limitations kinda force us to have them here. So I'm ok if 3.x will have dedicated `*Converter` interfaces. =||= Retagged as 3.x. =||= I'd like to lean on this for a 2.x consideration again, seeing as 3.x discussion seems to be settling on ""not necessary anytime soon"". 

Proposal, to protect against ambiguity, would be to add a new `convert` or `convertTo` method, which retains the semantics while introducing the new interfaces to allow for composition.

The old `to()` methods could optionally be deprecated too to avoid confusion =||= Project reactor chose the `as()` [naming](https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#as-java.util.function.Function-). It's short, which I like, and could be added without deprecating `to`.

```java
public <R> R as(ObservableConverter<T, R> converter);
public <R> R as(FlowableConverter<T, R> converter);
public <R> R as(SingleConverter<T, R> converter);
public <R> R as(MaybeConverter<T, R> converter);
public <R> R as(CompletableConverter<R> converter);
``` =||= I like it! Should I send a PR? =||= Sure. =||= Done in #5729 =||= This has to be still resolved in 3.x where I suggest having only `to()` with the custom interfaces just introduced. =||= Sounds good =||= Hi guys, I have a concern which related to this ticket. Here is my code: 

 ```
    inline fun <reified T> withSchedulers(subscribeOn: Scheduler, observeOn: Scheduler): T {
        when (T::class) {
            FlowableTransformer::class -> return FlowableTransformer<Any, Any> {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
            ObservableTransformer::class -> return ObservableTransformer<Any, Any> {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
            SingleTransformer::class -> return SingleTransformer<Any, Any> {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
            CompletableTransformer::class -> return CompletableTransformer {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
            MaybeTransformer::class -> return MaybeTransformer<Any, Any> {
                it.subscribeOn(subscribeOn).observeOn(observeOn)
            } as T
        }
        throw IllegalArgumentException(""not a valid Transformer type"")
    }
```

Are there any ways to reduce the boilerplate code? or any better approaches to achieve this? Or just write 5 functions for 5 types, something like `to` operator above?

Thanks.

 =||= Closing via #6514. =||= "3.x: Merge as() into to()"In 2.x, the `to()` operator used the generic `Function` to allow assembly-time conversion of flows into arbitrary types. The drawback of this approach was that each base reactive type had the same `Function` interface in their method signature, thus it was impossible to implement multiple converters for different reactive types within the same class. To work around this issue, the `as` operator and `XConverter` interfaces have been introduced in 2.x, which interfaces are distinct and can be implemented on the same class. Changing the signature of `to` in 2.x was not possible due to the pledged binary compatibility of the library.

From 3.x, the `as()` methods have been removed and the `to()` methods now each work with their respective `XConverer` interfaces:

- `Flowable.to(Function<Flowable<T>, R>)` is now `Flowable.to(FlowableConverter<T, R>)`
- `Observable.to(Function<Observable<T>, R>)` is now `Observable.to(ObservableConverter<T, R>)`
- `Maybe.to(Function<Flowable<T>, R>)` is now `Maybe.to(MaybeConverter<T, R>)`
- `Single.to(Function<Flowable<T>, R>)` is now `Maybe.to(SingleConverter<T, R>)`
- `Completable.to(Function<Completable, R>)` is now `Completable.to(CompletableConverter<R>)`
- `ParallelFlowable.to(Function<ParallelFlowable<T>, R)` is now `ParallelFlowable.to(ParallelFlowableConverter<T, R>)`

If one was using these methods with a lambda expression, only a recompilation is needed:

```java
// before
source.to(flowable -> flowable.blockingFirst());

// after
source.to(flowable -> flowable.blockingFirst());
```

If one was implementing a Function interface (typically anonymously), the interface type, type arguments and the `throws` clause have to be adjusted

```java
// before
source.to(new Function<Flowable<Integer>, Integer>() {
    @Override
    public Integer apply(Flowable<Integer> t) throws Exception {
        return t.blockingFirst();
    }
});

// after
source.to(new FlowableConverter<Integer, Integer>() {
    @Override
    public Integer apply(Flowable<Integer> t) {
        return t.blockingFirst();
    }
});
```

Resolves: #5654"David Karnokakarnokd06/19/19, 08:50:05 AM
5628.065193.x: ConnectableObservable redesign"### Problem

The `CompletableObservable` (and `CompletableFlowable`) implementors, `publish` and `replay` in RxJava 1.x and 2.x are inconsistent in their terminal behavior.

When `publish` terminates, its `CompletableObservable` will appear as fresh to the new subscribers. This has the drawback that such subscribers may hang as `connect` may be never called again.

In contrast, `replay` will stay terminated along with any cached items and new subscribers can still get those events. The drawback here is that a new `connect` will clear the internal storage and start the consumption of the main source while not giving any chance to subscribers to prepare and receive that stream of events from the start if the replay is bounded.

Dealing with this inconsistency currently requires `refCount` to trigger a reset on an unofficial channel: casting the `CompletableObserver` into `Disposable` if possible and disposing it when the count reaches zero again.

### Suggested solution

I suggest changing the API to include an explicit `reset()` method and changing the logic to have 3 states:

**fresh** --> `connect()` --> **running** --> `onComplete()`/`onError()` --> **terminated** --> `reset()` --> **fresh**

and possibly:

**terminated** --> `connect()` --> **running**

In the **fresh** state, consumers can pile up and be ready to receive events. An atomic state change to **running** will begin streaming events until a terminal event is reached, at which point the state atomically changes to **terminated**. Consumers subscribing in this state will always receive the terminal event, and in case of `replay`, the cached items as well.

A call to `reset()` will clear the internal storage of the `ConnectableObservable` and start out as **fresh** again, allowing new consumers to gather around and get all fresh events from the beginning.

It is possible to support the call to `connect` in the **terminated** state to skip the **fresh** state. Preventing this transition, however, may be more involved as `connect()` should communicate this to be illegal transition someway as well as the need for a soft way for checking if `connect` is to succeed or not. Note that calling `connect` on a running `ConnectableObservable` is a no-op in 1.x and 2.x.""Hey @akarnokd. When are you planning to start working on that? I believe we may collaborate on that so I will port the same design to Reactor 3?

cc/ @smaldini =||= Closing via #6519 =||= "3.x: ConnectableFlowable/ConnetableObservabe redesign"This PR changes the connectable API to have a specific `reset` method to reset a terminated connectable source as part of the official API.

In 2.x, when `publish()` terminated, it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call `connect()` again (see #6501). However, `replay()` did not reset itself, thus late consumers got the cached events, however, a reconnect started the sequence and new consumers may have missed items.

In 3.x, this two corner cases have been fixed by the introduction of `reset()`. Both `publish` and `replay` now remain in their terminated state until `reset` is called. If the connection is disposed, it will automatically reset their state just like before. The state transitions are as follows:

1. **fresh** -> `connect()` -> **running** -> `onComplete()`/`onError()` -> **terminated** -> `reset()` -> **fresh**
2. **fresh** -> `connect()` -> **running** -> `dispose()` -> **fresh**
3. **fresh** -> `connect()` -> **running** -> `onComplete()`/`onError()` -> **terminated** -> `dispose()` -> **fresh**
4. **fresh** -> `connect()` -> **running** -> `onComplete()`/`onError()` -> **terminated** -> `connect()` -> **running**

This does resolve the race condition with `publish().refCount()` described in #6501.

In addition, there are some changes to `Flowable.publish()`'s behavior:

It no longer keeps consuming the upstream if there are no subscribers. This implies if the source terminates while there are unconsumed items in the internal buffer, those will be available for observation.
*I have no strong preference on this property and in comparison, `Observable.publish` drops items because there is no backpressure buffer in its implementation.*

Upstream errors are not reported to the `RxJavaPlugins.onError` handler when if there are no subscribers but have to be observed via a subscriber.
*Because terminal events are available until `reset` now, we can't know really if there is going to be a subscriber or not. However, it might be possible to detect the no-consumer case upon an error and still report it when `reset` or `dispose` is called.*

Resolves #5628
Resolves #5899"David Karnokakarnokd06/20/19, 06:18:07 AM
5899.065193.x: Flowable.publish() should not drop items if there are no consumers"Unlike `Observable.publish()`, the `Flowable.publish()` has an internal queue and fetches data from upstream based on consumption. For historical reasons, the 2.x implementation drops items when there are no consumers, which can lead to unnecessary dataloss when switching between consumers on an item boundary.

I propose changing the operator in 3.x to not drop items when there are no consumers. The 2.x behavior can be achieved via an additional unbounded consumer which stays subscribed until the operator completes."">I propose changing the operator in 3.x to not drop items when there are no consumers.

Does this only apply after the first subscription has happened? =||= If there are no subscribers, don't consume the queue. The [2.x](https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/internal/operators/flowable/FlowablePublish.java#L474) version has dedicated logic to keep consuming the queue. =||= Closing via #6519. =||= "3.x: ConnectableFlowable/ConnetableObservabe redesign"This PR changes the connectable API to have a specific `reset` method to reset a terminated connectable source as part of the official API.

In 2.x, when `publish()` terminated, it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call `connect()` again (see #6501). However, `replay()` did not reset itself, thus late consumers got the cached events, however, a reconnect started the sequence and new consumers may have missed items.

In 3.x, this two corner cases have been fixed by the introduction of `reset()`. Both `publish` and `replay` now remain in their terminated state until `reset` is called. If the connection is disposed, it will automatically reset their state just like before. The state transitions are as follows:

1. **fresh** -> `connect()` -> **running** -> `onComplete()`/`onError()` -> **terminated** -> `reset()` -> **fresh**
2. **fresh** -> `connect()` -> **running** -> `dispose()` -> **fresh**
3. **fresh** -> `connect()` -> **running** -> `onComplete()`/`onError()` -> **terminated** -> `dispose()` -> **fresh**
4. **fresh** -> `connect()` -> **running** -> `onComplete()`/`onError()` -> **terminated** -> `connect()` -> **running**

This does resolve the race condition with `publish().refCount()` described in #6501.

In addition, there are some changes to `Flowable.publish()`'s behavior:

It no longer keeps consuming the upstream if there are no subscribers. This implies if the source terminates while there are unconsumed items in the internal buffer, those will be available for observation.
*I have no strong preference on this property and in comparison, `Observable.publish` drops items because there is no backpressure buffer in its implementation.*

Upstream errors are not reported to the `RxJavaPlugins.onError` handler when if there are no subscribers but have to be observed via a subscriber.
*Because terminal events are available until `reset` now, we can't know really if there is going to be a subscriber or not. However, it might be possible to detect the no-consumer case upon an error and still report it when `reset` or `dispose` is called.*

Resolves #5628
Resolves #5899"David Karnokakarnokd06/20/19, 06:18:07 AM
6520.06522Issus about Flowable concatMapDelayError"RxJava version 2.2.9.

I feel doubt about `Flowable#concatMapDelayError`, when I use `Flowable#fromCallable`

The following code:
```java
   Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {
          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {
            return Flowable.fromCallable(new Callable<Integer>() {
              @Override public Integer call() throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException(""test null exp"");
                }
                return integer;
              }
            });
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, ""test-->complete-"" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, ""test-->error-"" + throwable);
          }
        });

```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->error-java.lang.NullPointerException: test null exp
```


It do not delay error. But I use `Observable` is success delayed the error, And I use `Flowable#create` is success delayed the error.

The following code:
```java
    Observable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Observable<Integer>>() {
          @Override public Observable<Integer> apply(final Integer integer) throws Exception {
            return Observable.fromCallable(new Callable<Integer>() {
              @Override public Integer call() throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException(""test null exp"");
                }
                return integer;
              }
            });
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, ""test-->complete-"" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, ""test-->error-"" + throwable);
          }
        });
```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->complete-23
  test-->complete-32
  test-->error-io.reactivex.exceptions.CompositeException: 4 exceptions occurred. 
```

The following code:
```java
    Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32)
        .concatMapDelayError(new Function<Integer, Flowable<Integer>>() {
          @Override public Flowable<Integer> apply(final Integer integer) throws Exception {
            return Flowable.create(new FlowableOnSubscribe<Integer>() {
              @Override public void subscribe(FlowableEmitter<Integer> emitter) throws Exception {
                if (integer >= 100) {
                  throw new NullPointerException(""test null exp"");
                }
                emitter.onNext(integer);
                emitter.onComplete();
              }
            }, BackpressureStrategy.BUFFER);
          }
        })
        .subscribe(new Consumer<Integer>() {
          @Override public void accept(Integer integer) throws Exception {
            Log.e(TAG, ""test-->complete-"" + integer);
          }
        }, new Consumer<Throwable>() {
          @Override public void accept(Throwable throwable) throws Exception {
            Log.e(TAG, ""test-->error-"" + throwable);
          }
        });
```

The following output:
```
  test-->complete-1
  test-->complete-2
  test-->complete-3
  test-->complete-23
  test-->complete-32
  test-->error-io.reactivex.exceptions.CompositeException: 4 exceptions occurred. 
```"Thanks for reporting. This is a bug in the operator cutting short because of internal shortcuts not considering the error-delay property. I'll post a fix shortly. =||= Thanks, appreciate it! =||= 2.x: Fix concatMapDelayError not continuing on fused inner source crash"The `Callable` fused path didn't consider the error-delay settings and cut the sequence short.

Fixes: #6520 "David Karnokakarnokd06/20/19, 12:34:48 PM
6153.065263.x: review features of the test consumers"- Review available assertions.
- Remove redundant assertions.
- Resolve ambiguities about the assertions.
- Rething naming of assertions.""The more I'm using it the more I feel like `assertValues` should be removed. It only asserts half of the things. Using `assertValuesOnly`, `assertResult`, or the overload with the error matcher would be more pragmatic. 

If the main code gets changed and suddenly the source completes the unit test would not break with `assertValues`. Often times distinguishing between a completing and not completing Observable / Flowable really does matter. =||= Maybe I'm being naive, but for most of my more advanced test cases I end up getting the `onNext` events and asserting on them directly. I have never encountered a case where `assertValues` was useful.

My understanding is that `assertCompleted`, `assertValueCount` and the likes are enough for simple test cases, and clients get little value from `assertValues` for more complex cases. =||= Please don't forget that the test consumer is there to test RxJava itself, not just your code out there. =||= But if those requirements differ then the APIs should be split. =||= +1, I don't really get why methods used to test RxJava internals should be exposed to clients =||= The Java language doesn't allow hiding methods from non-project usages. =||= `.to(test())` isn't that much longer than `.test()`. =||= Type inference may not work most of the time, requiring a full expression with type arguments for that test. =||= And thankfully as the library we bear that extra burden so that our consumers don't have to! =||= I've composed a questionare about the test support:

https://docs.google.com/forms/d/1kiuYMVxbDjsPhIjWMG4V4aiHUevhCI9BzOmlRd-OWhs

Let me know what you think and if adequate, I'll tweet it out. =||= Maybe reduce the number of options one can give to each operator or use a better control UX-wise. =||= I've tried a matrix-choice control but Google Docs doesn't allow me to change the width of the form thus it introduced a horizontal scrollbar you'd have to scroll left-right all the time. The choices should also help with the [original tasks](https://github.com/ReactiveX/RxJava/issues/6153#issue-349411648), for example, which operators should be renamed. =||= Good questionare 👍 

I'm a bit afraid though, that because many don't understand the difference between some of the assertion methods in the first place, questionare results might be misleading.

Hopefully people will look into javadocs, maybe questionare should have links to each method/type javadoc in case people don't have IDE/sources at hand. =||= There is the implicit assumption that people know which methods they have used and if the others don't ring a bell, they will simply chose the remove/not-using/no opinion. =||= Updated the form with links to each method's JavaDoc. =||= My issue is that the APIs don't consume events as you assert so you constantly have to supply all events or awkwardly remove events separate from assertion. I always end up writing my own test observer as a result. =||= Reactor uses a different approach: [StepVerifier](https://projectreactor.io/docs/test/release/api/reactor/test/StepVerifier.html). Note however that there were complications: expressing testing events over time, synchronizing through a test scheduler, etc. =||= I wonder if content-assist filters in one's IDE would help with the method ""bloat"" experienced with RxJava? =||= I’ll express the feedback I’ve collected browsing through the project I’m working on (and I’m too lazy to describe all assertions available). We have something like 15K+ tests, a lot of them include RxJava checks.

We have a specific rule to generally avoid termination events, especially errors — basically we treat them as _failures_, i. e. _something went horribly wrong and someone produced `onError`_. That said, we don’t use much.

* Most of the time we create `TestObserver` explicitly, subscribe and work with it directly.
* The `test()` method is rarely used since we have complex multi-step checks (hey BDD) and it does not scale for such situations.
* The most common assertion we use is `assertValuesOnly` and there is an ongoing push to replace every `assertValue` with it since it provides more checks under the hood. And actually something like `assertValueOnly` would be a better fit for us.
* Next go `assertResult` and `assertEmpty` — again, both of them are better checks than `assertValue` and `assertNoValues`.

Regarding what can be done better — we have a custom _cleanup_ extension that clears current values in `TestObserver`. It allows us to write more lean tests:

```kotlin
context(""event"") {
    it(""emits value A"") { valueObserver.assertValuesOnly(""A"") }

    context(""different event"") {
        beforeEachTest { valueObserver.clear() }
        
        it(""emits value B"") { valueObserver.assertValuesOnly(""B"") }
        // Without clear() above we need to check both values, i. e. assertValuesOnly(""A"", ""B"")
    }
}
```
It is similar to `Mockito.clearInvocations()` and can be useful, but we are fine with using our own thing.

I wouldn’t mind moving `TestScheduler`, `TestObserver` and friends into a separate artifact. Pretty sure we can live without the `Observable.test()` method.

Otherwise we are satisfied with the current set of asserts. The naming is a bit confusing and it leads to discoverability issues — I had to explain the difference between `assertValue` and `assertResult` a couple of times. Maybe something like `assertOnNext`, `assertOnNextOnly` can be a better fit. Also, think about removing complex checks like `assertValuesOnly` altogether since it forces you to create smart naming which combines multiple actions. `assertResult` is understandable, but I think there is no _result_ term in reactive world. =||= `assertValues` is extremely helpful and I would prefer to have it in future releases as well. =||= The results of the questionare (34 responses). **Bold** indicates the dominant factor for the proposed action to take.

Question | Answers | Action
-------|------------|------
Should a test() operator be available? | **Yes (91.2%)**, No (8.8%) | Keep
Should the TestSubscriber/TestObserver be available publicly | **Yes, both (79.4%)**, No (8.8%), TS only (2.9%), TO only (8.8%) | Keep both
Should RxJava support testing flows out of box | **Yes (100%)**, No (0%) | Keep supporting
Opinions about test methods | ... | ...
`  assertComplete` | **Keep: using it (41.2%), Keep: using it a lot (11.8%)**, Can live without (14.7%), Confusing: rename it (2.9%), Not using can stay (20.6%), Redundant: remove it (0%), No need: remove it (0%), No opinion (5.9%) | Keep
`  assertEmpty` | **Keep: using it (35.3%), Keep: using it a lot (11.8%)**, Can live without (14.7%), Confusing: rename it (11.8%), Not using can stay (20.6%), Redundant: remove it (0%), No need: remove it (0%), No opinion (5.9%) | Keep & Rename
`  assertError(Class)` | **Keep: using it (32.4%), Keep: using it a lot (14.7%)**, Can live without (14.7%), Confusing: rename it (0%), Not using can stay (20.6%), Redundant: remove it (2.9%), No need: remove it (2.9%), No opinion (11.8%) | Keep
`  assertError(Predicate)` | **Keep: using it (38.2%), Keep: using it a lot (8.8%)**, Can live without (8.8%), Confusing: rename it (0%), Not using can stay (14.7%), Redundant: remove it (2.9%), No need: remove it (2.9%), No opinion (23.5%) | Keep
`  assertError(Throwable)` | **Keep: using it (41.2%), Keep: using it a lot (5.9%)**, Can live without (14.7%), Confusing: rename it (0%), Not using can stay (8.8%), Redundant: remove it (11.8%), No need: remove it (2.9%), No opinion (14.7%) | Keep
`  assertErrorMessage` | Keep: using it (2.9%), Keep: using it a lot (2.9%), Can live without (14.7%), Confusing: rename it (0%), **Not using can stay (44.1%), Redundant: remove it (8.8%), No need: remove it (14.7%)**, No opinion (11.8%) | Remove
`  assertFailure(Class, T...)` | **Keep: using it (5.9%), Keep: using it a lot (5.9%)**, Can live without (2.9%), Confusing: rename it (8.8%), **Not using can stay (35.3%)**, Redundant: remove it (5.9%), No need: remove it (5.9%), No opinion (29.4%) | Keep & Rename
`  assertFailure(Predicate, T...)` | Keep: using it (5.9%), Keep: using it a lot (2.9%), Can live without (2.9%), Confusing: rename it (8.8%), **Not using can stay (38.2%), Redundant: remove it (5.9%), No need: remove it (5.9%), No opinion (29.4%)** | Remove
`  assertFailureAndMessage` | Keep: using it (5.9%), Keep: using it a lot (5.9%), Can live without (5.9%), Confusing: rename it (2.9%), **Not using can stay (29.4%), Redundant: remove it (8.8%), No need: remove it (17.6%)**, No opinion (23.5%) | Remove
`  assertNever(Predicate)` | Keep: using it (8.9%), Keep: using it a lot (5.9%), Can live without (0%), Confusing: rename it (8.8%), **Not using can stay (41.2%), Redundant: remove it (2.9%), No need: remove it (11.8%)**, No opinion (20.6%) | Remove
`  assertNever(T)` | Keep: using it (17.6%), Keep: using it a lot (2.9%), Can live without (8.8%), Confusing: rename it (8.8%), **Not using can stay (32.4%), Redundant: remove it (5.9%), No need: remove it (8.8%)**, No opinion (14.7%) | Remove
`  assertNoErrors` | **Keep: using it (29.4%), Keep: using it a lot (35.3%)**, Can live without (8.8%), Confusing: rename it (2.9%), Not using can stay (5.9%), Redundant: remove it (0%), No need: remove it (5.9%), No opinion (11.8%) | Keep
`  assertNotComplete` | **Keep: using it (32.4%), Keep: using it a lot (2.9%)**, Can live without (11.8%), Confusing: rename it (5.9%), Not using can stay (26.5%), Redundant: remove it (0%), No need: remove it (5.9%), No opinion (14.7%) | Keep
`  assertNoTimeout` | Keep: using it (2.9%), Keep: using it a lot (0%), Can live without (14.7%), Confusing: rename it (0%), **Not using can stay (38.2%)**, Redundant: remove it (5.9%), No need: remove it (11.8%), No opinion (26.5%) | Remove
`  assertNotSubscribed` | Keep: using it (5.9%), Keep: using it a lot (2.9%), Can live without (14.7%), Confusing: rename it (0%), **Not using can stay (32.4%)**, Redundant: remove it (0%), No need: remove it (8.8%), **No opinion (35.3%)** | Remove
`  assertNotTerminated` | Keep: using it (8.8%), Keep: using it a lot (2.9%), Can live without (14.7%), Confusing: rename it (0%), **Not using can stay (29.7%)**, Redundant: remove it (5.9%), No need: remove it (11.8%), **No opinion (26.5%)** | Remove
`  assertNoValues` | **Keep: using it (41.2%), Keep: using it a lot (14.7%)**, Can live without (11.8%), Confusing: rename it (2.9%), Not using can stay (11.8%), Redundant: remove it (0%), No need: remove it (5.9%), No opinion (11.8%) | Keep
`  assertResult` | **Keep: using it (14.7%), Keep: using it a lot (29.4%)**, Can live without (0%), Confusing: rename it (2.9%), Not using can stay (20.6%), Redundant: remove it (8.8%), No need: remove it (2.9%), No opinion (20.6%) | Keep
`  assertSubscribed` | Keep: using it (2.9%), Keep: using it a lot (2.9%), Can live without (11.8%), Confusing: rename it (0%), **Not using can stay (32.4%), Redundant: remove it (5.9%), No need: remove it (14.7%), No opinion (29.4%)** | Remove
`  assertTerminated` | Keep: using it (14.7%), Keep: using it a lot (0%), Can live without (5.9%), Confusing: rename it (0%), **Not using can stay (26.5%), Redundant: remove it (17.6%), No need: remove it (11.8%)**, No opinion (23.5%) | Remove
`  assertTimeout` | Keep: using it (5.9%), Keep: using it a lot (5.9%), Can live without (5.9%), Confusing: rename it (2.9%), **Not using can stay (44.1%), Redundant: remove it (5.9%), No need: remove it (8.8%)**, No opinion (26.5%) | Remove
`  assertValue(Predicate)` | **Keep: using it (29.4%), Keep: using it a lot (20.6%)**, Can live without (5.9%), Confusing: rename it (2.9%), Not using can stay (17.6%), Redundant: remove it (5.9%), No need: remove it (2.9%), No opinion (14.7%) | Keep
`  assertValue(T)` | **Keep: using it (17.6%), Keep: using it a lot (38.2%)**, Can live without (5.9%), Confusing: rename it (2.9%), Not using can stay (2.9%), Redundant: remove it (5.9%), No need: remove it (2.9%), No opinion (20.6%) | Keep
`  assertValueAt(int, Predicate)` | **Keep: using it (14.7%), Keep: using it a lot (17.6%)**, Can live without (23.5%), Confusing: rename it (2.9%), **Not using can stay (17.6%)**, Redundant: remove it (5.9%), No need: remove it (8.8%), No opinion (20.6%) | Keep
`  assertValueAt(int, T)` | **Keep: using it (14.7%), Keep: using it a lot (17.6%)**, Can live without (8.8%), Confusing: rename it (2.9%), **Not using can stay (20.6%)**, Redundant: remove it (8.8%), No need: remove it (11.8%), No opinion (14.7%) | Keep
`  assertValueCount` | **Keep: using it (17.6%), Keep: using it a lot (38.2%)**, Can live without (5.9%), Confusing: rename it (2.9%), **Not using can stay (2.9%)**, Redundant: remove it (5.9%), No need: remove it (5.9%), No opinion (20.6%) | Keep
`  assertValueSequence` | **Keep: using it (8.8%), Keep: using it a lot (11.8%)**, Can live without (8.8%), Confusing: rename it (5.9%), **Not using can stay (23.5%)**, Redundant: remove it (8.8%), No need: remove it (5.9%), No opinion (26.5%) | Keep
`  assertValueSequenceOnly` | Keep: using it (5.9%), Keep: using it a lot (5.9%), Can live without (5.9%), Confusing: rename it (8.8%), **Not using can stay (17.6%), Redundant: remove it (14.7%), No need: remove it (2.9%), No opinion (38.2%)** | Remove
`  assertValueSet` | Keep: using it (2.9%), Keep: using it a lot (5.9%), Can live without (8.8%), Confusing: rename it (5.9%), **Not using can stay (23.5%), Redundant: remove it (11.8%), No need: remove it (8.8%), No opinion (32.4%)** | Remove
`  assertValueSetOnly` | Keep: using it (0%), Keep: using it a lot (8.8%), Can live without (2.9%), Confusing: rename it (8.8%), **Not using can stay (23.5%), Redundant: remove it (11.8%), No need: remove it (5.9%), No opinion (41.2%)** | Remove
`  assertValuesOnly` | **Keep: using it (8.8%), Keep: using it a lot (11.8%)**, Can live without (5.9%), Confusing: rename it (8.8%), **Not using can stay (17.6%)**, Redundant: remove it (8.8%), No need: remove it (8.8%), No opinion (32.4%) | Keep & rename
`  await` | **Keep: using it (23.5%), Keep: using it a lot (8.8%)**, Can live without (8.8%), Confusing: rename it (2.9%), Not using can stay (11.8%), Redundant: remove it (2.9%), No need: remove it (17.6%), No opinion (23.5%) | Keep
`  await(long, TimeUnit)` | **Keep: using it (26.5%), Keep: using it a lot (8.8%)**, Can live without (5.9%), Confusing: rename it (2.9%), Not using can stay (17.6%), Redundant: remove it (2.9%), No need: remove it (11.8%), No opinion (26.5%) | Keep
`  awaitCount(int)` | **Keep: using it (26.5%), Keep: using it a lot (2.9%)**, Can live without (2.9%), Confusing: rename it (0%), Not using can stay (14.7%), Redundant: remove it (5.9%), No need: remove it (17.6%), No opinion (29.4%) | Keep
`  awaitCount(int, Runnable)` | Keep: using it (5.9%), Keep: using it a lot (2.9%), Can live without (0%), Confusing: rename it (2.9%), **Not using can stay (29.4%), Redundant: remove it (5.9%), No need: remove it (20.6%), No opinion (32.4%)** | Remove
`  awaitCount(int, Runnable, long)` | Keep: using it (5.9%), Keep: using it a lot (2.9%), Can live without (0%), Confusing: rename it (2.9%), **Not using can stay (26.5%), Redundant: remove it (2.9%), No need: remove it (20.6%), No opinion (38.2%)** | Remove
`  awaitDone` | **Keep: using it (5.9%), Keep: using it a lot (5.9%)**, Can live without (5.9%), Confusing: rename it (5.9%), Not using can stay (26.5%), Redundant: remove it (5.9%), No need: remove it (14.7%), No opinion (29.4%) | Keep & rename
`  awaitTerminalEvent` | Keep: using it (8.8%), Keep: using it a lot (5.9%), Can live without (20.6%), Confusing: rename it (0%), **Not using can stay (17.6%), Redundant: remove it (2.9%), No need: remove it (11.8%), No opinion (32.4%)** | Remove
`  awaitTerminalEvent(long TimeUnit)` | Keep: using it (2.9%), Keep: using it a lot (2.9%), Can live without (11.8%), Confusing: rename it (0%), **Not using can stay (26.5%), Redundant: remove it (5.9%), No need: remove it (11.8%), No opinion (38.2%)** | Remove
`  clearTimeout` | Keep: using it (2.9%), Keep: using it a lot (2.9%), Can live without (0%), Confusing: rename it (5.9%), **Not using can stay (29.4%)**, Redundant: remove it (0%), **No need: remove it (11.8%), No opinion (47.1%)** | Remove
`  completions` | Keep: using it (2.9%), Keep: using it a lot (0%), Can live without (2.9%), Confusing: rename it (5.9%), **Not using can stay (20.6%), Redundant: remove it (2.9%), No need: remove it (11.8%), No opinion (52.9%)** | Remove
`  errorCount` | Keep: using it (2.9%), Keep: using it a lot (2.9%), Can live without (2.9%), Confusing: rename it (0%), **Not using can stay (23.5%), Redundant: remove it (2.9%), No need: remove it (14.7%), No opinion (50%)** | Remove
`  errors` | Keep: using it (2.9%), Keep: using it a lot (5.9%), Can live without (5.9%), Confusing: rename it (2.9%), **Not using can stay (20.6%)**, Redundant: remove it (0%), **No need: remove it (14.7%), No opinion (47.1%)** | Remove
`  getEvents` | Keep: using it (5.9%), Keep: using it a lot (5.9%), Can live without (8.8%), Confusing: rename it (2.9%), **Not using can stay (14.7%), Redundant: remove it (8.8%), No need: remove it (8.8%), No opinion (44.1%)** | Remove
`  isTerminated` | Keep: using it (8.8%), Keep: using it a lot (2.9%), Can live without (11.8%), Confusing: rename it (0%), **Not using can stay (23.5%), Redundant: remove it (2.9%), No need: remove it (8.8%), No opinion (41.2%)** | Remove
`  isTimeout` | Keep: using it (2.9%), Keep: using it a lot (0%), Can live without (5.9%), Confusing: rename it (0%), **Not using can stay (26.5%), Redundant: remove it (8.8%), No need: remove it (11.8%), No opinion (44.1%)** | Remove
`  lastThread` | Keep: using it (5.9%), Keep: using it a lot (0%), Can live without (2.9%), Confusing: rename it (0%), **Not using can stay (17.6%)**, Redundant: remove it (0%), **No need: remove it (17.6%), No opinion (55.9%)** | Remove
`  valueCount` | Keep: using it (14.7%), Keep: using it a lot (5.9%), Can live without (11.8%), Confusing: rename it (0%), **Not using can stay (8.8%), Redundant: remove it (17.6%), No need: remove it (8.8%), No opinion (32.4%)** | Remove
`  values` | **Keep: using it (11.8%), Keep: using it a lot (32.4%)**, Can live without (14.7%), Confusing: rename it (0%), Not using can stay (8.8%), Redundant: remove it (5.9%), No need: remove it (8.8%), No opinion (17.6%) | Keep
`  cancel` | **Keep: using it (14.7%), Keep: using it a lot (2.9%)**, Can live without (2.9%), Confusing: rename it (0%), Not using can stay (14.7%), Redundant: remove it (2.9%), No need: remove it (2.9%), No opinion (58.8%) | Keep<sup>1</sup>
`  dispose` | **Keep: using it (23.5%), Keep: using it a lot (14.7%)**, Can live without (2.9%), Confusing: rename it (0%), Not using can stay (8.8%), Redundant: remove it (0%), No need: remove it (0%), No opinion (50%) | Keep<sup>2</sup>
`  isCancelled` | **Keep: using it (11.8%), Keep: using it a lot (2.9%)**, Can live without (2.9%), Confusing: rename it (2.9%), **Not using can stay (23.5%)**, Redundant: remove it (2.9%), No need: remove it (2.9%), No opinion (50%) | Keep<sup>1</sup>
`  isDisposed` | **Keep: using it (20.6%), Keep: using it a lot (8.8%)**, Can live without (5.9%), Confusing: rename it (2.9%), **Not using can stay (14.7%)**, Redundant: remove it (0%), No need: remove it (2.9%), No opinion (44.1%) | Keep<sup>2</sup>
`  assertOf(TestSubscriber)` | Keep: using it (5.6%), Keep: using it a lot (8.8%), Can live without (0%), Confusing: rename it (2.9%), **Not using can stay (11.8%), Redundant: remove it (5.9%), No need: remove it (11.8%), No opinion (52.9%)** | Remove
`  assertOf(TestObserver)` | Keep: using it (5.6%), Keep: using it a lot (8.8%), Can live without (0%), Confusing: rename it (2.9%), **Not using can stay (11.8%), Redundant: remove it (5.9%), No need: remove it (8.8%), No opinion (55.9%)** | Remove
`  hasSubscription` | **Keep: using it (15.2%), Keep: using it a lot (2.9%)**, Can live without (9.1%), Confusing: rename it (2.9%), **Not using can stay (18.2%)**, Redundant: remove it (2.9%), No need: remove it (2.9%), No opinion (48.5%) | Keep

**From the additional comments**

- using mainly `values()`
- rename confusing methods (empty)
- provide additional specific test consumer types for base reactive types<sup>3</sup>
- focus on testing, provide docs about how to test
- likes the `test()` API's existence
- likes the test functionality but RxJava should ship the test support separately via helpers
- better AssertJ support via callback having all events provided as parameters

Methods used for testing mainly by RxJava will be moved to the test-only `TestHelper` class. Some removed features may require an RxJava internal subclass instead to access protected internal state.

**Remarks**

<sup>1, 2</sup> these are redundant, may remove `dispose` from `TestSubscriber` and remove `cancel` from `TestObserver`.
<sup>3</sup> would match the event terminology better (`assertSuccess`) but introduces redundancy. =||= Closing via #6526. =||= "3.x: Remove methods from test consumers, make internal versions"Remove methods from the standard test consumers based on feedback in [6153 comment](https://github.com/ReactiveX/RxJava/issues/6153#issuecomment-463184785).

Some test support has been moved into the `io.reactivex.testsupport` package in the form of `TestObserverEx` and `TestSubscriberEx`.

Resolves: #6153"David Karnokakarnokd06/20/19, 04:15:30 PM
6122.065303.x: Disambiguate startWith(T|Iterable<T>)?"We were using postfixes to avoid inference problems around operator methods (such as `fromIterable` vs `fromArray`) but there is at least one operator currently, `startWith`, that [may exhibit type ambiguity](https://twitter.com/HansWurst315/status/1024386078785105921). A dedicated postfixed name should resolve the issue, such as:

1. `startWith(T)` + `startWithIterable(Iterable<T>)`
2. `startWithItem(T)` + `startWith(Iterable<T>)` + remove `startWith(T)`
3. `startWithItem(T)` + `startWithIterable(Iterable<T>)` + remove `startWith(T)`.

As a preparation, we can deprecate `startWith(T)` within 2.2.x in case option 2 or 3 is chosen.""The same also happens with some `onError*` methods.

I'm more inclined towards option 3 but no strong opinion. =||= For 3.x I'm happy with 3 also. =||= Perhaps instead of `startWithItem` we use `startWithJust` to match our `just` usage? =||= That's just my two cents' worth I would opt for the option 3.

I think `startWithJust` could be confusing since other methods call `just` for example, `range` when the count value is one or `fromArray` when the length is one. =||= 3.x is now accepting PRs if somebody wants to tackle this. =||= Closing via #6530. =||= "3.x: disambiguate startWith+1 to startWithItem & startWithIterable"`startWith(T)` and `startWith(Iterable)` was causing some trouble with `startWith(Publisher)`. This PR will rename the former two.

The diagrams will be updated in a separate PR.

Resolves: #6122"David Karnokakarnokd06/21/19, 09:12:26 AM
6475.065322.x: BoundedReplayBuffer temporarily leaks memory"When using `Observable.replay(N)`, the `BoundedReplayBuffer` keeps up to `N+1` items in its buffer. When using `replay(1)` for example, it keeps a reference to the most recent item, but also the previous, stale item.

Take for example this trivial snippet of code that provides an available Android `View` as a stream:

```kotlin
val eventsSubject = BehaviorSubject.create<Event<View>>()
val view: Observable<Option<View>> = eventsSubject
    .map { event ->
        when(event) {
            is Attached<View> -> Option.just(event.view)
            is Detached -> Option.empty()
        }
    }
    .replay(1).refCount()
```

The `replay(1)` call suggests a single value is cached, but the implementation keeps a strong reference to the previous item as well. 
Since this happens as a hidden side effect and rather counter intuitively, it is easy to accidentally leak memory -- even when the client code seems to be careful about it. Especially with Android Views referencing Activity contexts this is problematic.

---

https://github.com/ReactiveX/RxJava/pull/5282 proposed a fix for this at the cost of an extra `Node` allocation, which turned out to be unwanted. 
The proposed alternative there refers to [RxJava2Extensions#cacheLast](https://github.com/akarnokd/RxJava2Extensions#flowabletransformerscachelast), but this only emits the _very last_ item, not intermediates.""This is a known limitation of the standard `replay`. Either you can use a `ReplaySubject` that exposes a [`cleanupBuffer()`](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/subjects/ReplaySubject.html#cleanupBuffer--) method or write a custom replay that does what #5282 proposed. The third option is to not cache things that are lifecycle sensitive. =||= Right, those options seem valid workarounds for now. 

I suppose the fact that this happens somewhat surprisingly and hidden in the implementation details makes it feel like it's a bug. Even when being careful and supposedly 'clearing the buffer' by propagating an empty object it still results in leakage. Without knowing that this happens it's easy to accidentally run into this problem and possibly never find out. =||= Item lifecycle is not part of the Reactive Streams model, thus the operator only guarantees one gets up to a number of items when subscribing to cold replay. People have been using LeakCanary to detect such cases and most likely reworked their flow to not use replay. =||= Seems absolutely fair :+1: The pattern above just really 'works well' to go with a 'streams all the way' flow, though I understand this may not be RxJava's responsibility.  =||= I plan to resolve this in 3.x via an extra operator parameter. =||= Closing via #6532 for 3.x. =||= "3.x: Add eager truncation to bounded replay() to avoid item retention"This PR adds the `eagerTruncate` option to the `replay` operator so that the `head` node will lose the item reference it holds upon truncation.

The bounded buffers in `replay` implement a linked list that when truncated, moves the head reference forward along the links atomically. This allows late consumers to pick up the head and follow the links between them to get items replayed. However, the truncation may happen concurrently with a consumer working on some prior nodes so if the truncation would `null` out the value, the consumer reaching the same node would see `null` as well and fail.

![image](https://user-images.githubusercontent.com/1269832/59920898-55c5a980-942c-11e9-8dc1-b9e07264a36f.png)

To avoid this type of retention, the head node has to be refreshed with a new node still pointing to the next node in the chain but without any value. 

![image](https://user-images.githubusercontent.com/1269832/59921066-dbe1f000-942c-11e9-92a9-d2e06f1839a0.png)

The reason this is not the default is that it requires an additional allocation for each new incoming value when the buffer is full, which would reduce performance in cases where the excess retention is not a problem.

Overloads to both the direct and function-variants of both `Flowable.replay()` and `Observable.replay()` have been added. To avoid too many overloads, only one extra overload has been added extending the signature of the longest parameterized method per each bounds mode (size, time, time+size).

Their unit test files have been cloned so that both the non-eager (original) behavior and the eager behavior is tested separately.

Fixes #6475"David Karnokakarnokd06/24/19, 07:30:33 AM
5646.065333.x: drop CHANGES.md"It has become somewhat of an inconvenience to update `CHANGES.md` before pasting in the release text into the GitHub's own release page, causing a full build before the release build just for that single file.

I don't remember exactly why `CHANGES.md` was introduced but my assumption is that searching inside it via CTRL+F is simpler than searching within the [Releases](https://github.com/ReactiveX/RxJava/releases) tab.

Options:

- Keep it.
- Drop it.
- Use a dedicated wiki page instead.""Yis! Keeping changelog file under version control always feelt wrong, releasing and versioning is much easier when it's decoupled from regular code history, branching and PRs routine.

Sometime ago we've decided to just put a [giant link to Releases page in changelog files](https://github.com/gojuno/koptional/blob/master/CHANGELOG.md).

I only see few non-major benefits of keeping changelog under version control:

1. Someone can submit a PR fixing small typos/etc, but then they have to be repeated for releases page
1. If for some reason we'll need to migrate git hosting to lets say GitLab, migrating releases page will be a manual work
1. Releases could potentially be lost in case of GitHub failure
1. Offline access

All of them except №1 could be somewhat solved by duplicating changelog in version tag message.

---

So I'd propose to only leave a link in the changelog file that'll point to Releases page and maintain changelog on releases page (and optionally in git tag messages). =||= Closing via #6533. =||= "3.x: Remove Changes.md"An unnecessary duplication of the [releases](https://github.com/ReactiveX/RxJava/releases) tab. Changing the file triggers an unecessary build that has to be canceled on Travis CI so that the actual release runs without interference. 

Resolves #5646"David Karnokakarnokd06/21/19, 01:41:54 PM
6347.06534Observable.using() disposes resource before upstream"I've expected that Observable.using flow is:
* create resource
* creates resource using observable, subscribe
* finish/cancel resource-using observable
* dispose resource

But for me actual is sometimes
* create resource
* creates resource using observable, subscribe
* dispose resource
* finish/cancel resource-using observable

As I understand, using 'eager' makes second flow consistent,but i need first behavior, which is not observed on dispose() call - resource is disposed first always, then observable. What is correct way to make Observable which is not eager even on dispose?

https://github.com/ReactiveX/RxJava/blob/5278124db4a93b8f59cee4e3baa9e864601637fd/src/main/java/io/reactivex/internal/operators/observable/ObservableUsing.java#L151""Indeed eagerness is not affecting the dispose order, and I'm not certain if it should or not. /cc @artem-zinnatullin @davidmoten @vanniktech 

The shortest workaround would be for you to take the operator by source and have a local version with the desired order of disposal. =||= I'm not sure either. Haven't really used `using`. =||= My understanding was that resource is allocated firtst and free'd last, and i used it in Android to wrap some of APIs, like 'call register/start', 'handle results as observable', 'call unregister/stop'. But as on dispose Using first disposes resource (in my case - calls 'unregister/stop') it ended up in some kind of 'race conditon': observable chain is partially disposed, 'stop' is called, but as stop can be called by Android itself - it emits onError, which is not handled already, thus app crashes with undeliverable exception.
Second cause of issue was because i used SwitchMap on this Using, which first disposes upstream and then inner subscription, but that was fixed by moving switchMap inside of Using observable (second argument).

Currently i've went around this by copying code from Using and making it always dispose resource last, as was suggested. =||= This would be a change for 2.x with unexpected consequences so instead, this should be changed in 3.x. 
So eager disposes the resource first, non-eager disposes resource last. =||= Closing via #6534. =||= "3.x: Make using() resource disposal order consistent with eager-mode"Make the resource disposal order in all `using` implementations are consistent with the eagerness of the operator:

**eager**: dispose resource then dispose the upstream
**non-eager**: dispose the upstream then dispose the resource.

Fixes: #6347"David Karnokakarnokd06/24/19, 08:06:11 AM
6390.065352.x: ObservableEmitter/FlowableEmitter Javadoc Improvement"The javadoc for `ObservableEmtter` states:

> The emitter allows the registration of a single resource, in the form of a Disposable or Cancellable via setDisposable(Disposable) or setCancellable(Cancellable) respectively. The emitter implementations will dispose/cancel this instance when the downstream cancels the flow or after the event generator logic calls Emitter.onError(Throwable), Emitter.onComplete() or when tryOnError(Throwable) succeeds.

Similarly, the javadoc for `FlowableEmitter` states:

> The emitter allows the registration of a single resource, in the form of a Disposable or Cancellable via setDisposable(Disposable) or setCancellable(Cancellable) respectively. The emitter implementations will dispose/cancel this instance when the downstream cancels the flow or after the event generator logic calls Emitter.onError(Throwable), Emitter.onComplete() or when tryOnError(Throwable) succeeds.

`when the downstream cancels the flow` is ambiguous for a noobie like me. It isn't clear that a subscriber calling `dispose` will `[cancel] the flow`. It would be very helpful if the relationship between the `*Emitter` and the downstream subscriber was more explicit.""You mean replace ""cancels"" in ObservableEmitter with ""disposes""?  =||= I mean the documentation should explicitly say that `dispose`-ing a subscriber will `dispose` the `Observable` for which `ObservableEmitter` supplies events.

`when the downstream cancels the flow` is the confusing part, and I'm not sure where the documentation talks about this. =||= I was under the impression that in general, an `Observable` or `Flowable` was designed to have potentially many subscribers, and so it's counter-intuitive that disposing a single subscriber would thus dispose the `Observable`/`Flowable`. =||= I'm not sure if we want to put that level of documentation detail into those interfaces. There is a short example in the [Observable](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Observable.html) JavaDocs that demonstrates disposing a sequence which is currently not there for `Flowable`.

> I was under the impression that in general, an Observable or Flowable was designed to have potentially many subscribers, and so it's counter-intuitive that disposing a single subscriber would thus dispose the Observable/Flowable.

A subscriber/observer cancels/disposes the dedicated subscription object established when calling `subscribe` with said consumer. Yes, the terminology is somewhat imprecise and we use ""cancels the Flowable"" still as a shorthand for it. =||= > A subscriber/observer cancels/disposes the dedicated subscription object

Does this mean that the `ObservableEmitter` is the `dedicated subscription object`? =||= Technically, yes. =||= If you want, you can create a PR with your proposed documentation changes. =||= Closing via #6535 for 3.x. If you want, you can backport it to 2.x. =||= "3.x: JavaDocs: clarify create emitters are per consumer"This PR adds this documentation part to the various `create` JavaDocs (adapted):

Whenever an `Observer` subscribes to the returned `Observable`, the provided
`ObservableOnSubscribe` callback is invoked with a fresh instance of an `ObservableEmitter`
that will interact only with that specific `Observer`. If this `Observer`
disposes the flow (making `ObservableEmitter#isDisposed` return true),
other observers subscribed to the same returned `Observable` are not affected.


Resolves #6390"David Karnokakarnokd06/24/19, 07:49:48 AM
6447.06538observeOn.concatMap may not invoke the mapper function on the desired thread"There are two effects in play here: fusion and trampolining.

Fusion will take the `observeOn` queue and just pull on it when the subscription happens. Trampolining will use the last interacting thread (the subscription thread or the termination thread) to pull on the internal queue (dedicated or fused) and when there is an item, it will run the mapper on that thread.

```java
Flowable.range(1, 5)
    .observeOn(Schedulers.computation())
    .concatMap(v -> Flowable.just(Thread.currentThread().toString()))
    .blockingSubscribe(System.out::println);
```

This will likely print computation, main, main, main, main.

Workarounds:

- Use `hide()` between `observeOn` and `concatMap` to break fusion.
- Use `subscribeOn` after `concatMap` to move the trampoline off the main thread.
- Use `defer`+`subscribeOn` in the mapper function to calculate the actual `Flowable` on a desired thread, not the mapper thread.

Appeared on [StackOverflow](https://stackoverflow.com/q/55389131/61158).""Also `concatMapSingle`, `concatMapMaybe` and `concatMapCompletable` have similar issue. =||= Closing via #6538.

@kojilin If you want, you can post PRs. =||= "3.x: Add concatMap with Scheduler guaranteeing where the mapper runs"This PR adds an overload to `concatMap` and `concatMapDelayError` in both `Flowable` and `Observable` which makes sure the `mapper` function is always executed on a dedicated scheduler.

By default `concatMap` may execute the `mapper` function on various threads: the subscribing thread, the upstream thread generating the items to be mapped or the thread where the generated inner source terminates. These overloads remove this kind of uncertainty.

The implementation is a copy of the original concatMap instead of an extension so that optimizations for the non-scheduled variants still work without extra overhead.

Overloads to the `concatMap{Single|Maybe|Completable}` and `concatMap{Single|Maybe|Completable}DelayError` *may be added* in a separate PR later.

Resolves #6447"David Karnokakarnokd06/24/19, 01:37:53 PM
6543.065443.x: Fix Schedulers.from(Executor, boolean) version tag"It should say `@since 3.0.0` as it has been promoted.

https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/schedulers/Schedulers.java#L403"Closing via #6544 =||= Fixing version tag on Schedulers.from(Executor, boolean)"Resolves #6543 

Updating the version tag on `Schedulers.from(Executor, boolean)` since it was promoted."Luis Cortesluis-cortes06/26/19, 09:31:30 PM
6551.06556Disambiguous some method call sites when calling from Kotlin "I vaguely remember that we already had a discussion about this but I don't know which conclusion was drawn. Observable.onErrorResumeNext is ambiguous when calling from Kotlin.

<img width=""1370"" alt=""Screenshot 2019-06-30 at 12 09 33"" src=""https://user-images.githubusercontent.com/5759366/60395175-f18f9d80-9b2f-11e9-93cf-fd8d3f8081d3.png"">

Since 3.x is a thing do we want to rename these methods. Similar to what we did with `startWith` (even though there was no type inference problem).""Yes, 3.x is a good place fix such ambiguities. My ideas are `onErrorResume(ObservableSource)` or `onErrorResumeWith(ObservableSource)`. PR welcome. =||= Those names sound good to me. I believe the onErrorReturn should also be renamd then. =||= A few questions:

- Do you want to change `Maybe.onErrorResumeNext(MaybeSource)` as well? 
- To what should `Observable.onErrorReturn(Function valueSupplier)` be renamed? 
- Do you want to rename `Maybe.onErrorReturn(Function valueSupplier)` as well?
- What about `Single.onErrorReturn(Function resumeFunction)?`
- Is it ok to do all of this in the same PR?
 =||= > Do you want to change Maybe.onErrorResumeNext(MaybeSource) as well?

Yes, every class where `onErrorResumeNext` has a source type and a function.

> To what should Observable.onErrorReturn(Function valueSupplier) be renamed?

There is no ambiguity there as the other is called `onErrorReturnItem`

> Do you want to rename Maybe.onErrorReturn(Function valueSupplier) as well?

There is no ambiguity there either.

> What about Single.onErrorReturn(Function resumeFunction)?

There is no ambiguity there either.

> Is it ok to do all of this in the same PR?

You can rename multiple things within the same PR. =||= @akarnokd Thanks for the clarification. 

Out of curiosity, @vanniktech was there a reason besides ambiguity that made you suggest renaming the `onErrorReturn`s? =||= @akarnokd Is there a reason `Single.onErrorResumeNext(final Single<? extends T> resumeSingleInCaseOfError)` takes a `Single` and not a `SingleSource` like the other methods? 

I've made the change and run all the tests for this method and all of them pass. 

If there's no reason and it's ok with you I'd be happy to make the change since I'm in the area anyway.  =||= Looks like an API mistake. You can change that too (and see if other places need fixing as well). =||= "3.x rename on error resume next methods to disambiguate when calling from kotlin (#6551)"Resolves #6551 

- Renamed `onErrorResumeNext(Source)` to `onErrorResumeWith(Source)` for `Observable`, `Maybe`, `Single`, and `Flowable`
- Renamed some unit tests and their classes to reflect the method name change
- Changed parameter type of `Single.onErrorResumeWith` from `Single` to `SingleSource`  
- Updated JavaDocs for all renamed methods
- Removed redundant casts for unit tests
- Deleted duplicate unit test that arose from no longer needing to cast arguments "Luis Cortesluis-cortes07/04/19, 08:19:14 AM
6554.06564Remove onExceptionResumeNext?"[JavaDocs](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#onExceptionResumeNext-org.reactivestreams.Publisher-)

I don't remember ever needing, asked for or recommended this operator? The difference from `onErrorResumeNext` is that anything that's not extending `Exception` can pass through. I believe it was added to support some internal Netflix operation. It can be emulated via `onErrorResumeNext`: 

```java
source.onErrorResumeNext(
    error -> error instanceof Exception 
        ? fallback : Obserable.error(error))
```""Never used onExceptionResumeNext. =||= It was rather more confusing.
 =||= "3.x: remove buffer/window with supplier & onExceptionResumeNext"This PR removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years.

- `buffer(Supplier [, Supplier])`
- `window(Supplier [, int])`
- `onExceptionResumeNext(<source>)`

Resolves #6554 
Resolves #6555"David Karnokakarnokd07/11/19, 06:34:16 AM
6555.06564Remove exact buffer/window with Supplier<source>?"There exist special overloads of the exact-boundary `buffer`/`window` operators that takes a supplier of a source. (Example [JavaDocs](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#buffer-java.util.concurrent.Callable-)).

This supplier is called over and over once the previous boundary signaled an item or completed.

I'm not sure if this type of boundary was in use at all. It can be emulated with the plain [sourced versiong](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#buffer-org.reactivestreams.Publisher-):

```java
source.buffer(Observable.defer(supplier).take(1).repeat())
```"3.x: remove buffer/window with supplier & onExceptionResumeNext"This PR removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years.

- `buffer(Supplier [, Supplier])`
- `window(Supplier [, int])`
- `onExceptionResumeNext(<source>)`

Resolves #6554 
Resolves #6555"David Karnokakarnokd07/11/19, 06:34:16 AM
6597.06598using Observable#mergeWith(CompletableSource), upstream occurs an error, but the ComletableSource won't be disposed"using Observable#mergeWith(CompletableSource), upstream occurs an error, but the ComletableSource won't be disposed.

```java
Observable.create(new ObservableOnSubscribe<Object>() {
    @Override
    public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
        Schedulers.io().scheduleDirect(
            () -> emitter.tryOnError(new Throwable(""occurs error"")),
            1, TimeUnit.SECONDS);
        }
    })
    .mergeWith(
        Completable.create(emmit ->
            emmit.setCancellable(() -> System.out.println(""mergeWith dispose""))
         )
         .doOnSubscribe(dis -> System.out.println(""mergeWith doOnSubscribe""))
    )
    .subscribe(ob -> {}, System.out::println);
```
the result is :
```
mergeWith doOnSubscribe
java.lang.Throwable: occurs error
```

but if add 'toObservable()' 
```
Observable.create(new ObservableOnSubscribe<Object>() {
            @Override
            public void subscribe(ObservableEmitter<Object> emitter) throws Exception {
                Schedulers.io().scheduleDirect(() -> emitter.tryOnError(new Throwable(""occurs error"")), 1, TimeUnit.SECONDS);
            }
        })
                .mergeWith(Completable.create(emmit ->
                        emmit.setCancellable(() -> System.out.println(""mergeWith dispose"")))
                        .doOnSubscribe(dis -> System.out.println(""mergeWith doOnSubscribe"")).toObservable())
                .subscribe(ob -> {}, System.out::println);
```

the result is: 
```
mergeWith doOnSubscribe
mergeWith dispose
java.lang.Throwable: occurs error
```

The 'dispose' will be invoked。
In case of first,it will produce a memory leak.
Is that a bug?"Thanks for reporting. This is indeed a bug with those `mergeWith` operators. =||= Thank you for all your efforts =||= 3.x: Fix mergeWith not cancelling the other source if the main errors"The `mergeWith` implementations' `onError` (called by the main source) cancelled the main source instead of cancelling the other source. This mistake affects all 2 x 3 overloads of the operator.

Fixes #6597"David Karnokakarnokd07/30/19, 07:27:04 AM
6576.06601ObservableBlockingSubscribe compares BlockingObserver.TERMINATED with wrong object"The `ObservableBlockingSubscribe.observe` function appears to compare the `o` variable, i.e. the `ObservableSource`, which shouldn't ever change, with `BlockingObserver.TERMINATED`. This will probably never be true. The intention was likely to use `v` instead of `o`, in:

https://github.com/ReactiveX/RxJava/blob/a38268c738af7ae1ca50dc4af2bfbb5713361411/src/main/java/io/reactivex/internal/operators/observable/ObservableBlockingSubscribe.java#L64 

Since this appears to be somewhat redundant with `bs.isDisposed()`, this probably does not cause any issues."Yes, it should be `v == BlockingObserver.TERMINATED`. PR welcome. =||= 2.x: ObservableBlockingSubscribe compares with wrong object"It should compare the TERMINATED instance with the value received from the blocking queue.

Fixes: #6576 
Related: #6577"David Karnokakarnokd07/30/19, 09:20:18 AM
6608.06609ReplaySubject and buffer with debounce not emitting values after first subscription"The issue described below started with version 2.2.10 and continues with 2.2.11. It works with 2.2.7 through 2.2.9.

I have a test where a set a `ReplaySubject` like so:

```
locationPublisher = ReplaySubject.create()
locationPublisher.onNext(mockLocation)
locationPublisher.onComplete()

locationObservable = locationPublisher.share()
```

Then, I subscribe twice to the observable (I'm simplifying the test case just to demonstrate the bug):
```
        locationObservable
            .buffer(locationObservable.debounce(5, TimeUnit.SECONDS))
            .test()
            .assertValueCount(2)


        locationObservable
            .buffer(locationObservable.debounce(5, TimeUnit.SECONDS))
            .test()
            .assertValueCount(2)
```
When I run the above test, it fails on the second test subscription on RxJava 2.2.10 or 2.2.11:
> java.lang.AssertionError: Value counts differ; expected: 2 but was: 1 (latch = 0, values = 1, errors = 0, completions = 1)
Expected :2 
Actual   :1 (latch = 0, values = 1, errors = 0, completions = 1)""Hi and thanks for reporting. This is a bug in `refCount` affecting both 2.x and 3.x.

What happens is that when the source subject completes, it completes `buffer`, which then cancels the boundary source, which makes the `refCount` think it still has 1 subscriber active and doesn't reset the source.

The operator is a bit delicate so I have to work out the correct state transitions and not break tests... =||= Hi. I can't seem to reproduce this with 2.2.11. Could you check if the following test passes for you on 2.2.11?

```java

@Test
public void upstreamTerminationTriggersAnotherCancel() throws Exception {
    ReplaySubject<Integer> rs = ReplaySubject.create();
    rs.onNext(1);
    rs.onComplete();

    Observable<Integer> shared = rs.share();

    shared
    .buffer(shared.debounce(5, TimeUnit.SECONDS))
    .test()
    .assertValueCount(2);

    shared
    .buffer(shared.debounce(5, TimeUnit.SECONDS))
    .test()
    .assertValueCount(2);
}
``` =||= Yes, I just created a new project with Android Studio and added only RxJava as a new dependency and your test above.

It fails on versions 2.2.10 and 2.2.11 put passes on 2.2.9. =||= "3.x: Fix refCount not resetting when termination triggers cross-cancel"This PR fixes both `refCount` implementation to properly reset the source when the source terminates multiple consumers.

In the original, when the source terminated multiple sources, the first termination handler cleared the connection but since the `--subscriberCount` wasn't zero, the source was not reset. If this termination triggered a cancel on the second consumer, that path would not get the source reset either due to losing the connection object. Unfortunately, one can't just take the first termination handler and reset there immediately either because that could disrupt the termination of the rest of the consumers. It has to wait for the source to terminate all consumers or have the consumers cancel all.

This affects 2.x and will be backported in a separate PR.

Fixes #6608"David Karnokakarnokd08/03/19, 08:24:01 AM
6587.06612Inner errors within concatMapSingle vanish if disposed"Not sure if this intentional or a bug. The following code:
```java
package Test;

import io.reactivex.Observable;
import io.reactivex.schedulers.Schedulers;
import io.reactivex.Single;

public class Test {
	public static void main(String[] args) {
//		Observable.just(0,1)		// UndeliverableException - First concatMapSingle-block throws, interrupting second one
		Observable.just(2, 0)		// Just ""MyError"" output, exception in first block appears to vanish
				.concatMapSingle(workItem2 -> {
					return Single.just(workItem2).subscribeOn(Schedulers.computation()).map(workItem -> {
						try {
							Thread.sleep(1000);
							if (workItem == 1)
								throw new Exception(""Something in first block failed"");
							Thread.sleep(1000);
						} catch (InterruptedException e) {
							System.out.println(""InterruptedException in block 1"");
							throw e;
						}
						return workItem;
					});
				}).concatMapSingle(workItem2 -> {
					return Single.just(workItem2).subscribeOn(Schedulers.computation()).map(workItem -> {
						try {
							Thread.sleep(1000);
							if (workItem == 2) {
								throw new Exception(""Something in second block failed"");
							}
							Thread.sleep(1000);
						} catch (InterruptedException e) {
							System.out.println(""InterruptedException in block 2"");
							throw e;
						}
						return workItem;
					});
				}).blockingSubscribe(item -> System.out.println(""Item finished "" + item), err -> {
					System.out.println(""MyError: "" + err.toString());
					err.printStackTrace();
				});
	}
}
```
has 2 processing stages. If the first one throws an exception, the second one gets interrupted and throws an `UndeliverableException`. In the opposite case, if the 2nd block throws an exception, the 1st one gets interrupted, but its `InterruptedException` is completely ignored - not delivered to any error handler, nor thrown as `UndeliverableException`.

This is caused by some kind of race condition within `ConcatMapSingleMainObserver`. When the 2nd block throws, on the `ConcatMapSingleMainObserver` instance belonging to the 1st block, `dispose` is called before `innerError`. Because at this point `errors` is empty, `addThrowable` succeeds, but the `drain` loop is never called, because `dispose` has set the `AtomicInteger` to `1`. Therefore, the exception in `error` is never retrieved and forwarded.

This can be fixed (if it needs fixing, anyways) by having `innerError`, `dispose` and the `drain` loop check for `cancelled` and forward exceptions to `RxJavaPlugins.onError` if appropriate. I will make a PR..."This is an issue with all `concatMap` variants and the fix looks like in #6572. =||= 3.x: Fix many operators swallowing undeliverable exceptions"Fix many operators to emit the collected exception in case of a cancel/dispose call to the plugin error handler (i.e., becoming undeliverable excptions).

In addition, the terminal event/error delivery has been unified in many other operators so that the terminal-indicator exception is never leaked.

There will be a separate PR about cleaning up the `addThrowable` usage cases (#6611).

Fixes: #6587"David Karnokakarnokd08/05/19, 03:25:26 PM
6615.06616Flowable.fromIterable does not work as expected when used in switchMap"This issue was reproduces on RX-Java v2.2.6 and v3.0.0-RC1

I have this piece of code:
```java
Flowable
  .range(1, 2)
  .doOnNext(value -> {
    System.out.println(""value1: "" + value);
  })
  .switchMap(value -> Flowable.just(value * 10))
  .subscribe(
    value -> System.out.println(""value2: "" + value),
    throwable -> System.out.println(""error: "" + throwable),
    () -> System.out.println(""complete"")
   );
```
When run it prints:
value1: 1
value2: 10
value1: 2
value2: 20
complete

Then I have the exact same thing but with Flowable.fromIterable:
```java
Flowable
    .range(1, 2)
    .doOnNext(value -> {
        System.out.println(""value1: "" + value);
    })
    .switchMap(value -> Flowable.fromIterable(Arrays.asList(value * 10)))
    .subscribe(
        value -> System.out.println(""value2: "" + value),
        throwable -> System.out.println(""error: "" + throwable),
        () -> System.out.println(""complete"")
    );
```
This one prints:
value1: 1
value2: 10

And then nothing, no complete, no error, nothing."Hi and thanks for reporting. This is a bug in `switchMap` not playing nice with `fromIterable`. You can work around by applying `.hide()` to `fromIterable`. I'll post a fix shortly. =||= Thanks. =||= 3.x: Fix switchMap incorrect sync-fusion & error management"This PR fixes the incorrect request call inside `switchMap` when working with sync-fused sources.

Fixes: #6615"David Karnokakarnokd08/14/19, 09:40:11 AM
6625.066272.x Calling hasNext() on a disposed blocking iterator hangs forever"Calling `hasNext()` on a a blocking iterator never returns if the iterator has been disposed. 

Tested on 2.2.11

To reproduce:
```
Iterator<Integer> iterator = Flowable.fromArray(1, 2, 3).delay(1, TimeUnit.SECONDS).blockingIterable().iterator();

System.out.println(""start"");
((Disposable)iterator).dispose();
iterator.hasNext(); //Hangs forever
```""Indeed, if you ""hack"" into that Iterator it won't work properly as it implementing Disposable is not part of the public intended API. I'll see what I can do about it in 2.x. For 3.x, it probably needs some redesign to work with try-with-resources for example. =||= Closing via #6626 & #6627. =||= "2.x: Fix blockingIterable hang when force-disposed"When the iterator was cast to `Disposable` and disposed, the subsequent `hasNext` would block indefinitely. That interface is not intended to be part of the public API and `Iterator` in general does not support any form of official cancellation (unlike Stream). This PR makes sure that if that dispose is called, it unblocks the iterator.

Resolves #6625 "David Karnokakarnokd08/21/19, 02:25:39 PM
6636.06637System.properties access restriction."I'm getting `access denied (""java.util.PropertyPermission"" ""*"" ""read,write"")` error when using the IO Scheduler. 

Its coming from: 
https://github.com/ReactiveX/RxJava/blob/13772a173cb6a59643dfd5eaf023a1412f804096/src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java#L93

```
static {
        Properties properties = System.getProperties();

        PurgeProperties pp = new PurgeProperties();
        pp.load(properties);

        PURGE_ENABLED = pp.purgeEnable;
        PURGE_PERIOD_SECONDS = pp.purgePeriod;

        start();
    }
```

All this seems to be from what I could see is that it's trying to get purge options from the system properties. 

```
static final class PurgeProperties {

        boolean purgeEnable;

        int purgePeriod;

        void load(Properties properties) {
            if (properties.containsKey(PURGE_ENABLED_KEY)) {
                purgeEnable = Boolean.parseBoolean(properties.getProperty(PURGE_ENABLED_KEY));
            } else {
                purgeEnable = true;
            }

            if (purgeEnable && properties.containsKey(PURGE_PERIOD_SECONDS_KEY)) {
                try {
                    purgePeriod = Integer.parseInt(properties.getProperty(PURGE_PERIOD_SECONDS_KEY));
                } catch (NumberFormatException ex) {
                    purgePeriod = 1;
                }
            } else {
                purgePeriod = 1;
            }
        }
    }
```

In my system I can't allow for read/write access to all System properties. Can this be changed to use `System.getProperty(PURGE_ENABLED_KEY)` or the like as I can allow for access to specific keys."I'll look into it. =||= Fix posted for [3.x](https://github.com/ReactiveX/RxJava/pull/6637) and [2.x](https://github.com/ReactiveX/RxJava/commit/cc690ff2f757873b11cd075ebc22262f76f28459). =||= 3.x: Avoid using System.getProperties() due to security restrictions"Change the code in the `SchedulerPoolFactory` to use `System.getProperty` directly. Also fix property names to `rx3.` as now both v2 and v3 could run together.

Fixes #6636"David Karnokakarnokd08/28/19, 10:58:51 AM
6611.066393.x: Revise AtomicThrowable.addThrowable usage"Currently, many (if not all?) usage of `addThrowable` is as follows:

```java
if (errors.addThrowable(ex)) {
   // do something with the error case
} else {
    RxJavaPlugins.onError(ex);
}
```

The plugin error call could be inlined into the method call and renamed to `tryAddThrowable` to ensure all usage places are updated correctly."Hey, do you need help doing this?  =||= Each usage location has to be reevaluated and there are thousands of those. It would be easier if I do them. =||= "3.x: Cleanup addThrowable, ""2.x"" and null-value error messages""This PR renames the internal `addThrowable` to `tryAddThrowable` and introduces the `tryAddThrowableOrReport` to perform the common reporting to the global error handler. Usage places have been re-evaluated and fixed if necessary.

In addition, `null` exceptions have been made more uniform.

Resolves #6611"David Karnokakarnokd08/28/19, 02:07:44 PM
6596.066423.x: groupBy may never cancel the upstream if the group is dropped"### Summary

The design decision to allow a delayed `subscribe()` to a group emitted by `groupBy` (i.e., `subscribeOn`) creates a window where if the consumer ignores the group, `groupBy` may never cancel its source.

### Problem

In order to support taking a limited number of groups (i.e., `source.groupBy(i -> i % 10).take(2)`, the `groupBy` operator can't cancel its source just because the downstream cancelled the flow of groups on it. Instead, a reference counting scheme is used so that when all groups have been cancelled, the upstream will then be cancelled (i.e., `source.groupBy(i -> i % 2).take(2).flatMap(g -> g.take(2))`).

The documentation states that [one should not ignore a group](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/Flowable.html#groupBy-io.reactivex.functions.Function-):

> Note: A `GroupedFlowable` will cache the items it is to emit until such time as it is subscribed to. For this reason, in order to avoid memory leaks, you should not simply ignore those `GroupedPublisher`s that do not concern you. Instead, you can signal to them that they may discard their buffers by applying an operator like `ignoreElements()` to them.

however, some operators may ignore their input - since they don't see a group but an object only, thus the group is not consumed and the source is never cancelled.

Unfortunately, `flatMap` is one of such operators which when cancelled, it will ignore incoming values, and thus groups. Add some asynchronous cancellation race and the problem manifests sooner or later (`source.groupBy.take.flatMap.takeUnit(cancelSignal)`).

In the original Rx.NET implementation, groups are reference counted and if the consumer doesn't subscribe to it immediately, the group is discarded right then. However, they don't cache items and thus a delayed subscription results in dataloss RxJava was set to avoid.

### Proposition

I propose a change to the `groupBy` logic to solve this cancellation problem as well as not lose data. The solution requires multiple considerations.

First, we need to detect if there was a `subscribe` call when a fresh group was emitted. If not, the group is discarded *after* the single value and a completion signal is emitted to the group. This way, the `groupBy` is not held back by a potentially unconsumed group and if the group is eventually consumed, the value is not lost. 

**The drawback is that this scheme may lead to group recreation over and over even if the group is actually subscribed to in a delayed fashion.** Note, however, that since a group is practically a hot subject, using `subscribeOn` has generally no practical benefit and consumers should apply `observeOn` to shift the emission to the desired thread anyway.

Second, there is an inherent race possible between an async subscriber and deciding if the group has been subscribed to just in time. Therefore, an atomic state transition has to be implemented to declare a group live or dead on arrival. In addition, the completion of the dead group and a possible cancellation by its consumer should not trigger multiple cancellations/group removal, especially the removal of a newer group with the same key.

Third, when a `GroupedFlowable` is declared dead on arrival, then consumed later, the consumption if the cached item should not trigger a request from the main source like with any alive group consumption. In contrast, declaring a group dead should ask for replenishment from the main source as now we can't know if the group will ever be consumed.""Thanks for raising this @akarnokd. Reminds me of #5839 where you used the term *resource-aware streams*. Making RxJava *resource-aware* might be an option so that queueing operators applied some function (global? local? interface defined?) to unused buffered elements. 

I've hundreds of uses of `groupBy` across work and other codebases and I always use it with `flatMap` straight after (the only exception is the occasional use of `groupBy.map.flatMap` which is trivially transformable to `groupBy.flatMap`). My use cases are not that interesting perhaps but I do wonder if people do use `groupBy` with cancelling operators like `take` before `flatMap`. I don't like losing flexibility in general but perhaps the root of our problem is that the `groupBy` operator should always flatten the grouped streams as well so that we can internalize the cancellation problem.  

Has anyone got a use case where they call `flowable.groupBy.take.flatMap` or similar cancelling operator being applied to the `groupBy` before the `flatMap`? =||= We use something like a hook for unconsumed data (discarded). The problem is still that sometimes we cannot guarantee the parent is not emitting some extra onNext. We had that problem with MonoCollectList in particular but it can apply to other operators.

One thing I was wondering was if we could make cancel propagate back an onComplete to delimit the onNext sequence consistently.

Regarding your case @davidmoten i've mostly seen cases where we do `flux.groupBy.flatMap[take.reduce]` or similar. I've also had a case where groups could be pre-determined and we just forward to processors we can eagerly create instead of waiting for an onNext to create the groupedFlux in that case. =||= Thanks @smaldini.

My question is not great at the moment. Really I want to establish if any user has a use case to insert a non-trivial operator between `groupBy` and `flatMap`. If not that means that internalization of the `flatMap` is a possibility. =||= >We use something like a hook for unconsumed data (discarded). The problem is still that sometimes we cannot guarantee the parent is not emitting some extra onNext. We had that problem with MonoCollectList in particular but it can apply to other operators.

That's interesting and certainly makes *resource-aware streams* more difficult. =||= I don't think resource awareness would help in this situation. When the group is composed over (`flatMap( group.map )`), it stops being a `GroupedFlowable` thus any `Disposable` option would be lost.

Resource-awareness is its own complicated thing and requires drastic changes to the architecture. I'd like someday to explore it but outside of RxJava. =||= >I don't think resource awareness would help in this situation. When the group is composed over (flatMap( group.map )), it stops being a GroupedFlowable thus any Disposable option would be lost.

Yep, indeed. 

What about the internalization of `flatMap` into `groupBy`? =||= Like with `publish(Function)`? I'm not sure; it would prevent open composition as you'd have to put everthing inside. I don't think yo could hand out `Flowable<GroupedFlowable<T, K>>` reliably either way. =||= "3.x: Fix groupBy not canceling upstream due to group abandonment"This PR fixes the issue when a group is not subscribed to, the upstream may never cancel due to seemingly open groups.

The fix is a tradeoff with group abandonment and possible excessive group re-creation so that elements are not lost in case the groups do get subscribed to a bit later. Therefore, the groups should be subscribed to immediately and synchronously:

```java
Observable.range(1, 1000)
.groupBy(v -> v % 10)
.flatMap(v -> {
    System.out.println(""New group: "" + v.getKey());
    return v;
})
.subscribe();

Observable.range(1, 1000)
.groupBy(v -> v % 10)
.flatMap(v -> {
    System.out.println(""New group: "" + v.getKey());
    return v.observeOn(Schedulers.io()); //  <-------------------------------- OK
})
.blockingSubscribe();
```

Consequently, the following setups will result in constant group recreations:

```java
Observable.range(1, 1000)
.groupBy(v -> v % 10)
.observeOn(Schedulers.io()) // <------------------------------------- TROUBLE
.flatMap(v -> {
    System.out.println(""New group: "" + v.getKey());
    return v;
})
.blockingSubscribe();

Observable.range(1, 1000)
.groupBy(v -> v % 10)
.flatMap(v -> {
    System.out.println(""New group: "" + v.getKey());
    return v.subscribeOn(Schedulers.io()); // <----------------------- TROUBLE
})
.blockingSubscribe();
```

For the `subscribeOn` ""trouble"", since groups were essentially unicast subjects/processors, `subscribeOn` had no practical use on them and instead `observeOn` should be used to move the observation of the group's items to the desired thread.

Resolves #6596"David Karnokakarnokd08/29/19, 02:33:12 PM
6647.066482.x: confused of method takeLast(long,TimeUnit)"I'm a little confused about takeLast(long, TimeUnit).
When executing the following code, each time the output order is supposed to be N digits in the last time window, but in fact the output results are inconsistent with the ideal state.
### Code
```
 public static void main(String[] args) {
        ArrayList<Integer> ints = new ArrayList<>();
        for (int i = 0; i < 100; i++) {
            ints.add(i);
        }
        Observable.fromIterable(ints)
                .takeLast(1,TimeUnit.NANOSECONDS)
                .subscribe(longs->{
                    System.out.println(longs);
                });
        try {
            Thread.sleep(100000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```
### Result
![image](https://user-images.githubusercontent.com/29222599/64687577-59158200-d4bd-11e9-9def-89505d68f337.png)""Hi and thanks for reporting. This is a bug in `takeLast` because the internal time window calculation is incorrect. I'll post a fix shortly. =||= @akarnokd  Hello! I would like to know that the takeLast() method is to get the data of the last window that was sent. We already got the data of the last window in the OnNext() method, so why do we have to make another time difference judgment in the onComplete() method =||= I don't understand your question. TakeLast takes those last items that have been received between the onComplete and some time before:

```
source       --o-o-o------o-o-o-o-o---|
time window                  ^========^
result       -----------------o-o-o---|
``` =||= @akarnokd Sorry, I mean the last time window data filtering has been done in the following onNext() code
```
public void onNext(T t) {
            final SpscLinkedArrayQueue<Object> q = queue;

            long now = scheduler.now(unit);
            long time = this.time;
            long c = count;
            boolean unbounded = c == Long.MAX_VALUE;

            q.offer(now, t);

            while (!q.isEmpty()) {
                long ts = (Long)q.peek();
                if (ts <= now - time || (!unbounded && (q.size() >> 1) > c)) {
                    q.poll();
                    q.poll();
                } else {
                    break;
                }
            }
        }
```
So why are we even checking onComplete?
```
                T o = (T)q.poll();

                if ((Long)ts < scheduler.now(unit) - time) {
                    continue;
                }

                a.onNext(o);
```
What I'm reading is that takeLast() is the last time window of observable's entire life cycle, but I look at the source code calling a.onNext(o) and then calling the Observer's accept () method, so that means takeLast() and observer has a coupling. I don't know if my expression is clear enough and thank you for your patient explanation. =||= Because onComplete can happen much later than the previous onNext, thus that value is now out of the time window. =||= Okay,Thanks! =||= "3.x: Fix takeLast(time) last events time window calculation."The logic inside the `Observable.takeLast(time)` was not using a fixed timestamp to compare against but one that could change between calls, resulting in items wrongly skipped from the accumulated buffer. The PR makes this timestamp limit fixed outside the drain loop.

The `Flowable` variant did not have the issue but both received the unit test verifying the correct behavior.

The same fix for 2.x will be posted separately.

Fixes: #6647"David Karnokakarnokd09/12/19, 10:47:28 AM
6651.06652"Observable#window(long, java.util.concurrent.TimeUnit, long) if reached ""window-max-count"", the timespan not work""io.reactivex.Observable#window(long, java.util.concurrent.TimeUnit, long)

```
Observable.create((ObservableOnSubscribe<Integer>) emitter -> {
            emitter.onNext(0);
            emitter.onNext(1);
            TimeUnit.SECONDS.sleep(1);
            emitter.onNext(2);
            TimeUnit.SECONDS.sleep(6);
            emitter.onNext(4);
            emitter.onNext(5);
        })
                .subscribeOn(Schedulers.io())
                .observeOn(Schedulers.io())
                .window(5,TimeUnit.SECONDS, 2)
                .flatMapSingle(Observable::toList)
                .subscribe(list -> System.out.println(""list="" + list + "" time: ""
                      + TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis() - l)
                      + ""s""));
```
Like the case of above, since 7 seconds, some empty arrays are expected,and ""2"" will be emited when the 5 seconds,but actually not.

```
list=[0, 1] time: 0s
list=[2, 4] time: 7s
```
There is nothing after 7 seconds, it make a confuse.
As the chart https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/window6.png
 it says that the timeSpan still works after winow-max-size reached.""How long did you wait for ""5""? There is an overload where you can specify the time window should restart upon reaching the size limit. =||= > How long did you wait for ""5""? There is an overload where you can specify the time window should restart upon reaching the size limit.

never the ""5"" be passed, because createObservable does not emit a ""complete"" in this case of ""restart"" is false by default.
if restart is true, the time window will restart, that is correct. =||= Thanks for the details, it is a bug in the operator. I'll post fixes shortly. =||= Thanks for all of your contribution！ =||= Reopening to track 2.x  =||= Closing via #6657. =||= "3.x: Fix size+time bound window not creating windows properly"There was a logic error in the size+time bound `window` operator for when to close a window if timers are not restarted when the size-bound is hit.

Due to this bug, two tests were not receiving and thus accounting for empty windows that are happening when the size-bound is hit followed by the periodic time-bound hit.

2.x will be fixed in a separate PR.

Fixes #6651"David Karnokakarnokd09/17/19, 07:21:18 AM
5788.066683.x: Single incorrect or missing images (tracking issue)"- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(arg)`: missing diagram
- [x] `concat(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `concatArray`: missing diagram
- [x] `concatArrayEager`: missing diagram
- [x] `concatEager`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: missing diagram
- [x] `error(Throwable)`: indicate error in the box
- [x] `fromCallable`: missing diagram
- [x] `fromPublisher`: missing diagram
- [x] `fromObservable`: missing diagram
- [x] `merge`: missing diagram
- [x] `merge(SingleSource<SingleSource<T>>)`: indicate main element is a `SingleSource`
- [x] `merge(s1..s4)`: add 3rd and 4th source, indicate backpressure
- [x] `mergeDelayError`: Iterable/Publisher missing diagrams, S2,S3,S4 wrong diagrams
- [x] `never`: missing diagram
- [x] `timer`: missing diagram
- [x] `equals`: missing diagram
- [x] `unsafeCreate`: missing diagram
- [x] `using`: missing diagram
- [x] `wrap`: missing diagram
- [x] `ambWith`: missing diagram
- [x] `as`: missing diagram
- [x] `hide`: missing diagram
- [x] `compose`: missing diagram
- [x] `cache`: missing diagram
- [x] `cast`: missing diagram
- [x] `delay`: missing diagram
- [x] `delaySubscription`: missing diagram
- [x] `dematerialize`: missing diagram
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: indicate error case
- [x] `doFinally`: missing diagram
- [x] `doOnSubscibe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnError`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `filter`: one source item, indicate both true and false outcomes
- [x] `flatMapPublisher`: operator name
- [x] `blockingGet`: missing diagram
- [x] `lift`: missing diagram
- [x] `contains`: missing diagram
- [x] `mergeWith`: indicate backpressure
- [x] `onErrorReturn`: indicate item is the result of a function call with the original error
- [x] `onErrorReturnItem`: use the previous `onErrorReturn` diagram, change name in box
- [x] `onErrorResumeNext`: diagram should have one item and no complete marker
- [x] `onErrorResumeWith`: operator name
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat`: missing diagram
- [x] `repeatWhen`: missing diagram
- [x] `repeatUntil`: missing diagram
- [x] `retry`: missing diagram
- [x] `retryWhen`: missing diagram
- [x] `subscribe`: missing diagram
- [x] `subscribeWith`: missing diagram?
- [x] `takeUntil`: fix item count in main and other sources, indicate all other signal types
- [x] `timeout`: missing diagram
- [x] `to`: missing diagram
- [x] `toCompletable`: diagram is stretched
- [x] `toFlowable`: operator name in box, indicate backpressure
- [x] `toFuture`: indicate Future, remove the blocking text
- [x] `toMaybe`: operator name in box, indicate both outcomes with proper signal types
- [x] `unsubscribeOn`: missing diagram
- [x] `test`: missing diagram?


""I see most marbles in the JavaDoc live under this folder:  `https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/`. Are other locations accepted - e.g. can I upload it in Google Drive for example and open a PR with the updated path in the JavaDoc directly? Here's a few I created:

![single_dofinally](https://user-images.githubusercontent.com/4089934/39448132-dca93836-4cbb-11e8-9b13-ce078a8ba206.png)
![single_doondispose](https://user-images.githubusercontent.com/4089934/39448133-dcca516a-4cbb-11e8-9143-b935cf0dd64c.png)
![single_doonerror](https://user-images.githubusercontent.com/4089934/39448135-dce99bce-4cbb-11e8-9d52-8e30084f9aa4.png)
![single_doonsubscribe](https://user-images.githubusercontent.com/4089934/39448136-dd05bcbe-4cbb-11e8-823d-d9d0c3501f24.png)
![single_doonsuccess](https://user-images.githubusercontent.com/4089934/39448137-dd21fdca-4cbb-11e8-848d-45c3af91b76f.png)


 =||= Images have to be hosted by the project. Besides, Google drive tends to change the service terms and images may become inaccessible (I've lost resource location this way in another project). 

About your images:

- `doFinally`: 
  - error should be a red X
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
- `doOnDispose`
  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect
  - I draw disposed flows with dashed lines ([example](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/doFinally.o.png)), it would be great here
  - `unsubscribe` should be `dispose`
- `doOnSubscribe`
  - the star should be in between the operator box and the bottom timeline
- `doOnSuccess`: OK =||= Updated images from #5987 now in the repository:

![doFinally](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doFinally.png)
![doOnSuccess](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSuccess.2.png)
![doOnError](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnError.2.png)
![doOnDispose](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnDispose.png)
![doOnSubscribe](https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnSubscribe.png) =||= how are these made? are there any written guidelines? I can try making some when I have time. =||= There is a Mac only OmniGraffle. I'm on Windows and I use Excel shapes and arrows. =||= @AarjavP , I used [THIS template](https://github.com/davidmoten/rxjava-marble-template) as a staring point. It's for **Inkscape** software, which worked nicely on my Mac. =||= Hi all, can you please tell me is this marble acceptable for the `filter` operator?

As I haven't contributed to this project so far I would like to take it easy and slow :) Let me know what should I change so that I have a reference for future marbles.

![filter](https://user-images.githubusercontent.com/10116857/42415703-8d0530ce-8257-11e8-966c-2756a336e6c1.png)
 =||= Not really. There is no | in Single. Please have a look at diagrams above: https://github.com/ReactiveX/RxJava/issues/5788#issuecomment-385533074 =||= @akarnokd can we update this issue please? Its getting a bit messy and hard to follow what has been completed. =||= @UMFsimke It has been only you lately that worked on this. =||= "3.x: Add missing marble diagams to Single"Add (hopefully) all remaining missing marble diagrams to `Single`.

Resolves #5788

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatArrayEager.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.i.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.2.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.3.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.mergeDelayError.4.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.unsafeCreate.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.using.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.using.b.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.wrap.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.cache.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.cast.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.t.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.ts.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.doOnEvent.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.blockingGet.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.lift.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.contains.f.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.contains.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onErrorResumeWith.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.onTerminateDetach.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.f2.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.n.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.f.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retry.nf.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.retryWhen.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribe.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribe.c.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribe.cc.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribe.c2.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.subscribeWith.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.takeUntil.c.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.takeUntil.s.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.takeUntil.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeout.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeout.s.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeout.b.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.timeout.sb.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.unsubscribeOn.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.test.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.test.b.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.o.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.s.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.delaySubscription.c.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.dematerialize.png)

"David Karnokakarnokd10/11/19, 06:44:59 AM
6672.06674Question: Why a running computation thread got interrupted while window is finished"Why an active computation thread got interrupted while window is finished?
```
        Observable
            .intervalRange(0, 2, 0, 1, TimeUnit.SECONDS)
            .window(1, TimeUnit.SECONDS)
            .doOnNext(i -> {
                long start = System.currentTimeMillis();
                while (System.currentTimeMillis() < start+1500) {
                }
                if (Thread.interrupted()) {
                    System.out.println(""WTF? Thread is interrupted!"");
                }
            })
            .ignoreElements()
            .blockingAwait();
```
Is it a bug?""This is a shortcoming of the window operator that cancels the timer before terminating, which interrupts the long running code in `doOnNext`. 

A workaround would be to move the computation to yet another thread with `observeOn` so that the interrupt won't reach it.

I'll look into the termination and timer cancellation ordering to avoid such confusing interrupts. =||= Could you fix it for 2.x too? =||= If it can be fixed, both 2.x and 3.x will receive the fix. =||= "3.x: Fix window(time) possible interrupts while terminating"Fix the case in `window(time)` variants where the timer thread is busy with window emission and the upstream terminates on some other thread, the window emission is interrupted.

~~So instead of disposing the timer/worker right after the upstream termination, a `DISPOSE` message is queued up. Thus any ongoing drain loop from the timer thread can cleanup gracefully.~~

After some additional considerations, there is no need for `DISPOSE`. The drain loop will take care of disposing the timer and the main downstream can simply be terminated.

The 2.x fix will be in a separate PR shortly.

Fixes #6672"David Karnokakarnokd10/17/19, 04:23:41 PM
6673.06676NPE in SpscLinkedArrayQueue.clear due to concurrent invocation"Reported in https://github.com/ReactiveX/RxJava/issues/5927#issuecomment-542792421

```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 138(SpscLinkedArrayQueue.java:138)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)
       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber.cancel + 157(BasicFuseableConditionalSubscriber.java:157)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)
       at io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber.tryOnNext + 101(FlowableDistinctUntilChanged.java:101)
       at io.reactivex.internal.operators.flowable.FlowableMap$MapConditionalSubscriber.tryOnNext + 128(FlowableMap.java:128)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnConditionalSubscriber.runAsync + 649(FlowableObserveOn.java:649)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)
```

We just upgraded our project from 1.x, and did not see these errors in testing, but are seeing them in production.  We're working to figure out the exact cause, and will provide more information as we have it.

Here are some additional stack traces, in case you notice any pattern:
```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll + 155(SpscLinkedArrayQueue.java:155)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 145(SpscLinkedArrayQueue.java:145)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)
       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableConditionalSubscriber.cancel + 157(BasicFuseableConditionalSubscriber.java:157)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.cancel + 168(FlowableConcatMapMaybe.java:168)
       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)
       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.drain + 284(FlowableConcatMapMaybe.java:284)
       at io.reactivex.internal.operators.mixed.FlowableConcatMapMaybe$ConcatMapMaybeSubscriber.onNext + 137(FlowableConcatMapMaybe.java:137)
       at io.reactivex.internal.operators.flowable.FlowableDistinctUntilChanged$DistinctUntilChangedSubscriber.tryOnNext + 101(FlowableDistinctUntilChanged.java:101)
       at io.reactivex.internal.operators.flowable.FlowableMap$MapConditionalSubscriber.tryOnNext + 128(FlowableMap.java:128)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnConditionalSubscriber.runAsync + 649(FlowableObserveOn.java:649)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)
```
```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.newBufferPoll + 155(SpscLinkedArrayQueue.java:155)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 145(SpscLinkedArrayQueue.java:145)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)
       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.clear + 264(FlowableOnBackpressureBuffer.java:264)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.clear + 236(FlowableObserveOn.java:236)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.checkTerminated + 188(FlowableObserveOn.java:188)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync + 399(FlowableObserveOn.java:399)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)
       at io.reactivex.internal.schedulers.ScheduledRunnable.run + 66(ScheduledRunnable.java:66)
       at io.reactivex.internal.schedulers.ScheduledRunnable.call + 57(ScheduledRunnable.java:57)
```
```
Fatal Exception: java.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.Object java.util.concurrent.atomic.AtomicReferenceArray.get(int)' on a null object reference
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.lvElement + 251(SpscLinkedArrayQueue.java:251)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.poll + 138(SpscLinkedArrayQueue.java:138)
       at io.reactivex.internal.queue.SpscLinkedArrayQueue.clear + 186(SpscLinkedArrayQueue.java:186)
       at io.reactivex.internal.operators.flowable.FlowableOnBackpressureBuffer$BackpressureBufferSubscriber.cancel + 154(FlowableOnBackpressureBuffer.java:154)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.cancel + 154(FlowableObserveOn.java:154)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableSkipWhile$SkipWhileSubscriber.cancel + 93(FlowableSkipWhile.java:93)
       at io.reactivex.internal.subscribers.BasicFuseableSubscriber.cancel + 158(BasicFuseableSubscriber.java:158)
       at io.reactivex.internal.operators.flowable.FlowableElementAtSingle$ElementAtSubscriber.onNext + 85(FlowableElementAtSingle.java:85)
       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.tryOnNext + 74(FlowableFilter.java:74)
       at io.reactivex.internal.operators.flowable.FlowableFilter$FilterSubscriber.onNext + 52(FlowableFilter.java:52)
       at io.reactivex.internal.operators.flowable.FlowableSkipWhile$SkipWhileSubscriber.onNext + 56(FlowableSkipWhile.java:56)
       at io.reactivex.internal.operators.flowable.FlowableMap$MapSubscriber.onNext + 68(FlowableMap.java:68)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$ObserveOnSubscriber.runAsync + 407(FlowableObserveOn.java:407)
       at io.reactivex.internal.operators.flowable.FlowableObserveOn$BaseObserveOnSubscriber.run + 176(FlowableObserveOn.java:176)
```

The full chain for the last stack trace is:
```
Single.just(...)
  .delaySubscription(
    Completable.amb(
      listOf(
        Completable.timer(...),
        FlowableProcessor
          .map { ... }
          .onBackpressureBuffer()
          .compose { it.observeOn(...) }
          .map { ... }
          .observeOn(...)
          .map { ... }
          .skipWhile { ... }
          .filter { ... }
          .firstOrErrror()
          .ignoreElement()
      )
    )
      .toObservable<Any>()
  )
  .subscribeOn(...)
```""As far as I can tell, the chain for the second stack trace is:
```
FlowableProcessor
  .map { ... }
  .onBackpressureBuffer()
  .compose { it.observeOn(...) }
  .map { ... }
  .observeOn(...)
  .map { ... }
  .distinctUntilChanged()
  .concatMapMaybe { ... }
  .firstOrError()
```
which is a lot simpler.

In both cases, the `FlowableProcessor` is subscribed to `FlowableProcessor.onBackpressureBuffer().scan { ... }` =||= "3.x: Fix concurrent clear() calls when fused chains are canceled"When a fuseable source backed by an SpscLinkedArrayQueue is cancelled and cleared concurrently (i.e., one thread clears while the other cancels the chain), the `clear()` method could run concurrently and either crash with NPE or end up in an infinite loop due to corrupted queue state.

This PR fixes two kinds of mistakes leading to this scenario:

- Calling `clear()` from `cancel`/`dispose` when the output is fused.
- Calling `clear()` from a fused drain loop when cancellation is detected.

When fused, similar to `poll()`, calling `clear()` is the responsibility of the consumer and the producer side is not allowed to call them.

The bug affected the following operators:
- `FlowableOnBackpressureBuffer`
- `FlowableGroupBy`
- `UnicastProcessor`
- `UnicastSubject`

Fixes #6673"David Karnokakarnokd10/17/19, 01:44:38 PM
6679.066812.x: Backport marble fixes to Single"The main task is to locate the relevant methods and then copy-paste the `<img>` entry.

The diff in https://github.com/ReactiveX/RxJava/pull/6668/files should help.

In case of renamed operator(s), let me know and I'll post images for them.""I'll take this up :) =||= The two `using` methods taking a `Supplier` as resourceSupplier in 3.x are taking a `Callable` in 2.x. Can I use the same image for these methods?

I guess the only change from 2.x to 3.x is to use a Supplier rather than a Callable. So, I suppose the marble image need not have any change for 2.x

I'll send a PR once you confirm this =||= Use them for now, I'll create the appropriate images for them tomorrow. =||= Closing via #6681 =||= "Backport marble diagrams for Single from 3.x"This PR is to backport the marble images of Single class from 3.x. The method `onErrorResumeWith` does not exist in 2.x and hence I have left that out.

Closes #6679"Thiyagarajanthiyagu-710/18/19, 06:17:19 AM
6697.067003.x: update javadoc for observeOn to mention its eagerness"`Flowable.observeOn` and `Observable.observeOn` try to do as much event delivery as they can.
Add a section explaining this property to all these multi-valued `observeOn` overloads:

""This operator keeps emitting as many signals as it can on the given Scheduler's Worker thread, which may result in a longer than expected occupation of this thread. In other terms, it does not allow per-signal fairness in case the worker runs on a shared underlying thread. If such fairness and signal/work interleaving is preferred, use the `delay` operator with zero time instead.""

Also link to the `@see #delay(long,TimeUnit,Scheduler)`.""Hi! Do we only need to add the quoted message in both classes? I can do it if it is ok. =||= > I can do it if it is ok.

Sure.

> Do we only need to add the quoted message in both classes?

`Single`, `Maybe` and `Completable` can signal only one event and thus can't exhibit the property described. =||= Hi @akarnokd! Just one silly question: 

When you say 

> Add a section explaining this property to all these multi-valued observeOn overloads

You mean all but `observeOn(Scheduler scheduler)`, right?

In any case, I just created a PR with what I understood was required. Please, if there is something wrong let me know to fix it.

Thanks  =||= @akarnokd could you take a look at this?
https://github.com/Polidea/RxAndroidBle/issues/628
You can just test my last example, your suggestion to use `delay()` did not help me solve the problem. =||= "3.x: Update javadoc for observeOn to mention its eagerness"Update javadoc to reflect the eagerness property of `observeOn` in `Flowable` and `Observable` classes.

Resolves #6697 "Josemy DuarteJosemyDuarte11/04/19, 09:31:07 AM
6713.067142.x: Unexpected behaviour of MulticastProcessor with buffer size larger than 1"Multicastprocessor does not work as expected wrt. backpressure/request handling: 

With buffer size 1, everything is ok. However, for larger buffer sizes requests are no sent upstream if the amount of requests does not exactly match the buffer size or the amount of requests is a whole multiple of the buffer size.

The code below illustrates this behavior - the first example works just because the backpressure handling towards an FlowableFromArray seems to be handled differently.

We assume that there might be an issue in the drain() method of MulticastProcessor.
What's your opinion on this? Could this be a bug or does it work as designed?

Code that works as expected
---
```Java
MulticastProcessor<Integer> multicastProcessor = MulticastProcessor.create(2, true);
TestSubscriber<Integer> testSubscriber = TestSubscriber.create(0);

multicastProcessor.subscribe(testSubscriber);

Flowable.fromArray(1,2,3,4,5,6,7,8,9).subscribe(multicastProcessor);

testSubscriber.requestMore(3);
testSubscriber.requestMore(3);

assertEquals(Arrays.asList(1,2,3,4,5,6), testSubscriber.values()); // expected result
```

Code with unexpected behaviour
---
```Java
MulticastProcessor<Integer> multicastProcessor = MulticastProcessor.create(2, true);
TestSubscriber<Integer> testSubscriber = TestSubscriber.create(0);

multicastProcessor.subscribe(testSubscriber);

Flowable.fromArray(1,2,3,4,5,6,7,8,9)
    .doOnCancel(() -> System.out.println(""log that should not change behaviour""))
    .subscribe(multicastProcessor);

testSubscriber.requestMore(3);
testSubscriber.requestMore(3);

assertEquals(Arrays.asList(1,2,3,4), testSubscriber.values()); // unexpected result
```

Code that works again, after adjusting the request amount
---
```Java
MulticastProcessor<Integer> multicastProcessor = MulticastProcessor.create(2, true);
TestSubscriber<Integer> testSubscriber = TestSubscriber.create(0);

multicastProcessor.subscribe(testSubscriber);

Flowable.fromArray(1,2,3,4,5,6,7,8,9)
    .doOnCancel(() -> System.out.println(""log that should not change behaviour""))
    .subscribe(multicastProcessor);

testSubscriber.requestMore(2);
testSubscriber.requestMore(2);

assertEquals(Arrays.asList(1,2,3,4,5,6), testSubscriber.values()); // expected result
```

version
---
2.2.14
"Hi and thanks for the detailed use cases. Indeed this is a bug in the drain method as it does not write back the consumed amount. I'll post fixes shortly. =||= 3.x: Fix MulticastProcessor not requesting more after limit is reached"After reaching the prefetch limit, the updated `consumed` counter was not written back so the processor stopped requesting more (consumed > limit).

Affects 2.x to. A separate PR will be posted for it.

Resolves #6713"David Karnokakarnokd11/14/19, 11:06:35 PM
6641.067403.x: Change the behavior of Flowable.groupBy to signal MBE if no main requests"Currently, the `Flowable.groupBy` queues up groups until the downstream requests more groups. Unfortunately, this can lead to hangs because if there are more groups than requested, active groups may starve out as they don't trigger replenishments or those replenishments result in more groups to be created. Example:

```java
Flowable.range(1, 1000)
.groupBy(v -> v)
.flatMap(v -> v, 16)
.test()
.assertValueCount(1000)
.assertComplete();
```
This case works if `flatMap`'s concurrency level is greater or equal to the expected group count.

I propose changing the `Flowable.groupBy` operator to signal `MissingBackpressureException` if the direct downstream is not ready to receive more groups."This is a tough one. Many tests break because of the non-consumed groups or hang because of request management issues. I'll have to rework the tests and come up with the correct request management logic. =||= 3.x: Change Flowable.groupBy to signal MBE instead of possibly hanging"This PR changes the backpressure behavior of `Flowable.groupBy` to signal `MissingBackpressureException` instead of silently hanging if the produced groups are not ready to be accepted by the downstream. 

This can happen if one `flatMap`s a `groupBy` but there are more groups produced than the concurrency level of `flatMap`. Since replenishment is tied to item consumption from the groups, not consuming them can result in none of the groups receiving any further items and the whole operator hangs.

The following changes have been applied:

- Removed the queue from the main operator since it will now try to emit directly and not buffer groups.
- The main `Flowable`, lacking a queue, no longer supports operator fusion. Tests checking this property have been removed as well.
- When a group is drained, consumed items are replenished in batch if possible. Detecting a cancellation will also trigger a replenishment.
- When a group is pulled (fusion mode), now all `pull`, `isEmpty` and `clear` will trigger replenishment so that other groups can make progress too.
- Unit tests have been modified to have large enough bufferSize/prefetch amounts to allow them to pass.

Fixes #6641"David Karnokakarnokd12/06/19, 07:59:15 AM
6742.06745OSGi warning about io.reactivex.rxjava3.disposables using private"Since the OSGi update #6675, packaging the jar gives the [following warning](https://travis-ci.org/ReactiveX/RxJava/builds/620101751#L239):

```
warning: Export io.reactivex.rxjava3.disposables,  has 1,  private references [io.reactivex.rxjava3.internal.disposables]
```

I don't know why this package gets a warning but not `core`.

/cc @io7m"What this message is saying is that a class in the exported package `io.reactivex.rxjava3.disposables` references a class in the non-exported package `io.reactivex.rxjava3.internal.disposables`. This isn't _always_ indicative of a real problem - it might just indicate that your API classes are leaking implementation details -  but I'll take a look at it. =||= Thanks, it is likely due to the internal `DisposableContainer` interface referenced. I've moved it into public in #6745 and should no longer give a warning. =||= 3.x: Make DisposableContainer public API"Make the internal interface `DisposableContainer` public as it can be one safely.

(I've seen some 3rd party usage in custom containers, this will make them now legit on 3.x.)

**Edit**
Also [should resolve](https://travis-ci.org/ReactiveX/RxJava/builds/620175320#L219) the OSGi private reference warning.

Resolves #6742"David Karnokakarnokd12/03/19, 04:20:46 PM
6747.06748Is it assumed that CompositeException is eligible to modify the cause of exceptions passed in constructor of CompositeException?"Since RxJava modifies exceptions during call of `getCause` method of `CompositeException` instance and connect these exceptions in chains we have finally millions of exceptions and quickly getting out of memory.

```
    @Test
    public void compositeExceptionIssue() {
        Single
            .just(new Throwable(""ROOT ERROR""))
            .flatMapCompletable(rootError -> Observable
                .range(1, 10)
                .flatMapCompletable(testNumber -> Completable
                    .mergeArrayDelayError(
                        Completable.error(new RuntimeException(""Test#"" + testNumber + ""A"", rootError)),
                        Completable.error(new RuntimeException(""Test#"" + testNumber + ""B"", rootError))
                    )
                    .doOnError(Throwable::getCause)
                    .onErrorComplete()
                )
                .doOnComplete(() -> {
                    rootError.printStackTrace();
                })
            )
            .blockingAwait();
    }
```
This simple test demonstrates that  cause of `rootError` throwable is changed.""Do you mean those ""Caused by: java.lang.RuntimeException: Duplicate found in causal chain so cropping to prevent loop"" listings? =||= The `getCause` looks needlessly convoluted. I presume it was implemented that way that IDEs show some usable stacktraces of the individual inner exceptions. Java 7's `addSuppressed` is better in this regard but we can't use it just yet.

I can probably have such duplicate indicator show up at most once. =||= I mean that original exception is actually chained with other exceptions. `rootError.getCause()!=null` while expected to be null (in my option). =||= I see. To resolve it, we'd have to remove the custom `getCause` implementation otherwise it will keep touching all sorts of inner exceptions. We could also probably fake a `StackTraceElement` array containing all inner exceptions too. =||= Thanks for reporting. This is a shortcoming of the 1.x and 2.x composite design and I'm afraid we can only resolve this for 3.x because it is a breaking change in the structure of the composite verified by unit tests. =||= "3.x: Change how the cause of CompositeException is generated"This PR changes how `CompositeException.getCause` creates a cause exception on demand. In 1.x and 2.x, the code tried to link up the various inner exceptions via their `initCause`, which was in on itself fishy as well as could lead to excessive memory usage.

Instead, the new code will present the inner exceptions as part of a formatted message, which in theory, should be still picked up by IDE exception listings and allow navigation:

```
Multiple exceptions (2)
|-- io.reactivex.rxjava3.exceptions.TestException: ex3
    at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:341)
|-- io.reactivex.rxjava3.exceptions.TestException: ex4
    at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:342)
  |-- io.reactivex.rxjava3.exceptions.CompositeException: 2 exceptions occurred. 
      at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:337)
    |-- io.reactivex.rxjava3.exceptions.CompositeException.ExceptionOverview: 
        Multiple exceptions (2)
        |-- io.reactivex.rxjava3.exceptions.TestException: ex1
            at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:335)
        |-- io.reactivex.rxjava3.exceptions.TestException: ex2
            at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.nestedMultilineMessage(CompositeExceptionTest.java:336)
```

![image](https://user-images.githubusercontent.com/1269832/70315342-a9308600-1819-11ea-81d2-b56694dbd9e8.png)

There are a few formatting conveniences:
- If there is only one inner exception, the `CompositeException`'s cause will be simply that exception. This can happen when the very same exception is aggregated into the composite and get deduplicated.
- If an inner exception's message is multi-lined, the message and cause traces should be indented properly.
- Reoccurring causes are not expanded over and over:

```
Multiple exceptions (2)
|-- io.reactivex.rxjava3.exceptions.TestException: ex1
    at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.reoccurringException(CompositeExceptionTest.java:316)
  |-- io.reactivex.rxjava3.exceptions.TestException: ex0
      at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.reoccurringException(CompositeExceptionTest.java:315)
|-- io.reactivex.rxjava3.exceptions.TestException: ex2
    at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.reoccurringException(CompositeExceptionTest.java:319)
  |-- io.reactivex.rxjava3.exceptions.TestException: ex1
      at io.reactivex.rxjava3.exceptions.CompositeExceptionTest.reoccurringException(CompositeExceptionTest.java:316)
      |-- (cause not expanded again) io.reactivex.rxjava3.exceptions.TestException: ex0
```

Currently, only the first line of the stacktraces are shown because it can get quite long (and thus memory consuming) to list them all. Maybe a system parameter can be introduced to control the verbosity.

Fixes #6747"David Karnokakarnokd12/07/19, 09:36:21 PM
6753.067542.x: Zip, CombineLatest, and Amb operators throw when supplied with ObservableSource implementation that doesn't subclass Observable"Issue found in version 2.2.15.

The Zip, CombineLatest, and Amb operators of the `Observable` class each have an overload that accepts an `Iterable<ObservableSource>` and a `Function<Array<Any>, R>` where `R` is a type parameter. The problem is that the elements of the `Iterable` are copied into an `Observable[]` internally by the `Observer` classes implementing the operators. This causes an `ArrayStoreException` if one supplies any custom `ObservableSource` implementation that doesn't subclass `Observable`.

The equivalent functions for the other stream types don't have this restriction. I.e, the Zip implementation in `Maybe` copies the source values into a `MaybeSource[]` and avoids this problem.

Example kotlin code which reproduces the issue:
```kotlin
import io.reactivex.Observable
import io.reactivex.ObservableSource

val sourceA = ObservableSource<String> { Observable.just(""A"").subscribe(it) }
val sourceB = ObservableSource<String> { Observable.just(""b"", ""B"").subscribe(it) }

val combined =
    Observable.combineLatest(
       listOf(sourceA, sourceB),
       { (it[0] as String) + (it[1] as String) }
    )

fun main() {
    combined.subscribe(::println)
}
```
A simple workaround is to wrap any `ObservableSource`. To fix the above example pass `listOf(sourceA, sourceB).map { Observable.wrap(it) }` to `combineLatest`."Indeed the initial array for those has the wrong type. Would you like to post a PR? =||= Sure! I can whip up a PR in a bit. =||= 2.x: Zip, CombineLatest, and Amb operators throw when supplied with ObservableSource implementation that doesn't subclass ObservableFixes #6753Mark Sholtemgsholte12/11/19, 08:20:43 AM
6768.067733.x: [Java 8] Add FunctionalInterface annotations to our functional interfacesAnnotate interfaces in `io.reactivex.rxjava3.functions` and `io.reactivex.rxjava3.core`.Cool~ finally we are here. =||= Add FunctionalInterface annotations.Resolves #6768kerrhepin198912/17/19, 11:06:39 PM
6772.067803.x: [Java 8] Add Disposables.fromAutoCloseableSimilar to the other `Disposables.fromX`, add a variant that wraps an `AutoCloseable`.3.x: [Java 8] Add AutoCloseable <-> Disposable conversions, nicen docs"Add `Disposables.fromAutoCloseable` and `Disposables.toAutoCloseable` methods. Improve JavaDocs styling.

Resolves #6772
Resolves #6777"David Karnokakarnokd12/19/19, 05:18:06 PM
6777.067803.x: [Java 8] Add Disposables.toAutoCloseableAdd a wrapper that exposes a `Disposable` as an `AutoCloseable` to be used with `try-with-resources`.3.x: [Java 8] Add AutoCloseable <-> Disposable conversions, nicen docs"Add `Disposables.fromAutoCloseable` and `Disposables.toAutoCloseable` methods. Improve JavaDocs styling.

Resolves #6772
Resolves #6777"David Karnokakarnokd12/19/19, 05:18:06 PM
6794.067993.x: XProcessor.offer to throw NPE instead of signaling itChange the behavior to align with the standard `onXXX` methods.3.x: XProcessor.offer to throw NPE immediately"Make `offer` throw a `NullPointerException` immediately instead of turning it into an error signal. In addition, have `MulticastProcessor.offer` throw an `IllegalStateException` if called when the processor is in fusion mode.

Resolves #6794 "David Karnokakarnokd12/26/19, 10:43:57 PM
6784.068003.x: Add Flowable.blockingForEach overload with configurable prefetch"The default `blockingForEach` uses `blockingIterable` with its default prefetch. Add an overload that uses `blockingIterable(prefetch)` internally.

Also the **Backpressure** section of the current `blockingForEach` is wrong as `blockingIterable` is bounded."3.x: Add blockingForEach(Consumer, int) overload"The underlying `blockingIterable` already supported the custom prefetch overload and this PR exposes it as a new `blockingForEach` overload.

In addition, the Javadocs incorrectly stated `blockingForEach` operated in an unbounded-in fashion. It uses the usual stable-prefetch with 75% re-request amount.

Resolves #6784"David Karnokakarnokd12/26/19, 11:33:43 PM
6796.068013.x: Add validator to check the existence of throwIfFatal in a catch block"Scan `src/main/java` for the following pattern:

```java
} catch (Throwable 
Exceptions.throwIfFatal(
```

however, allow free pass for

```java
} catch (Throwable 
// Exceptions.throwIfFatal(
```
 As an indicator the fatals are handled in other ways."3.x: Add missing throwIfFatal calls"- Add missing `Exceptions.throwIfFatal` calls in `catch (Throwable ` blocks.
- Add validator that checks for the existence of these `throwIfFatal`, `wrapOrThrow` or `fail` calls.
- Fix `AutoCloseableDisposable` to use `wrapOrThrow` like the other `Disposable` wrapper implementations.

Resolves #6796"David Karnokakarnokd12/26/19, 11:55:37 PM
6811.068143.x: Remove fromFuture(..., Scheduler) overloadsThey basically simply just apply `subscribeOn`. 3.x: Remove fromFuture(..., Scheduler) overloads"Those overloads were only applying `subscribeOn` with no other benefits.

Resolves: #6811"David Karnokakarnokd01/07/20, 09:47:29 AM
6816.068173.x simple cleanup: Remove the duplicate Comparator in FunctionsIn `io.reactivex.rxjava3.internal.functions.Functions`, [this](https://github.com/ReactiveX/RxJava/blob/79f8e6dde6446b1aa33c146eaedbb958086daf56/src/main/java/io/reactivex/rxjava3/internal/functions/Functions.java#L154) and [this](https://github.com/ReactiveX/RxJava/blob/79f8e6dde6446b1aa33c146eaedbb958086daf56/src/main/java/io/reactivex/rxjava3/internal/functions/Functions.java#L523) look like the exact same thing. Is it worth it to delete one of them?Yes. PR welcome. =||= Deleted Functions.naturalOrder"Removes a duplication of the natural order comparator.

Resolves #6816"slisaasquatch01/07/20, 06:40:16 PM
6825.068272.x: Unexpected Flowable.flatMap(...) behavior while handling an upstream error"Hi,
 
I've discovered an unexpected behavior of the Flowable.flatMap() operator leading to a possible subscription leak. Localized my problem in the following scenario:
1. RxJava version 2.2.16.
2. Given a simple Rx chain of flowable1.flatMap(value -> flowable2).
3. flowable1 emits a value (so that flatMap subscribes to flowable2).
4. flowable1 emits an error.
Expected result: flatMap disposes flowable2 upon handling the upstream error.
Actual result: flowable2 remains subscribed after the entire Rx chain terminates because of the error.

Replacing the flatMap operator with concatMap fixes the problem (such a replacement is valid in my case). However I decided to raise this issue because such behavior of flatMap looks quite odd to me. Could somebody from RxJava team confirm whether my expectation is valid and the observed behavior is a defect?

I've reproduced this issue in a code snippet: https://gist.github.com/eugene-zolotko/b24cbc436bc0eab2ed5de539b9e4e312
I'm expecting this code to produce ""flowable2 cancelled"" output. But got ""flowable2 error"" instead, plus error2 gets thrown as UndeliverableException because it occurs after the entire chain is terminated.""Sources emitting an error are considered cancelled so it is completely legal to not call cancel on them. Use `doFinally` to cleanup upon all sorts of termination or cancellation. =||= Thank you for looking into this. But I'm afraid I wasn't specific enough in my question above. In the following code snippet I expected error2 to never get emitted because error1 terminates the entire flow sooner that flowable2 emits error2. However error2 actually fired (triggered an UndeliverableException). 

```
    final Exception error1 = new Exception(""1"");
    final Flowable<Integer> flowable1 = Flowable.just(1).delay(1, TimeUnit.SECONDS)
        .concatWith(Flowable.<Integer>error(error1).delaySubscription(1, TimeUnit.SECONDS));

    final Exception error2 = new Exception(""2"");
    final Flowable<Object> flowable2 =
        Flowable.error(error2).delaySubscription(2, TimeUnit.SECONDS)
            .doOnCancel(() -> System.out.println(""flowable2 cancelled""))
            .doOnError(error -> System.out.println(""flowable2 error""));

    flowable1.flatMap(i -> flowable2).test()
        .awaitDone(4, TimeUnit.SECONDS)
        .assertError(error1);
```

So my questions are: 
1. Is this an expected behavior? 2. Is there a way to avoid throwing error2 as an UndeliverableException  (except for intercepting it with RxJavaPlugins.setErrorHandler)? 3. What's the reason of the difference in behavior between flatMap and concatMap is such conditions? =||= 1. No, the inner sequence should get cancelled. I'll investigate this further.
2. Suppressing the error via `onErrorX` or not let RxJava know about the error in the first place
3. Should work the same. =||= Closing via #6826 & #6827. =||= Thank you very much for your support. =||= "2.x: Fix Flowable.flatMap not canceling the inner sources on outer error"The outer `onError` did not cancel the inner sources. The `Observable` variant works correctly but both received an unit test to verify the behavior.

Fixes: #6825 "David Karnokakarnokd01/09/20, 07:57:23 AM
6828.068373.x: Inline Observable.concatMapIterable and flatMapIterable"They can be implemented more efficiently than relying on `concatMap` or `flatMap`, similarly to how `Flowable` implements them.

In addition, the `bufferSize` overloads make no sense as the operation is completely synchronous and nothing is to be buffered. (In comparison, `Flowable.concatMapIterable` has to buffer the upstream items because the downstream may not be ready to consume the iterable.)"3.x: Remove a pointless Observable.concatMapIterable overload"Remove the `concatMapIterable(Function, int)` overload as there is no buffering involved with the operator.

Resolves #6828."David Karnokakarnokd01/13/20, 12:17:19 PM
6820.068383.x: Rename combineLatestDelayError(array) to combineLatestArrayDelayErrorLooks like the `Array` naming was not entirely consistent across operators.3.x: Rename to combineLatestArrayDelayError"The operator missed a rename with 2.x to match the `combineLatestArray` variant.

Resolves #6820"David Karnokakarnokd01/13/20, 12:17:36 PM
6766.068403.x: Add missing NonNull annotations to the standard methods"Including the return type, parameters and type argument usages on lambdas.
- [ ] `Flowable`
- [ ] `Observable`
- [ ] `Maybe`
- [ ] `Single`
- [ ] `Completable`
- [ ] `ParallelFlowable`

Please do them in separate PRs.""We can annotate the type arguments on our base interfaces and those should be enough for most of the usage places, however, some 3rd party interfaces need explicit annotations:

- `Publisher<@NonNull`
- `Iterable<@NonNull`
- `Stream<@NonNull`

The original pattern could be `Type<AnotherType` or `Type<? extends` locations. =||= "3.x: Add nullability annotations to type arguments"Annotate type argument use with `@NonNull`.

Resolves #6766"David Karnokakarnokd01/14/20, 07:49:54 AM
6821.06843"3.x: Reword javadocs saying the operator ""modifies"" the current source""Reactive sources are immutable so there is no modification, only wrapping and composition. The wording ""modifies"" is an old remnant.

Also reword ""instructs"" type of docs."3.x: Improve wording of operators"- Reword sentences with ""modifies"" and ""instructs"".
- Reword ""the source X"" to ""the current X"".
- Reword a couple of other operator sentences.

Related #6819 
Resolves #6821"David Karnokakarnokd01/14/20, 11:47:15 AM
6842.068443.x: Remove the remaining onExceptionResumeNext operator(s)Apparently, `Maybe.onExceptionResumeNext` was not removed back then.3.x: Remove Maybe.onExceptionResumeNext"It was always very peculiar to let only checked exceptions resumed.

Resolves #6842"David Karnokakarnokd01/14/20, 01:16:07 PM
6830.068463.x: Remove duplicate unit tests that check null arguments on standard operators"The `ParamValidationCheckerTest` verifies the `null` checks on arguments so there is no longer need for individual unit test methods doing it too. These kinds tests should be identifiable by `expected = NullPointerException.class` or `catch (NullPointerException`

- [x] `Flowable`
- [x] `Observable`
- [x] `Maybe`
- [x] `Single`
- [x] `Completable`
- [x] `ParallelFlowable`"Deleted unnecessary NPE tests"Resolves #6830

I have kept tests that arbitrarily throw NPEs like [this one](https://github.com/ReactiveX/RxJava/blob/0bd2a0152b64723ac3daf3e2fbad3d59c7f3bbb8/src/test/java/io/reactivex/rxjava3/completable/CompletableTest.java#L375), and tests with `Iterable`s that return null `Iterator`s like [this one](https://github.com/ReactiveX/RxJava/blob/0bd2a0152b64723ac3daf3e2fbad3d59c7f3bbb8/src/test/java/io/reactivex/rxjava3/flowable/FlowableNullTests.java#L61)."slisaasquatch01/14/20, 09:24:01 PM
6834.068473.x: Replace the verbose @return entires with simpler ones"Many operator's documentation repeats (more or less) its first sentence as part of `@return`. This adds unnecessary verbosity, opportunity for them to become desynced and is extra effort to maintain. 

Instead, they should be as simple as `@return the new {@code Type} instance`.

- [ ] `Flowable`
- [ ] `Observable`
- [ ] `Maybe`
- [ ] `Single`
- [ ] `Completable`
- [ ] `ParallelFlowable`

`\@return (?!the new)`"3.x: Simplify @return sentences in Flowable JavaDocs"Simplify the wording of `@return` in JavaDocs.

Resolves #6834"David Karnokakarnokd01/16/20, 08:08:33 AM
6832.068533.x: Validate argument naming consistency between base class methods"Operator argument naming should match between base classes on the same operators.

For example `Observable::buffer(boundary)` vs. `Flowable::buffer(boundaryIndicator)`.

Source-level comparison would be too complicated so reflection can be used for this, provided the class saves the argument names. Javac 8 has this option that must be enabled in the IDE and in `build.gradle`:

```groovy
[compileJava, compileTestJava]*.options*.compilerArgs << ""-parameters""

tasks.withType(JavaCompile) {
    options.compilerArgs << ""-parameters"";
}
```

An extra test is preferrable to remind users enabling this option:

```java
    void method(int paramName) {
        // deliberately empty
    }

    @Test
    public void javacParametersEnabled() throws Exception {
        assertEquals(""Please enable saving parameter names via the -parameters javac argument"",
                ""paramName"",
                getClass()
                .getDeclaredMethod(""method"", Integer.TYPE)
                .getParameters()[0].getName());
    }
```
There are some common operator names across all base classes, these should match as well."3.x: Fix method argument naming across types"Make method argument naming consistent between the base reactive classes, adjust some of the naming for all.

In addition, the null-check was missing from `blockingMostRecent`.

Resolves #6832 

The utility program has to be run manually to list the inconsistencies. The remaining inconsistency is due to `merge` because its argument is `sources` for `Flowable`/`Observable` but `source` for `Single`/`Maybe` nested."David Karnokakarnokd01/21/20, 01:26:16 PM
6854.068563.x: Rename Single.equals to Single.sequenceEqualFor consistent naming.Rename Single.equals to Single.sequenceEqual"Renamed Single.equals to Single.sequenceEqual and renamed argument names for consistent naming.

Resolves #6854"slisaasquatch01/21/20, 09:21:10 PM
6855.068573.x: [Wiki] Enhance Operator-Matrix generation with anchors and explanations"https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

I've turned the column headers to images rotated 90 degrees so the table doesn't overflow the wiki layout.

The `src/test/java/io/reactivex/rxjava3/internal/util/OperatorMatrixGenerator.java` should be updated accordingly, plus:

- Add HTML anchors to the rows so they can be navigated to via `#methodName`
- Add `<sup>[N](#note-N)</sup>` to absent entries and a list of notes below the table explaining why. For this, the reason mapping has to be added to the generator."Closing via #6857 =||= 3.x: [Wiki] Improve Operator-Matrix with links and notes"Update the `OperatorMatrixGenerator` to add anchors and links to notes about why operators are not present in one or another class.

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

Some operators are missing and will be added as part of #6852.

Resolves #6855."David Karnokakarnokd01/22/20, 01:03:54 PM
6829.068603.x: Ensure delegating operator overloads list all relevant @throws too in their Javadocs"The current `ParamValidationNaming` can only check explicit argument validation (i.e., the method body lists `requireNonNull` or `verifyPositive`) but not overloads delegating to those methods thus lacking the explicit argument validation themselves.

I don't think this can be automated, therefore, each base reactive class' source should be manually examined and expanded with the missing `@throws` declaration:

- [x] `Flowable`
- [x] `Observable`
- [x] `Maybe`
- [x] `Single`
- [x] `Completable`
- [x] `ParallelFlowable`

(There is currently an `Observable` cleanup PR in the works, please wait for it before doing this issue.)

**Edit**

Perhaps checking if the typical method parameter names, such as `bufferSize`, `prefetch`, `capacityHint`, `source*`, `mapper`, `predicate`, etc. appear in `@throws` declaration."3.x: Add last missing throws tag to JavaDocs"Added the last missing `@throws` tag to methods and one missing `@NonNull` annotation.

I included a small program that will list JavaDocs without `@throws` for future use.

Resolves #6829"David Karnokakarnokd01/22/20, 04:37:15 PM
6863.068643.x: Maybe.delay has no `delayError` option unlike `Single`It defaults to always delay an error.Adding delayError to Maybe.delayResolves #6863 Paul Estradapestrada01/24/20, 07:41:41 AM
6852.068873.x: Missing operators (tracking issue)"https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix

https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#under-development

Operators present in some but not other classes (when they make sense there too):

- [x] `Completable.concatArrayDelayError`
- [x] `Completable.blockingSubscribe`
- [x] `Completable.doOnLifecycle`
- [x] `Completable.onErrorResumeWith`
- [x] `Completable.onErrorReturn`
- [x] `Completable.onErrorReturnItem`
- [x] `Completable.retryUntil`
- [x] `Completable.safeSubscribe`
- [x] `Completable.sequenceEqual`
- [x] `Completable.startWith` (`MaybeSource`, `SingleSource`)
- [x] `Completable.switchOnNext`
- [x] `Completable.switchOnNextDelayError`
- [x] `Completable.toFuture`
- [x] `Maybe.blockingSubscribe`
- [x] `Maybe.concatArrayEagerDelayError`
- [x] `Maybe.concatMapCompletable`
- [x] `Maybe.concatMapSingle`
- [x] `Maybe.dematerialize`
- [x] `Maybe.fromObservable`
- [x] `Maybe.doOnLifecycle`
- [x] `Maybe.fromPublisher`
- [x] `Maybe.safeSubscribe`
- [x] `Maybe.startWith` 
- [x] `Maybe.timeInterval`
- [x] `Maybe.timestamp`
- [x] `Maybe.toFuture`
- [x] `Maybe.switchOnNext`
- [x] `Maybe.switchOnNextDelayError`
- [x] `Single.blockingSubscribe`
- [x] `Single.concatArrayDelayError`
- [x] `Single.concatArrayEagerDelayError`
- [x] `Single.concatDelayError`
- [x] `Single.concatMap`
- [x] `Single.concatMapCompletable`
- [x] `Single.concatMapMaybe`
- [x] `Single.doOnLifecycle`
- [x] `Single.fromMaybe`
- [x] `Single.mergeArray`
- [x] `Single.mergeArrayDelayError`
- [x] `Single.ofType`
- [x] `Single.onErrorComplete`
- [x] `Single.retryUntil`
- [x] `Single.safeSubscribe`
- [x] `Single.sequenceEqual` (rename `equals`)
- [x] `Single.startWith` 
- [x] `Single.timeInterval`
- [x] `Single.timestamp`
- [x] `Single.switchOnNext`
- [x] `Single.switchOnNextDelayError`
- [x] `Flowable.fromAction`
- [x] `Flowable.fromCompletable`
- [x] `Flowable.fromMaybe`
- [x] `Flowable.fromObservable`
- [x] `Flowable.fromRunnable`
- [x] `Flowable.fromSingle`
- [x] `Flowable.onErrorComplete`
- [x] `Flowable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)
- [x] `Observable.fromAction`
- [x] `Observable.fromCompletable`
- [x] `Observable.fromMaybe`
- [x] `Observable.fromRunnable`
- [x] `Observable.fromSingle`
- [x] `Observable.onErrorComplete`
- [x] `Observable.startWith` (`MaybeSource`, `SingleSource`, `CompletableSource`)""Can I work on it?
 =||= @souraexx Sure, pick one. I'm currently working on all `onErrorComplete`s. =||= "3.x: Add safeSubscribe to Maybe, Single & Completable"Add the final missing method, `safeSubscribe` to `Maybe`, `Single` & `Completable`.

Resolves #6852"David Karnokakarnokd01/28/20, 11:06:38 AM
6865.068883.x: Check Maybe/Single/Completable operators delegating to Flowable ops"Some operators in `Maybe`, `Single` and `Completable` are delegating to `Flowable` operators that may not be the best fit. For example:

```java
    public static <T> Flowable<T> merge(@NonNull Publisher<@NonNull ? extends MaybeSource<? extends T>> sources, int maxConcurrency) {
        Objects.requireNonNull(sources, ""sources is null"");
        ObjectHelper.verifyPositive(maxConcurrency, ""maxConcurrency"");
        return RxJavaPlugins.onAssembly(new FlowableFlatMapPublisher(sources, MaybeToPublisher.instance(), false, maxConcurrency, 1));
    }
```

Can now be:

```java
       return RxJavaPlugins.onAssembly(new FlowableFlatMapMaybe<>(sources, Functions.identity(), false, maxConcurrency)
```

But, since `FlowableFlatMapMaybe` takes a `Flowable<T>`, not a `Publisher<T>`, a new simple class should be created (`FlowableFlatMapMaybePublisher`) that takes a `Publisher<T>` but reuses the internals of `FlowableFlatMapMaybe`."3.x: Use more appropriate operators when delegating to Flowable ops"Many `Single` and `Maybe` operators delegate to `Flowable` operators. This PR makes sure they use the most appropriate ones since there are `Single`- and `Maybe`-specific operators on `Flowable` for some time now.

Some concatenating non-delayed Single operators now use the `Flowable.concatMapSingleDelayError(Functions.identity(), false)` because an array or `Iterable` of `Single`s can't just throw anytime like a `Publisher<Single<T>>`'s `Publisher` could, hence a delay-error until boundary mode works the same but without the extra coordination of the more general `Publisher` variant.

Resolves #6865

`Completable` didn't have any delegation required changing."David Karnokakarnokd01/28/20, 02:59:55 PM
6872.068903.x: Create a tool that scans the java sources and checks marble dimensions"Create a manually runnable tool (in `internal.util`) that walks through the java sources of the base classes, parses out the `<img width="""" height="""" src=""""/>`, downloads the referenced image and verifies that `height` is set properly. 

More specifically, `round(640.0/image.width * image.height)` and prints a fake stacktrace element to the particular line and the right amount. It is recommended the download is somewhat rate-limited (1 per 100ms) because the sheer number of images. The same reason applies why this isn't an unit test to be. Use `TestHelper.findSource()` to locate the source java.
"3.x: Fix marble dimensions, add program that checks them"Resolves #6872

Also added 2 diagrams missing

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapMaybe.o.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/switchMapMaybeDelayError.o.png)

and fixed 1 diagram wrongly exported

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Completable.concatArrayDelayError.png)"David Karnokakarnokd01/28/20, 03:32:13 PM
6878.068913.x: Swap Maybe.flatMapSingle and Maybe.flatMapSingleElement ?"Currently, `flatMapSingle` returns `Single` and signals `NoSuchElementException` if the source `Maybe` is empty. `flatMapSingleElement` remains `Maybe`.

I'd consider renaming `flatMapSingle` to `flatMapSingleOrError` and `flatMapSingleElement` to `flatMapSingle` as I think a default `Maybe` -> `Maybe` transformer should better match the other such transformers.

Alternatively, drop `flatMapSingle` and rename `flatMapSingleElement` to `flatMapSingle` so that the original behavior could be achieved via `flatMapSingle.toSingle())`.""Personally I'm in favor of dropping the old `flatMapSingle` and renaming `flatMapSingleElement`, because I found the behavior of the old `flatMapSingle` surprising at first, and using `toSingle().flatMap()` is more readable. =||= Let's drop `flatMapSingle` and rename `flatMapSingleElement`. 

@slisaasquatch would you like to post a PR? If so, please keep the unit tests and use `flatMapSingle().toSingle()`. =||= "3.x: Swap Maybe.flatMapSingle and Maybe.flatMapSingleElement"Resolves #6878

Dropped the old `Maybe.flatMapSingle` and replaced it with `Maybe.flatMapSingleElement`"slisaasquatch01/28/20, 08:32:21 PM
6892.068933.x: Reenable XFlatMapTest.maybeSingleThere is a small behavior difference between `Flowable.flatMap` and `Maybe.flatMapSingle` that made the test fail. Namely, the effect of disposing before the function returns the inner source.3.x: Reenable XFlatMapTest.maybeSingle, add missing Single operators"Reenable the `XFlatMapTest.maybeSingle` and make sure all flatMap variants behave the same when the flow is cancelled/disposed while the mapper function is executing, thus the returned inner source doesn't get subscribed to at all.

Resolves #6892

While adding the extra tests, I noticed two `flatMap` variant is missing from `Single`:

- A combiner of the original and inner success item: `flatMap(Function<T, Single<U>>, BiFunction<T, U, R>)`
- A notification-type mapper: `flatMap(Function<T, Single<R>>, Function<Throwable, Single<R>>)`

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.combiner.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.flatMap.notification.png)

Lastly, the same combiner variant for `Maybe` received a marble diagram too:

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMap.combiner.png)

Related #5806"David Karnokakarnokd01/29/20, 11:52:14 AM
6889.068942.x: Unexpected behaviour of GroupBy operator wrt. request handling"The groupBy operator does not work as expected wrt. request handling.
If a subscriber of one of the GroupedFlowables is cancelled, the buffer space occupied by this GroupedFlowable is not released. 

The code below illustrates this behavior:

### Code
```java
        List<TestSubscriber> listOfSubscribers = new ArrayList<>();

        Flowable.range(1, 1000)
            .doOnNext(n -> System.out.printf(""onNext (%d) \n"", n))
            .doOnRequest(r -> System.out.printf(""%d requests send \n"", r))
            .groupBy(integer -> integer % 10)
            .subscribe(groupedFlowable -> {
                TestSubscriber<Integer> subscriber = TestSubscriber.create(0);
                listOfSubscribers.add(subscriber);
                groupedFlowable.subscribe(subscriber);
            });
```
### output result
```java
        128 requests send 
        onNext (1) 
        1 requests send 
        onNext (2) 
        1 requests send 
        onNext (3) 
        1 requests send 
        onNext (4) 
        1 requests send 
        onNext (5) 
        1 requests send 
        onNext (6) 
        1 requests send 
        onNext (7) 
        1 requests send 
        onNext (8) 
        1 requests send 
        onNext (9) 
        1 requests send
        onNext (10) 
        1 requests send 
        onNext (11) 
        onNext (12) 
        onNext (13) 
        ...
        onNext (136) 
        onNext (137) 
        onNext (138)
```
As I expected, the buffer is filled up with items until the buffer is completly full and, as a result, requests are no longer signalled to upstream

If I add a line of code which cancels all TestSubscribers I would expect that the groupBy operator signals 128 requests to upstream, because the buffer should be empty again. However this is not the case, and cancelling all TestSubscribers has no effect on the result.

### Modified code with same output
```java
        List<TestSubscriber> listOfSubscribers = new ArrayList<>();

        Flowable.range(1, 1000)
            .doOnNext(n -> System.out.printf(""onNext (%d) \n"", n))
            .doOnRequest(r -> System.out.printf(""%d requests send \n"", r))
            .groupBy(integer -> integer % 10)
            .subscribe(groupedFlowable -> {
                TestSubscriber<Integer> subscriber = TestSubscriber.create(0);
                listOfSubscribers.add(subscriber);
                groupedFlowable.subscribe(subscriber);
            });

        listOfSubscribers.forEach(TestSubscriber::cancel);
```
What's your opinion on this? Could this be a bug or does it work as designed?
Thank you""This is a shortcoming of the 2.x implementation and should be fixed in the latest 3.x release candidate (RC-8). 

Since there were other changes to `groupBy` in 3.x, I have to look into if the resolution to this particular behavior can be backported or not. Until then, it would be great if you checked your setup with the RC-8. =||= "2.x: Fix groupBy not requesting more if a group is cancelled with buffered items"If a group is cancelled with unconsumed item in its buffer, the operator stopped requesting more thus hanging other groups.

The fix is to count how many items are still in the buffer upon cancellation, and issue a request for them for the parent.

Fixes #6889"David Karnokakarnokd01/29/20, 10:57:12 AM
5806.068973.x: Maybe incorrect or missing marbles (tracking issue)"- [x] `amb`: missing diagram
- [x] `ambArray`: missing diagram
- [x] `concat(Iterable)`: missing diagram
- [x] `concat(Publisher)`: missing diagram
- [x] `concat(Publisher, int)`: missing diagram
- [x] `concatArray`: missing diagram
- [x] `concatArrayDelayError`: indicate error delayed, 1 marble per source
- [x] `concatArrayEager`: missing diagram
- [x] `concatDelayError(Iterable)`: missing diagram
- [x] `concatDelayError(Publisher)`: missing diagram
- [x] `concatDelayError(Publisher, int)`: fix overlap/misalignment inside the operator box
- [x] `concatEager(Iterable)`: missing diagram
- [x] `concatEager(Publisher)`: missing diagram
- [x] `create`: missing diagram
- [x] `defer`: missing diagram
- [x] `error(Callable)`: indicate callable returns the error
- [x] `fromAction`: missing diagram
- [x] `fromCompletable`: missing diagram
- [x] `fromSingle`: missing diagram
- [x] `fromCallable`: missing diagram
- [x] `fromFuture(Future)`: operator name in the box, indicate Future is the parameter
- [x] `fromFuture(Future, long, TimeUnit)`: operator name in the box, indicate Future is the parameter, indicate timeout
- [x] `fromRunnable`: missing diagram
- [x] `merge(Iterable)`: missing diagram
- [x] `merge(Publisher)`: missing diagram
- [x] `merge(Publisher, int)`: missing diagram
- [x] `mergeArray`: missing diagram
- [x] `mergeArrayDelayError`: one marble per Maybe source
- [x] `mergeDelayError(Iterable)`: one marble per Maybe source
- [x] `mergeDelayError(Publisher)`: one marble per Maybe source
- [x] `mergeDelayError(Maybe, Maybe, ...)`: one marble per Maybe source
- [x] `sequenceEqual` + 1: result should be `Single`.
- [x] `timer` + 1: result should be Maybe
- [x] `using` + 1: rework to indicate the created Maybe
- [x] `wrap`: missing marble
- [x] `zip(Iterable)`: one marble per Maybe source, result should be Maybe
- [x] `zip(Maybe, Maybe, ...)` + 8: one marble per Maybe source, result should be Maybe
- [x] `zipArray`: one marble per Maybe source, result should be Maybe
- [x] `ambWith`: one marble per Maybe source, result should be Maybe
- [x] ~~`as`: missing diagram~~ operator removed
- [x] `blockingGet` + 1: missing diagram
- [x] `cache`: one marble per Maybe source, result should be Maybe
- [x] `cast`: missing diagram
- [x] `compose`: missing diagram
- [x] `concatMap`: indicate Maybe target, indicate empty source
- [x] `concatWith`: one marble per Maybe source, result should be Maybe, operator name, indicate other is a parameter
- [x] `contains`: one marble per Maybe source, result should be Single, empty case
- [x] `count`: one marble per maybe, operator name, result should be Single, empty case
- [x] `defaultIfEmpty`: non-empty case, result should be Maybe
- [x] `delay(time)` + 3: one marble per Maybe source, result should be Maybe
- [x] `delay(Publisher)`: one marble per Maybe, one signal by the Publisher, empty publisher case
- [x] `delaySubscription(Publisher)`: missing diagram
- [x] `delaySubscription(time)` + 1: one marble per Maybe source, result should be Maybe
- [x] `doAfterSuccess`: missing diagram
- [x] `doAfterTerminate`: operator name, one marble per Maybe, result should be Maybe
- [x] `doFinally`: missing diagram
- [x] `doOnDispose`: missing diagram
- [x] `doOnComplete`: one marble per Maybe, result should be Maybe
- [x] `doOnError`: missing diagram
- [x] `doOnEvent`: missing diagram
- [x] `doOnSubscribe`: missing diagram
- [x] `doOnSuccess`: missing diagram
- [x] `doOnTerminate`: one marble per Maybe, result should be Maybe
- [x] `filter`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, Function, Callable)`: one marble per Maybe, result should be Maybe
- [x] `flatMap(Function, BiFunction)`: one marble per Maybe, result should be Maybe
- [x] `flatMapObservable`: should be mapped into an Observable
- [x] `flatMapPublisher`: indicate backpressure
- [x] `flatMapSingle`: indicate empty maybe results in error
- [x] `flatMapSingleElement`: operator name, indicate empty maybe
- [x] `flatMapCompletable`: indicate empty maybe
- [x] `hide`: missing diagram
- [x] `ignoreElement`: operator name, one marble per Maybe, result should be Maybe
- [x] `isEmpty`: result should be Single
- [x] `mergeWith`: operator name, one marble per Maybe, indicate backpressure
- [x] `ofType`: one marble per Maybe
- [x] `onErrorComplete` + 1: missing diagram
- [x] `onErrorResumeNext`: one marble per Maybe, result should be Maybe
- [x] `onErrorResumeWith`: one marble per Maybe, result should be Maybe
- [x] `onErrorReturn`: one marble per Maybe, result should be Maybe, indicate callback
- [x] `onErrorReturnItem`: operator name, one marble per Maybe, result should be Maybe, indicate normal outcome
- [x] ~~`onExceptionResumeNext`: operator takes a Maybe source directlyˇ~~ operator removed
- [x] `onTerminateDetach`: missing diagram
- [x] `repeat` + 1: one marble per source, indicate backpressure, indicate repeat conditions
- [x] `repeatUntil`: operator name, repeat condition, indicate backpressure
- [x] `repeatWhen`: one marble per Maybe, indicate backpressure
- [x] `retry` + 2: one marble per Maybe, result should be Maybe, indicate repeat conditions
- [x] `retry(int, Predicate)`: missing diagram
- [x] `retry(Predicate)`: missing diagram
- [x] `retryUntil`: missing diagram
- [x] `retryWhen`: one marble per Maybe, output should be Maybe
- [x] `switchIfEmpty` + 1: improve diagrams, indicate argument type
- [x] `takeUntil` + 1: one marble per Maybe, output should be Maybe
- [x] `timeout` + 3: one marble per Maybe, output should be Maybe
- [x] `timeout(MaybeSource)`: missing diagram
- [x] `timeout(MaybeSource, MaybeSource)`: missing diagram
- [x] `timeout(Publisher)`: missing diagram
- [x] `timeout(Publisher, MaybeSource)`: missing diagram
- [x] `to`: missing diagram
- [x] `toFlowable`: missing diagram
- [x] `toObservable`: missing diagram
- [x] `toSingle` + 1: missing diagram
- [x] `unsubscribeOn`: missing diagram
- [x] `zipWith`: one marble per Maybe, output should be Maybe"Here is the Excel file I draw the diagrams in: https://drive.google.com/file/d/1di67kFJEuiLPyq14JlnV3vFl-muaCMfH/view?usp=sharing =||= 3.x: Add remaining Maybe marbles (+50)"Resolves #5806 

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.ambWith.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingGet.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.blockingGet.v.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.cache.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.compose.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatWith.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.count.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/MAybe.defaultIfEmpty.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.t.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.tb.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.ts.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.delay.tsb.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doAfterSuccess.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doAfterTerminate.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doFinally.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnDispose.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnSubscribe.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.doOnTerminate.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapObservable.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.flatMapPublisher.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.isEmpty.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.mergeWith.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeat.n.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeat.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeatUntil.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.repeatWhen.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.f.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.g.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.n.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.nf.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retry.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.retryWhen.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchIfEmpty.m.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.switchIfEmpty.s.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.takeUntil.m.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.takeUntil.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.m.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.mm.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.pm.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.t.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.tm.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.ts.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.timeout.tsm.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.to.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toFlowable.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toObservable.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.toSingle.png)"David Karnokakarnokd01/29/20, 05:42:52 PM
6880.068993.x: Add concatEagerDelayError across`concatEager` [is available](https://github.com/ReactiveX/RxJava/wiki/Operator-Matrix#concatEager) but its delay-error variant is missing.3.x: Add concatEagerDelayError across"`Flowable`, `Observable`, `Maybe` and `Single` now have a `concatEagerDelayError`, delegating to the appropriate `concatMapEagerDelayError` operator.

In addition, `Maybe` and `Single` received an overload `concatEager(Iterable, int)` to expose the `maxConcurrency` option already present in the rest of the types.

Note that `Completable.concatEagerDelayError` is essentially the same as `mergeDelayError` because there are no items to keep emitting in order.

Resolves #6880

The `Flowable` and `Observable` variant of `concatEager` also received fresh marble diagrams. (Related #5813)

#### Flowable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.i.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.in.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEager.pn.png)

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.i.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.in.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.concatEagerDelayError.pn.png)

----

#### Observable

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.i.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.in.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.o.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEager.on.png)

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.i.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.in.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.o.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.concatEagerDelayError.on.png)

----

#### Maybe

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.in.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEager.pn.png)

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.i.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.in.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.concatEagerDelayError.pn.png)

----

#### Single

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEager.in.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEager.pn.png)

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEagerDelayError.i.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEagerDelayError.in.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEagerDelayError.p.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Single.concatEagerDelayError.pn.png)"David Karnokakarnokd01/30/20, 03:14:13 PM
6900.06903"3.x: Add ""error handling"" section to Observable.blockingFirst""It looks like the only blockingX method [missing](http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html#blockingFirst--) an error handling section. The other variants (`blockingLast` & `blockingSingle`) in `Observable` do have it (as well as in [`Flowable`](http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html#blockingFirst--).

Just copy the relevant dt/dd section over."3.x: Add 'Error handling' section to Observable.blockingFirst JavaDocs"Add missing JavaDocs section.

Resolves #6900"Víctor Julián García Granadovjgarciag9602/09/20, 04:31:20 PM
6914.06917Flowable.Switchmap sometimes doesn't unsubscribe from inner stream"RxJava version - 2.2.18.

Sometimes, when the inner flowable emits >1 item, the unsubscription from the outer chain after receiving the first item doesn't trigger the unsubscription from the inner Flowable.
The completion of the outer chain also doesn't trigger the `finally` of the inner Flowable.
This doesn't happen if I replace Flowable with Observable.

Sorry for the pretty dumb example code, but not sure how to illustrate the problem better.

So the expected result would be that `Outer finally` and `Inner finally` both printed `10000` times.
What happens is that `Inner finally` is sometimes not printed, and the subscription to the inner flowable remains hanging, even though the outer chain has completed.
On my machine this test produces around 9970 - 9990 `Inner finally` results instead of 10000 (It varies from run to run).

```Kotlin
    private val inner = AtomicInteger()
    private val outer = AtomicInteger()

    @Test
    fun test() {
        repeat(10_000) {
            thread {
                Flowable.create<Unit>({
                    it.onNext(Unit)
                }, BackpressureStrategy.LATEST)
                    .switchMap { createFlowable() }
                    .observeOn(Schedulers.computation())
                    .doFinally {
                        println(""Outer finally"")
                        outer.incrementAndGet()
                    }
                    .take(1)
                    .subscribe({}, Throwable::printStackTrace)
            }.join()
        }

        assert(inner.get() == outer.get())
    }

    private fun createFlowable(): Flowable<Unit> {
        return Flowable
            .create<Unit>({
                Schedulers.io().scheduleDirect({
                    it.onNext(Unit)
                }, 10, TimeUnit.MILLISECONDS)

                Schedulers.io().scheduleDirect({
                    it.onNext(Unit)
                }, 10, TimeUnit.MILLISECONDS)
            }, BackpressureStrategy.BUFFER)
            .subscribeOn(Schedulers.single())
            .unsubscribeOn(Schedulers.single())
            .doFinally {
                println(""Inner finally"")
                inner.incrementAndGet()
            }
    }
```""You are invoking the emitter's `.onNext(Unit)` concurrently in the inner `Flowable`, which is not allowed. The [JavaDocs](http://reactivex.io/RxJava/2.x/javadoc/io/reactivex/FlowableEmitter.html) also mentions this:

> The Emitter.onNext(Object), Emitter.onError(Throwable), tryOnError(Throwable) and Emitter.onComplete() methods should be called in a sequential manner, just like the Subscriber's methods. Use the FlowableEmitter the serialize() method returns instead of the original FlowableEmitter instance provided by the generator routine if you want to ensure this. The other methods are thread-safe. =||= Do I understand it right that if I serialize this emitter, it should work?
The test still fails.

Edit: if I change the scheduler to `Schedulers.single` it still fails, although this scheduler executes tasks sequentially

```Kotlin
            Flowable
            .create<Unit>({
                val serializedEmitter = it.serialize()

                Schedulers.single().scheduleDirect({
                    serializedEmitter.onNext(Unit)
                }, 10, TimeUnit.MILLISECONDS)

                Schedulers.single().scheduleDirect({
                    serializedEmitter.onNext(Unit)
                }, 10, TimeUnit.MILLISECONDS)
            }, BackpressureStrategy.BUFFER)
``` =||= You start the flow in a `Thread` and even though you join onto it, the `take(1).subscribe()` will keep running after. Once all 10000 such threads have apparently ended, you compare the counters of some still live outer and inner sources thus there is an inherent race between the two counters as well as the test thread itself. 

Try using `blockingSubscribe` and see if you now get all 10000 across each counter at the end. =||= Yeah the test is flawed probably, but it fails with `blockingSubscribe()` as well.
Or if I put a `Thread.sleep` before the assertion
 =||= Or you can forget the counters I added and just check the console output, it will always lack Inners anyway =||= Thanks for the feedback. After investigating, I found a bug in the operator's implementation: when timed right, the reference to the inner gets nulled out before the cancellation could reach it. This null shouldn't actually happen.

I'll post fixes shortly. =||= Wow, great, thank you for the quick fix =||= "3.x: Fix Flowable.switchMap not canceling properly during onNext-cancel races"There was an unnecessary `active.lazySet(null)` which prevented cancellation of the inner source under some circumstances.

More specifically, when one thread issued a `cancel`, the cancelled flag was set, then another thread in `drain` would loop around, see the `cancelled` flag and clear the reference. Back in the cancelling thread, the `disposeInner` would only see `null` and do nothing.

Observable.switchMap did not have this mistake. Both received unit tests to verify the correct behavior.

2.x will be fixed in a separate PR.

Resolves #6914"David Karnokakarnokd02/27/20, 07:48:20 PM
6920.06921Observable.replay - a bug or a feature?"Version: 3.0.0

Hello! In the `ConnectableObservable` java docs this following is written:

> Disposing the connection will reset the {@code ConnectableFlowable} to its fresh state and there is no need to call {@code reset()} in this case.

So I think If I dispose the connection then I don't need to call `reset`, it should be in its initial state. However the following test fails. But if you uncomment the `reset()` call then it passes:

```kotlin
    @Test
    fun testReplay() {
        val subject = PublishSubject.create<Int>()
        val replay = subject.replay()

        var observer = replay.test() // subscribe
        val disposable = replay.connect() // connect
        subject.onNext(1)
        observer.dispose() // unsubscribe
        disposable.dispose() // disconnect
//        sharedStream.reset()

        observer = replay.test() // subscribe again
        replay.connect() // connect again
        subject.onNext(0)

        observer.assertValues(0) // Actual value is 1, but if reset was called then it will be 0
    }
```

Could you please clarify whether it is a bug or expected behaviour. Thanks!""At glance, looks like it is an oversight as `publish` works as documented. I'll have to check if there is another reason for it such as an (older) unit test expecting some behavior. =||= Thanks for the reporting. This is a bug in the `replay` operator as it was supposed to reset upon dispose, but the code was never enabled for it, nor was the behavior actually tested. Posted a fix in #6921  =||= @akarnokd Thanks for the fix! Are there any snapshots available with this fix? I see there were to releases of the 2.x version with bug fixes, but this fix was skipped for some reason. The latest version I could find is `3.0.0`. =||= #6929
https://github.com/ReactiveX/RxJava#snapshots =||= "3.x: Fix replay() not resetting when the connection is disposed"Disposing a `replay()`-based connectable should reset the operator to its fresh state. This was supposed to happen but the relevant code changes were not enabled. The PR fixes this for both `Flowable` and `Observable`-based implementations.

The `publish`-based connectables work as intended.

Fixes #6920"David Karnokakarnokd02/29/20, 01:02:29 PM
6883.069443.x: Marbles should have a proper background"The transparent ones look terrible with dark-themed IDEs or non-light background:

![image](https://user-images.githubusercontent.com/1269832/73169180-d69ffe80-40fb-11ea-9893-ba14ca1a2bee.png)

Only looks fine in Eclipse:

![image](https://user-images.githubusercontent.com/1269832/73169164-ce47c380-40fb-11ea-97f7-52157da366e4.png)

Write a program that goes through the images in `https://github.com/ReactiveX/RxJava.wiki.git` `images/rx-operators`, checks if the image has transparency, draw it onto a white background then save it as `originalName.v3.png` (because some of those are linked all around). Find the filename in the source code and replace them.""I'd like to do this if it's fine. =||= @tomislavhofman Sure! =||= While we're waiting for my internet to do the heavy lifting

Here are some fun facts:

- There were 749 images with transparent background ( which now have corresponding .v3.png with white background )

- RxJava project contains 45 .md files and 1855 .java files

- A total of 842 occurrences of transparent .pngs has been found across 18 files in total ( 5 located in /docs/ and 13 in /src/ )
    1. First place, Flowable.java and 373 changes
    2. Trailing second, Observable.java with 351 changes
    3. Third place has been taken by Single.java which was updated in 72 places.

Here's a very bare and unsorted log of changes made to RxJava source code https://pastebin.com/qMvUFc1n

- [x] Images with white background
- [x] Found and replaced in source code


On a side note, if my 2nd attempt to push the wiki changes onto my fork fails. Would you be okay with me uploading just the updated images somewhere and you can update the wiki yourself? It's a difference between 100ish MB and 1GB.
<img width=""688"" alt=""Screenshot 2020-04-02 at 11 32 53"" src=""https://user-images.githubusercontent.com/19726609/78233241-b9115b80-74d5-11ea-81c8-89a59320ae50.png""> 😶

If that doesn't work for you I'll just try again.

Once the wiki files are updated I'll submit the pull request for links updates. =||= You won't be able to push to the wiki or create a PR for the wiki part. Can you upload the files into this issue via attachment(s)? =||= Oh, and I thought I was being clever by researching and discovering how to make a PR to github wiki...

I'll attach the files below =||= Okay, I've uploaded all 749 images to a comment in this thread which I haven't posted yet...

How should I approach posting them, I'm a bit confused here, it is a lot of images.

**edit:** should I strip the image tag and post urls only? =||= No no. Zip about ~100 images~ at once and then attach each of them to a comment.

Edit, looks like the limit is 10 MB only. =||= How about you upload the code that does the image transformation? =||= ```Java
    private static void makeNonTransparentCopyOfImages(final List<File> files, final File outputFolder) {
        int index = 0;
        for (final File file : files) {
            if (!file.getName().contains("".png"")) {
                continue;
            }
            try {
                BufferedImage image = ImageIO.read(file);
                int width = image.getWidth();
                int height = image.getHeight();
                if (image.getColorModel().hasAlpha()) {
                    BufferedImage background = new BufferedImage(width, height, image.getType());
                    Graphics2D g2 = background.createGraphics();
                    g2.setColor(Color.WHITE);
                    g2.fillRect(0, 0, width, height);
                    BufferedImage combined = new BufferedImage(width, height, image.getType());
                    Graphics g = combined.getGraphics();
                    g.drawImage(background, 0, 0, null);
                    g.drawImage(image, 0, 0, null);
                    ImageIO.write(combined, ""PNG"", new File(outputFolder, file.getName().replace("".png"", "".v3.png"")));
                } else {
                    System.out.println(""Non transparent image: "" + index + "" - "" + file.getName());
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            index++;
        }
    }
``` =||= Created PR (#6944) which should be safe to merge once images have been uploaded. =||= "Update image urls to non-transparent version."Updated image urls to use non-transparent ones as per #6883

Resolves #6883"Tomislav Hofmantomislavhofman04/02/20, 12:19:57 PM
6945.06946Deadlock"RXJava 3.0.1.
I randomly got into a weird situation where my code entered a deadlock and I don't know why.
I simplified the code and got to the below part which will enter a deadlock and never return.
This seems like a bug, but maybe I'm missing something.
The code:
```java
Observable
    .range(1, 20)
    .flatMap(
            integer -> {
                if (integer % 5 != 0) {
                    return Observable
                            .just(integer);
                }

                return Observable
                        .just(-integer)
                        .observeOn(Schedulers.io());
            },
            false,
            1
    )
    .ignoreElements()
    .blockingAwait();
```"Thanks. It is a bug with the flatMap operator. Until the fix, you can workaround it by applying `hide()` to the plain `just`. =||= OK, that works, thanks. =||= 3.x: Fix Observable.flatMap with maxConcurrency hangs"Queued up scalar values were not counted as completed, thus the subsequent sources where not subscribed to to fill up the allowed concurrency level.

Fixes #6945"David Karnokakarnokd04/04/20, 09:29:23 AM
6954.069563.x: Exceptions will be swallowed when schedulers are involved"In general, exceptions should never be swallowed and should be handled somewhere, eg., catch clause or uncaught exception handlers of threads.

As to RxJava, exceptions are expected to be handled at:
- observer's onError(), or
- RxJava exception handler (RxJavaPlugins.onError()), or
- thread's uncaught exception handler (eg., exceptions thrown by Exceptions.throwIfFatal()), 

and not to be magically swallowed somewhere.

This is true in most situations, but is broken when schedulers are involved. That is, the following tests will fail:

**(Test 1) Exceptions from observables are swallowed:**

    @Test
    public void exceptionFromObservableShouldNotBeSwallowed() throws Exception {
        // Exceptions, fatal or not, should be handled by
        // #1 observer's onError(), or
        // #2 RxJava exception handler, or
        // #3 thread's uncaught exception handler,
        // and should not be swallowed.
        try {
            CountDownLatch latch = new CountDownLatch(1);

            // #3 thread's uncaught exception handler
            Scheduler computationScheduler = new ComputationScheduler(new ThreadFactory() {
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r);
                    t.setUncaughtExceptionHandler((thread, throwable) -> {
                        latch.countDown();
                    });
                    return t;
                }
            });

            // #2 RxJava exception handler
            RxJavaPlugins.setErrorHandler(h -> {
                latch.countDown();
            });

            // #1 observer's onError()
            Observable.create(s -> {

                s.onNext(1);

                if (true) {
                    throw new OutOfMemoryError();
                }

                s.onComplete();

            }).subscribeOn(computationScheduler)
            .subscribe(v -> {
            }, e -> {
                latch.countDown();
            });

            assertTrue(latch.await(2, TimeUnit.SECONDS));
        } finally {
            RxJavaPlugins.reset();
        }
    }

**(Test 2) Exceptions from observers are swallowed:**

    @Test
    public void exceptionFromObserverShouldNotBeSwallowed() throws Exception {
        // Exceptions, fatal or not, should be handled by
        // #1 observer's onError(), or
        // #2 RxJava exception handler, or
        // #3 thread's uncaught exception handler,
        // and should not be swallowed.
        try {
            CountDownLatch latch = new CountDownLatch(1);

            // #3 thread's uncaught exception handler
            Scheduler computationScheduler = new ComputationScheduler(new ThreadFactory() {
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r);
                    t.setUncaughtExceptionHandler((thread, throwable) -> {
                        latch.countDown();
                    });
                    return t;
                }
            });

            // #2 RxJava exception handler
            RxJavaPlugins.setErrorHandler(h -> {
                latch.countDown();
            });

            // #1 observer's onError()
            Flowable.interval(500, TimeUnit.MILLISECONDS, computationScheduler)
                    .subscribe(v -> {
                        throw new OutOfMemoryError();
                    }, e -> {
                        latch.countDown();
                    });

            assertTrue(latch.await(2, TimeUnit.SECONDS));
        } finally {
            RxJavaPlugins.reset();
        }
    }

Sometimes these broken cases matter in certain situation or on certain platform, eg.,
- As Test 1, when out-of-memory occurs before emitter.onComplete(), the application may block forever waiting for onComplete(), because no one in the whole application could possibly known about this exception.
- On Android, on which I code a lot, the exception handing contract implies that any runtime exception or error in any thread should throw to the uncaught exception handler, which will terminate the application. Almost all async tools, including the built in AsyncTask, conform to this contract. Setting an error handler that always throws runtime exceptions and errors via RxJavaPlugins.setErrorHandler() on Android almost makes it. But it doesn't work when schedulers are involved.

The cause is clear. Internal to Scheduler implementation, RxJava only uses Future of a task submitted to Executor as a cancel-handle and never check exceptions inside the Future while any exception thrown by the submitted task will go into the Future.

But the fix is not as easy, there is no chance to check the Future for exception since RxJava pushes task result instead of pulls it.

Pulling results is the design intent of Future. When we won't, I think we should customize the FutureTask which runs the task in Executor and provides the Future function to give us a chance to handle the result(including the exception).  

Actually, JDK has given us all we need to do this via ThreadPoolExecutor#newTaskFor, ScheduledThreadPoolExecutor#decorateTask, RunnableFuture, RunnableScheduledFuture, etc. And Android did something similar in its AsyncTask implementation.

I'll propose a PR that:
- Implements a CompleteScheduledExecutorService which is a ScheduledExecutorService that supports setting a complete handler that will receive the Future(and handle the task result) of the submitted task once it completes in the executing thread.
- Modifies executor based schedulers to use CompleteScheduledExecutorService and check the Future for exceptions(and route it to RxJavaPlugins.onError() or throw it using Exceptions.throwIfFatal()) of submitted tasks in their complete handlers.
- With test cases cover CompleteScheduledExecutorService related code and the above Test 1 & Test 2.


""Thanks for the report but there is no need for such complicated resolution. We only need to remove one `throwIfFatal` and add catch with `RxJavaPlugins.onError` call. See #6956. =||= > Thanks for the report but there is no need for such complicated resolution. We only need to remove one `throwIfFatal` and add catch with `RxJavaPlugins.onError` call. See #6956 

yeah, I considered that adding RxJavaPlugins.onError()s and removing throwIfFatal()s, but it makes https://github.com/ReactiveX/RxJava/issues/748 a problem again. It seems tricky to balance this issue and  #748. After all, if we passed StackOverflowError to RxJavaPlugins.onError(), RxJavaPlugins.onError() should throw it and it will be swallowed again.

I think customizing the future task will completely solve #748 and this issue. JDK supports that and at least as I know Android are using that approach. And I think it is not complex as the core code is only implementing the JDK's interface. It even simplifies the schedulers implementation, as I see ; ) =||= If you crash the `onError` handler, it will call the [uncaught exception handler](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/plugins/RxJavaPlugins.java#L378). =||= > If you crash the `onError` handler, it will call the [uncaught exception handler](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/plugins/RxJavaPlugins.java#L378).

as replied in #6956 : )
 =||= "3.x: Fix scheduled tasks' fatal exception behavior"Fatal exceptions may be lost with scheduled direct & scheduled periodic direct tasks because `FutureTask` simply treats them as exceptional outcomes. For regular tasks, [ScheduledRunnable](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/internal/schedulers/ScheduledRunnable.java#L67) already avoids rethrowing fatal errors as it would go nowhere.

This PR adds this behavior to the direct runnable tasks.

Resolves #6954"David Karnokakarnokd04/27/20, 06:46:52 AM
6947.069602.x: open for grabs: backport #6946Fix for the scalar-queue max-concurrency issue already fixed for 3.x in #6946.2.x: Fix Observable.flatMap with maxConcurrency hangs (#6947)"Just a backport to 2.x of the fix for the scalar-queue max-concurrency issue already fixed for 3.x in #6946

The code for the fix has been added and also the test for it.

In addition, as was also done for #6946, the corresponding test for `FlowableFlatMap` has been added.

Resolves #6947"Víctor Julián García Granadovjgarciag9604/15/20, 07:50:59 AM
6968.06969Request: allow to set `CLOCK_DRIFT_TOLERANCE_NANOS `in seconds/milliseconds"RxJava 2.2.18

https://github.com/ReactiveX/RxJava/blob/2cb20bd41efe70556ef7d346ee60f70e20548bae/src/main/java/io/reactivex/Scheduler.java#L97-L101

Would you please allow to set `CLOCK_DRIFT_TOLERANCE_NANOS` in seconds/milliseconds? 

I have a code which controls player position to play short pieces (few seconds) of media and pause them when the position is reached. Such as player may have various playback issues  (fast/slow playback, delay in initialization) i use `Flowable.interval`(50ms) to check its state/position periodically. However when system time synchronization occurs during playback flowable stops fire events until time become the same as it was before synchronization
Here how it looks in my log
```
14:21:43.273 z1 D PlaybackDurationControlCompletable.onTick: player position is unchanged, skipping check
14:21:37.727 z1 D some other event, time syncrhonization occurrs
// ... no onTick events for 6 seconds
14:21:43.372 z1 D PlaybackDurationControlCompletable: Initializing position 41769; elapsedTimerTime=5757 
```"This can be done for 3.x easily, but 2.x [no longer accepts changes like this](https://github.com/ReactiveX/RxJava#version-2x). =||= @akarnokd thank you very much, will migrate to RxJava3 =||= 3.x: Allow setting the drift tolerance timeunit via system property"Adds the new system property `rx3.scheduler.drift-tolerance-unit` to allow specifying a more fine-grained tolerance amount.

Resolves #6968"David Karnokakarnokd04/27/20, 08:46:41 AM
6974.069753.0.3 - Hangs when using combination of flatMap and publish"Hi.

After few days of desperate attempts to find the cause of my servers' spontaneous hangs, I managed to reproduce the issue, but still don't have a clear idea about the reason, but I think I have identified a possible direction.

All problems has started when I started using very promising operator groupBy with evicting map provider possibility:
```java
<K, V> Flowable<GroupedFlowable<K, V>> groupBy(@NonNull Function<? super T, ? extends K> keySelector,
            @NonNull Function<? super T, ? extends V> valueSelector,
            boolean delayError, int bufferSize,
            @NonNull Function<? super Consumer<Object>, ? extends Map<K, Object>> evictingMapFactory)
```

First I realised that it doesn't work well with Caffeine cache, as it performs evictions on a separate thread pool, and with async eviction notification groupBy goes crazy.

After moving to Guava things got better but only to some extent.

The tests I want to demonstrate I believe reproduce the issue I have. Definitely chain of operators is way more complicated in the production code, but here with certain variant of .publish() operator it's reproducible as well.

Basically, I'm not sure if there is issue in the groupBy(...evictingMapFactory) or in the publish(Function...), or in both.

Also tests are demonstrating that eviction policy doesn't work very well when crossing async boundaries downstream.

Please take a look at the attached file, it contains few simple tests, I kindly ask to check carefully all parameters, as it's important.

[FlowableOperators.java.zip](https://github.com/ReactiveX/RxJava/files/4604420/FlowableOperators.java.zip)""Hi and thanks for reporting this bug.

The problem is caused by the eviction double decrementing the group counter, once when the eviction completes the shared chain that cancels the group and once after the eviction.

I'll post a fix shortly. =||= Cool, looking forward for the fix! =||= /cc @davidmoten regarding the async eviction concerns. =||= Thanks for the prompt reply and the fix!
May I ask, when we can expect to have it to be released?
Maybe 3.0.4 soon? ;) =||= I suggest you verify it by testing with the current RxJava snapshot, just in case: https://github.com/ReactiveX/RxJava#snapshots =||= Sure, I will let you know about results. =||= Could you please comment on this?

```java
    public static void main(String[] args) {

        final int groups = 20;

        // Not completed (Timed out), buffer is too small
        int groupByBufferSize = groups * 2;
        int flatMapMaxConcurrency = 2 * groups;
        boolean notifyOnExplicitEviction = false;
        test2(groupByBufferSize, flatMapMaxConcurrency, groups, notifyOnExplicitEviction);

        // Success, buffer is large enough
        groupByBufferSize = groups * 30;
        flatMapMaxConcurrency = 2 * groups;
        test2(groupByBufferSize, flatMapMaxConcurrency, groups, notifyOnExplicitEviction);

        // Timeout... explicit eviction notification makes difference
        groupByBufferSize = groups * 30;
        flatMapMaxConcurrency = 2 * groups;
        notifyOnExplicitEviction = true;
        test2(groupByBufferSize, flatMapMaxConcurrency, groups, notifyOnExplicitEviction);

        // MissingBackpressureException, flatMap concurrency == groups count is not enough, must be at least 2x
        groupByBufferSize = groups * 20;
        flatMapMaxConcurrency = groups;
        notifyOnExplicitEviction = false;
        test2(groupByBufferSize, flatMapMaxConcurrency, groups, notifyOnExplicitEviction);
    }

    public static void test2(int groupByBufferSize, int flatMapMaxConcurrency, int groups,
                             boolean notifyOnExplicitEviction) {
        try {
            TestSubscriber<Integer> test = Flowable
                .range(1, 500_000)
                .map(i -> i % groups)
                .groupBy(i -> i, i -> i, false, groupByBufferSize,
                         // set cap too high
                         sizeCap(groups * 100, notifyOnExplicitEviction))
                .flatMap(gf -> gf
                             .take(10, TimeUnit.MILLISECONDS)
                    , flatMapMaxConcurrency)
                .test()
                .awaitDone(5, TimeUnit.SECONDS)
                .assertComplete();
            System.out.println(""Success"");
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

    public static <T> Function<Consumer<Object>, Map<T, Object>> sizeCap(int maxCapacity, boolean notifyOnExplicit) {
        return itemEvictConsumer ->
            CacheBuilder
                .newBuilder()
                .maximumSize(maxCapacity)
                .removalListener(n -> {
                    if (n.getCause() != RemovalCause.EXPLICIT || notifyOnExplicit) {
                        try {
                            itemEvictConsumer.accept(n.getValue());
                        } catch (Throwable throwable) {
                            throw new RuntimeException(throwable);
                        }
                    }
                })
                .<T, Object>build().asMap();
    }
``` =||= changing `.take(10, MILLISECONDS)` to `.take(10)` makes only 3d case failing with timeout =||= Is this with the snapshot? =||= yes, snapshot =||= `gf.observeOn(Schedulers.computation()).take(10)` produces yet another set of results. =||= I don't have the time today to look into these but we can perhaps narrow it down. Do the hangs happen without the eviction customization? =||= Behaviour is slightly different, but yes, on 3.0.3 also. =||= I don't know if this can be in help, but so far I got to the following:
synchronizing `GroupBySubscriber.onNext` with `State.cancel` fixes the issue.

```java

public synchronized void onNext(T t) {
////....

// ... State...

@Override
        public void cancel() {
            synchronized(parent) {
                if (cancelled.compareAndSet(false, true)) {
                    cancelParent();
                    drain();
                }
            }
        }
``` =||= Further fixes in #6979. =||= OK it seems to me I got the core of the issue. It lies in the `.drain()` method and the backpressure coordination with the upstream.
If group cancel happens concurrently with parent's onNext call, it's possible that group's onNext is called after cancel.
In this case, drain will return immediately as work-in-progress atomic guard is not updated when calling `checkTerminated`.
So that call is not accounted in the backpressure coordination inside `checkTerminated` and leads to a hang.
Easiest brute-force way to get rid of this problem is to change here return->break:
```java
if (checkTerminated(d, empty, a, delayError, e)) {
    return; // <- here should be `break`,
}
```

But I believe there should be more correct solution.

Also I think another valuable change would be to add verification that the group being removed in `.cancel(key)` is exactly the group that is calling this method, not blindly removing the key, as it theoretically may contain another group already, created after e.g. group abandonment or map eviction.
Schematically:
```java

        public void cancel(GroupedUnicast<K, V> group) {
            K key = group.getKey();
            Object mapKey = key != null ? key : NULL_KEY;
            if (groups.remove(mapKey, group)) {
                if (groupCount.decrementAndGet() == 0) {
                    upstream.cancel();
                }
            } else {
                System.out.println(""Group doesn't exist anymore"");
            }
        }

/// ... in State


        State(int bufferSize, GroupBySubscriber<?, K, T> parent, K key, boolean delayError, GroupedUnicast<K, T> group) {
            this.queue = new SpscLinkedArrayQueue<>(bufferSize);
            this.parent = parent;
            this.key = key;
            this.delayError = delayError;
            this.group = group;
        }


        void cancelParent() {
            if ((once.get() & ABANDONED) == 0) {
                parent.cancel(group);
            }
        }
 =||= And another thing which confuses me:

in drainNormal there is a call to q.poll() before a checkTerminated(), which removes element from the queue, and it's not being accounted in the coordination. =||= OK I see you already get your hands to the issue :)
I can see you have covered the problems,
and the only possible issue I still can see is the blind group key removal.
Correct me if I'm wrong:
if there is a race between evicting group from cache by the cache itself, calling parent's onNext and cancellation of the group,
it's possible that the cache removal will happen, then new group is created in onnext, and then cancellation happens and also removes the group from the cache, but there is already a new group, so it's an extra group removal. =||= > issue I still can see is the blind group key removal

Could be. A test case would be great for this.

> `groups.remove(mapKey, group)`

This could be a problem. The API uses `Map` and `remove(K, V)` was added to it in Java 8. I don't know how Android Desugar would handle it. Currently, all pre-Java 8 operators are still restricted to use Java 6 API just in case. Also [`ConcurrentMap.remove(K, V)`](https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/ConcurrentMap.html#remove(java.lang.Object,%20java.lang.Object)) does exist but would constitute as a public API change (and perhaps a limiting factor for existing usages). =||= Not sure how to write a test case for that... It shouldn't lead to a hang, just unnecessary group removal. =||= As you mentioned compatibility with Android and older Java runtimes, may I ask the question which is not related to the issue...
Is that compatibility restriction a reason for not using AtomicFieldUpdaters in the library in favour of pointer-chasing Atomics? =||= Reflective field access is broken on some Android phones.

Field updaters/varhandles are not always a clear win due to false sharing introduced by jam-packed state. You'd need to pad fields which increases the memory usage for all cases, not just the high-performance scenarios. Also on latest JDKs, there are signs that the previously widely employed class-hierarchy-based padding trick no longer works. =||= More than clear, thanks for the answer!
 =||= As for the Map's remove(Object,Object).
WDYT about checking if the map is instance of ConcurrentMap (I believe it will be like that in most of the cases, I can hardly imagine anyone would uses anything else), and if yes then using ConcurrentMap.remove(key, value), otherwise keep existing logic?
That check can be done during the construction, and for example keep 2 nullable references to maps, or wrap a non-ConcurrentMap's implementation with a proper delegating wrapper.
 =||= I have tried the code from your latest PR. And my pipeline still hangs on the graceful completion :(
So far don't have a simple test which is reproducing the problem, will let you know when I get something. Could be a problem is in another operator. (Though it works fine if I serialize calls to State.cancel and upstream onNext in groupby) =||= OK here is the case (just added `.observeOn` to grouped flowable):

```java

public static void test2(int groupByBufferSize, int flatMapMaxConcurrency, int groups,
                             boolean notifyOnExplicitEviction) {
        try {
            Flowable
                .range(1, 500_000)
                .map(i -> i % groups)
                .doOnCancel(() -> System.out.println(""Cancelling upstream""))
                .compose(s -> groupBy(s, i -> i, i -> i, groupByBufferSize, false,
                                      sizeCap(groups *2, notifyOnExplicitEviction)))
                .flatMap(gf -> gf
                             .observeOn(Schedulers.computation())
                             // .take(10)
                             .take(10, TimeUnit.MILLISECONDS)
                    , flatMapMaxConcurrency)
                .test()
                .awaitDone(5, TimeUnit.SECONDS)
                .assertComplete();
            System.out.println(""Success"");
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }
``` =||= If you put `hide()` before `observeOn`, does it work then? =||= > If you put hide() before observeOn, does it work then?

Apparently yes =||= I can see that partially my problems are caused by the .publish() operator (it uses FlowablePublishMulticast) which on complete calls .dispose() which in turn cancels upstream. I'm not sure I understand the reason of that canceling while this is a normal graceful shutdown. Could you please elaborate a little for a dummy like me why is it cancelling upstream on complete event? It messes with my resource cleanup logic (onTerminate is never called after that), and I'm not sure how to overrun it.

BTW here's the case where the new code fails even with `.hide()` in place:

```java

    public static void test2(int groupByBufferSize, int flatMapMaxConcurrency, int groups,
                             boolean notifyOnExplicitEviction) {
        try {
            Flowable
                .range(1, 500_000)
                .map(i -> i % groups)
                .doOnCancel(() -> System.out.println(""Cancelling upstream""))
                .compose(s -> groupBy(s, i -> i, i -> i, groupByBufferSize, false,
                                      sizeAndTtlCapGuava(groups * 2, Duration.ofMillis(10), notifyOnExplicitEviction)))
                .flatMap(gf -> gf
                             .hide()
                             .publish(shared -> shared)
                    , flatMapMaxConcurrency)
                .test()
                .awaitDone(5, TimeUnit.SECONDS)
                .assertComplete();
            System.out.println(""Success"");
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

    public static <T> Function<Consumer<Object>, ConcurrentMap<T, Object>> sizeAndTtlCapGuava(int maxCapacity,
                                                                                              Duration ttl,
                                                                                              boolean notifyOnExplicit) {
        return itemEvictConsumer ->
            CacheBuilder
                .newBuilder()
                .maximumSize(maxCapacity)
                .expireAfterWrite(ttl)
                .removalListener(n -> {
                    if (n.getCause() != com.google.common.cache.RemovalCause.EXPLICIT || notifyOnExplicit) {
                        try {
                            itemEvictConsumer.accept(n.getValue());
                        } catch (Throwable throwable) {
                            throw new RuntimeException(throwable);
                        }
                    }
                })
                .<T, Object>build().asMap();
    }

``` =||= > why is it cancelling upstream on complete event

With `publish(Function)`, the inner flow may be independent of the upstream so when the inner terminates, the upstream should be stopped. I suppose when there is a causal chain from an upstream completion to a downstream completion, this cancellation could be suppressed.

I'll look into the new cases tomorrow. =||= Adding .observeOn leads to MissingbackpressureException:

```java

    public static void main(String[] args) {
        final int groups = 20;

        // MissingBackpressureException
        int groupByBufferSize = 2;
        int flatMapMaxConcurrency = 2 * groups;
        boolean notifyOnExplicitEviction = false;
        test2(groupByBufferSize, flatMapMaxConcurrency, groups, notifyOnExplicitEviction);

        groupByBufferSize = groups * 30;
        flatMapMaxConcurrency = 2 * groups;
        test2(groupByBufferSize, flatMapMaxConcurrency, groups, notifyOnExplicitEviction);
    }

    public static void test2(int groupByBufferSize, int flatMapMaxConcurrency, int groups,
                             boolean notifyOnExplicitEviction) {
        try {
            Flowable
                .range(1, 500_000)
                .map(i -> i % groups)
                .compose(s -> groupBy(s, i -> i, i -> i, groupByBufferSize, false,
                                      sizeAndTtlCapGuava(groups, Duration.ofMillis(10), notifyOnExplicitEviction)))
                .flatMap(gf -> FlowableOperators.publish(gf.hide()
                                                           .observeOn(Schedulers.computation())
                    , shared -> shared)
                    , flatMapMaxConcurrency)
                .test()
                .awaitDone(5, TimeUnit.SECONDS)
                .assertComplete();
            System.out.println(""Success"");
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }
``` =||= Continuing about problem with the latest test above.
What I realised today is that when a group completes (e.g. because of external eviction from the Map), it pushes down onComplete event, and in case there is observeOn operator downstream, or any other reason which causes onComplete to be scheduled on another thread, the consequence is that expected group request from flatMap (or another operator consuming groups) happens with a delay, which leads to ""group abandonment"". It's not really about subscribing to a new group only, as stated in the documentation, but requesting more when another one completes.

Simple reproduction:

```java
Flowable
  .range(1, 500_000)
  .map(i -> i % 20)
  .groupBy(i->i) // no any group eviction
  .flatMap(gf -> gf.hide()
                                 .take(10)
                                 .observeOn(Schedulers.computation())
                    ,1000)
  .test()
  .awaitDone(5, TimeUnit.SECONDS)
  .assertComplete();
```

Concurrency in flatMap of 1000 is not enough =||= And when group is cancelled e.g. by take() operator, and it's done asynchronously, this is again is not accounted into the pair ""requested-emitted"" and leads to group abandonment.
I believe number of completed/cancelled groups should be accounted in the abandonment error generation. =||= Are you sure you get group abandonment instead of MissingBackpressureException? Abandonment happens only when there is no synchronous subscription happening but there were requests for new groups.

Also if you delay the completion within flatMap, there is no way for the operator to request more until there are concurrency slots freeing up. =||= Maybe I’m calling it wrong... It’s naturally being delayed: you evict group
from the map, immediately schedule group eviction task which will in turn
call onComplete. But that will happen eventually, along with following
request from flatMap.
But in that turn of onNext a new group is already trying to be emitted
which is causing error as requests didn’t catch up with emits. =||= Basically - isn’t it a violation of the protocol? we shouldn’t emit anything
unless requested. I think such eviction should be coordinated with the
emission? Conceptually we have just completed previous group ( in Guava
evictions happen exactly when you call get/put) we are allowed to emit new
group, but only after it completes and flatMap requests more. So maybe it
should queue up such emissions until next request from downstream? =||= I've experimented with the new cases and here is the rundown:

- `gf.publish(shared->shared)` does not hang for me.
- `gf.observeOn().take()` hangs but `gf.hide().observeOn().take()` passes.

The latter could lead down the rabbit hole so I'll merge #6979 to have a clean baseline for further actions. Let's continue the discussion in #6982.
 =||= "3.x: Fix Flowable.groupBy eviction logic double decrement and hang"When a group is evicted, the group is synchronously `onComplete`d during an `onNext`. If a cancellation happened during this time (for example, when a `publish` cancels its upstream because its output completes), the cancellation would unconditionally decrement the group counter even though the `groups` map had no longer the group (because it was evicted before). Then once the eviction logic finishes, it decremented the group counter again, leading to invalid internal state and hangs.

The fix is to only decrement if there was a group actually removed from the map.

Fixes #6974"David Karnokakarnokd05/10/20, 08:52:29 AM
6982.06988Flowable.groupBy hangs with group consumed via observeOn and take(timed)"Continuing evaluating the problems from #6974

The following test hangs after a while:

```java
    @Test
    public void issue6974Part2Case1ObserveOnNoCap() {
        final int groups = 20;
        int flatMapMaxConcurrency = 1_000_000;

        Flowable
        .range(1, 500_000)
        .map(i -> i % groups)
        .doOnRequest(v -> {
            System.out.println(""Source: "" + v);
        })
        .groupBy(i -> i)
        .flatMap(gf -> gf
                     .observeOn(Schedulers.computation())
                     .take(10, TimeUnit.MILLISECONDS)
            , flatMapMaxConcurrency)
        .test()
        .awaitDone(5, TimeUnit.SECONDS)
        .assertNoErrors()
        .assertComplete();
    }
```

Adding `hide` makes it pass which indicates the fusion between the group and `observeOn` seems to stop requesting more items.""Thoughs on the cause so far:

### Unconditional group removal

The unconditional group removal in `cancel(K key)` could be a contributing factor; debug indicated 0 groups during the hang.

### Rejected execution

`take` makes `observeOn` dispose its worker so items are stuck in the (fused) queue not being cleaned.

Currently, there is no good way to detect such rejection through the `Scheduler.Worker` API as rejected schedules return `EmptyDisposable.INSTANCE` and `TrampolineScheduler` also returns it as a default indicator. This would require API changes and the introduction of a dedicated and public rejected-disposable. 

Second, `observeOn` has to be updated to detect rejection and perform the cleanup on the fused queue.

Third, the cancellation can come after the schedule but before the drain execution, thus the drain is never executed and the operator is stuck in wip > 0 state.

### Difference with hide()

With `hide()`, the group manages the items and can request more upon cancellation, hence there should be no hanging. =||= My observations with the latest version:

1) when evicting groups from the map externally (ttl, size, etc) without async boundary downstream, hangs sometimes on the very last item, not every time.

Test case:

```java
Flowable
  .range(1, 500_000)
  .map(i -> i % 20)
  .groupBy(i -> i, i -> i, false, groupByBufferSize,
                         sizeAndTtlCapGuava(1000, Duration.ofMillis(10), false))
  .flatMap(gf -> gf, groups)
  .test()
  .awaitDone(5, TimeUnit.SECONDS)
  .assertComplete();
```

2) when cancelling groups e.g. by take() operator.

Here we have both issue with hangs and abandonment.

Please try

```java
Flowable
  .range(1, 500_000)
  .map(i -> i % 20)
  .groupBy(i->i) // no any group eviction
  .flatMap(gf -> gf.take(10)
                                 .observeOn(Schedulers.computation())
                    ,groups)
  .test()
  .awaitDone(5, TimeUnit.SECONDS)
  .assertComplete();
```
 =||= 3) same as 1) but with delayed oncomplete : in this case delayed oncomplete->request leads to MBE

```java
Flowable
                .range(1, 500_000)
                .map(i -> i % groups)
                .groupBy(i -> i, i -> i, false, groupByBufferSize,
                         sizeAndTtlCapGuava(1000, Duration.ofMillis(10), false))
                .flatMap(gf -> gf
                             .observeOn(Schedulers.computation())
                    , groups)
                .test()
                .awaitDone(5, TimeUnit.SECONDS)
                .assertComplete();
``` =||= We can't do anything about the MBEs, it is inherent when running with limited concurrency because a request from one group can lead to a new group creation for which if there is no request on the main output, there is no way to store it in a bounded manner.

The objective here is to not let the chain hang but have it complete or fail with MBE depending on the situation. =||= This lack of coordination between group eviction/consequent flatMap's request greatly limits use cases of the operator :(
Maybe there could be considered some change in it's design so it can become possible?
E.g. queue up emissions of new groups, caused specifically by eviction (it's relatively easy to detect) until there is a request from downstream?
Or do emissions on the request, not during onNext? =||= The question is that there is a time gap between completion of a group and consequent request, while if it was synchronously, there wouldn't be an issue with MBE.
Issue looks exactly the same as documented requirement of a mandatory synchronous subscription to a group right after emitted. =||= OK Here is another thought .... Which will demonstrate that Hang issues are related to MBEs.

In the request method there is only an increment of the atomic counter.
I can't find any signs of informing upstream about the request.
The only place where request upstream happens, is during synchronous subscription - flatMap immediately prefetches upstream.
That request is a basis for all upcoming groupBy operator work.
And if there is a delay between an emission of a group and replenishing request from the downstream, there is a high possibility of a hang / MBE because noone is coordinating emissions with requests, and also noone is informing upstream about a request from downstream - if emission downstream requests do not  catch up with the emissions.

Makes sense? =||= Please note I'm talking about requests from the flatMap, not from the consumers of the groups! =||= Hi. Really don't want to bother you, but could you please let us know, what are the plans regarding groupBy operator? =||= Latest snapshot still hangs for me with these tests:
First one hangs in around 50% of runs always exactly at the last item, second hangs always.

```java
import com.google.common.cache.CacheBuilder;
import io.reactivex.rxjava3.core.Flowable;
import io.reactivex.rxjava3.functions.Consumer;
import io.reactivex.rxjava3.functions.Function;
import io.reactivex.rxjava3.schedulers.Schedulers;

import java.time.Duration;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

public class Test {
    public static <T> Function<Consumer<Object>, ConcurrentMap<T, Object>> ttlCapGuava(Duration ttl) {
        return itemEvictConsumer -> CacheBuilder
                                        .newBuilder()
                                        .expireAfterWrite(ttl)
                                        .removalListener(n -> {
                                            if (n.getCause() != com.google.common.cache.RemovalCause.EXPLICIT) {
                                                try {
                                                    itemEvictConsumer.accept(n.getValue());
                                                } catch (Throwable throwable) {
                                                    throw new RuntimeException(throwable);
                                                }
                                            }
                                        }).<T, Object>build().asMap();
    }

    public static void main(String[] args) {
        final int groups = 20;

        int groupByBufferSize = 2;
        int flatMapMaxConcurrency = 200 * groups;
        // ~50% of executions - Not completed (latch = 1, values = 500000, errors = 0, completions = 0, timeout!,
        // disposed!)
        test(groupByBufferSize, flatMapMaxConcurrency, groups);

        groupByBufferSize = groups * 30;
        flatMapMaxConcurrency = groups * 500;
        // Always : Not completed (latch = 1, values = 14100, errors = 0, completions = 0, timeout!, disposed!)
        test(groupByBufferSize, flatMapMaxConcurrency, groups);
    }

    public static void test(int groupByBufferSize, int flatMapMaxConcurrency, int groups) {
        try {
            Flowable
                .range(1, 500_000)
                .map(i -> i % groups)
                .groupBy(i -> i, i -> i, false, groupByBufferSize, ttlCapGuava(Duration.ofMillis(10)))
                .flatMap(gf -> gf.observeOn(Schedulers.computation()), flatMapMaxConcurrency)
                .test()
                .awaitDone(5, TimeUnit.SECONDS)
                .assertComplete();
            System.out.println(""Success"");
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }
}

``` =||= I'll be looking into them (and a few additional cases I was thinking about the past days) tomorrow. =||= Thanks!!! =||= "3.x: Fix Flowable.groupBy eviction-completion-replenishment problems"This PR fixes the two cases from https://github.com/ReactiveX/RxJava/issues/6982#issuecomment-630290658

### Case 1: completions missed

When the upstream completed and some groups were waiting in the eviction queue, the eviction queue was cleared without completing those groups. Since they were no longer in the main map, those groups never completed and downstream operators relying on all groups completing (i.e., flatMap) would never complete.

The fix is to call `completeEvictions` upon upstream termination.

### Case 2: no replenisment on evicted groups

When an eviction happens, the groups get completed. However, unlike with the non-evicting case, a group completion no longer implies the upstream has completed. Consequently, the evicted groups emitted their items but never issued a replenishment for them, hanging the still-alive main operator.

The fix is to replenish emitted (and polled) counts whenever the group detects a completion. (Errors still imply the main operator has terminated so no need to replenish then.) 

Resolves #6982"David Karnokakarnokd05/20/20, 07:34:07 PM
6987.069963.x: Suppress undeliverables in some tests"Some tests trigger a lot of undeliverable exceptions flooding the console output. Example:

```
at io.reactivex.rxjava3.internal.subscribers.FutureSubscriberTest
    .onErrorCancelRace(FutureSubscriberTest.java:178)

at io.reactivex.rxjava3.internal.operators.observable.ObservableWindowWithObservableTest
    .disposeMainBoundaryErrorRace(ObservableWindowWithObservableTest.java:590)
```

These are generally irrelevant from those particular tests and should be safely ignored. The difficulty is, locating these tests if the console doesn't retain too many lines.

To resolve the issue, perhaps the easiest way is to write a `TestHelper.withUndeliverableSuppressed(Action)` method and keep wrapping the problematic test bodies."Suppress UndeliverableException handling in tests (#6987)"I used a JUnit TestRule to suppress handling of UndeliverableException for test methods annotated with @SuppressUndeliverable. This approach is coarser than the suggested approach (it suppresses the handling of all UndeliverableExceptions for the entire annotated test method).
I thought this approach was clean but I can switch to the suggested approach if preferred.

I added @SuppressUndeliverable to most tests that were logging UndeliverableExceptions with the test method in the stack trace. This may be more suppression than was required so just let me know.

Fixes #6987 "akluball05/24/20, 07:37:32 AM
7005.070063.x: NoAnonymousInnerClassesTest fails"When attempting to build the project locally via `./gradlew build`, all of the tests pass except for the `NoAnonymousInnerClassesTest`:
```
io.reactivex.rxjava3.validators.NoAnonymousInnerClassesTest > verify FAILED
    java.lang.AssertionError: Anonymous inner classes found:
    test.io.reactivex.rxjava3.testsupport.SuppressUndeliverableRule$1.class
        at io.reactivex.rxjava3.validators.NoAnonymousInnerClassesTest.verify(NoAnonymousInnerClassesTest.java:125)
```

For context, here are some more details about what I'm running on my machine:
```
$ java --version
openjdk 11.0.2 2019-01-15
OpenJDK Runtime Environment 18.9 (build 11.0.2+9)
OpenJDK 64-Bit Server VM 18.9 (build 11.0.2+9, mixed mode)
$ gradle --version
------------------------------------------------------------
Gradle 6.5
------------------------------------------------------------

Build time:   2020-06-02 20:46:21 UTC
Revision:     a27f41e4ae5e8a41ab9b19f8dd6d86d7b384dad4

Kotlin:       1.3.72
Groovy:       2.5.11
Ant:          Apache Ant(TM) version 1.10.7 compiled on September 1 2019
JVM:          13.0.2 (Oracle Corporation 13.0.2+8)
OS:           Mac OS X 10.15.5 x86_64
```""Apparently the verifier doesn't like the SuppressUndeliverableRule's inner class: https://github.com/ReactiveX/RxJava/blob/3.x/src/test/java/io/reactivex/rxjava3/testsupport/SuppressUndeliverableRule.java#L36

Could you turn that `new Statement` into a named inner class and see if it builds for you (it builds on CI so you are in a good position to verify a fix)? =||= Sure, happy to. I'll fork and open up a new PR @akarnokd  =||= @akarnokd, I just opened a pull request: https://github.com/ReactiveX/RxJava/pull/7006 =||= "Updating SuppressUndeliverableRule to have a named inner class instead of an anonymous inner class"Based on the discussion in https://github.com/ReactiveX/RxJava/issues/7005

Resolves #7005"Abhisheksh-abhi06/08/20, 08:21:23 AM
7001.070283.x: Flaky GroupBy test"https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2668

```
io.reactivex.rxjava3.internal.operators.flowable.FlowableGroupByTest > issue6974Part2Case1NoEvict FAILED
    java.lang.AssertionError: Error(s) present: [io.reactivex.rxjava3.exceptions.CompositeException: 1 exceptions occurred. ] (latch = 0, values = 15551, errors = 1, completions = 0)
        at io.reactivex.rxjava3.observers.BaseTestConsumer.fail(BaseTestConsumer.java:125)
        at io.reactivex.rxjava3.observers.BaseTestConsumer.assertNoErrors(BaseTestConsumer.java:212)
        at io.reactivex.rxjava3.internal.operators.flowable.FlowableGroupByTest.issue6974RunPart2NoEvict(FlowableGroupByTest.java:2681)
        at io.reactivex.rxjava3.internal.operators.flowable.FlowableGroupByTest.issue6974Part2Case1NoEvict(FlowableGroupByTest.java:2693)
        Caused by:
        io.reactivex.rxjava3.exceptions.CompositeException: 1 exceptions occurred. 
            Caused by:
            io.reactivex.rxjava3.exceptions.MissingBackpressureException: Unable to emit a new group (#71) due to lack of requests. Please make sure the downstream can always accept a new group as well as each group is consumed in order for the whole operator to be able to proceed.
```

Error is an allowed outcome here.""I would like to pick up this issue if no one is working on it yet. =||= I would like to pick up this issue, @ddunig2  are you still working on it? =||= I had not realized I got the okay to work on this. @tmankita give me three days to work on it then it's all yours. =||= @akarnokd that test seems to be passing on my local machine, I'm not sure what the issue is. =||= It can probabilistically result in a `MissingBackpressureException`, which is an allowed outcome, but the test expects no errors: https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2681

Effectively, the only thing needed is a different assert such as in this test: https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2730 =||= @akarnokd Okay, I got it. Would simply removing the assertNoErrors be valid? I would have to change the TestSubsriber to TestSubscriberEx to include the assertTerminate() and in this case, would we still need assertComplete()? =||= "3.x: Allow MBE in FlowableGroupByTest.issue6974RunPart2NoEvict"Issue #7001
https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2668-L2669

The above test can probabilistically throw an exception, thus:

https://github.com/ReactiveX/RxJava/blob/98acac218cdb04d279b5ac49bb1afc65bc6ec4fe/src/test/java/io/reactivex/rxjava3/internal/operators/flowable/FlowableGroupByTest.java#L2681

The above assertion would be invalid. I have removed the invalid assertion.

Fixes #7001"Lugduni Desrosiersddunig207/13/20, 06:30:46 PM
7032.070333.x Consider making .collect contravariant on T"Hi,

Currently, `collect` in Flowable, Observable accepts a `Collector<T, A, R> collector`. If that were to be `Collector<? super T, A, R> collector`, less casting would be needed in some instances. For example, when using `java.util.stream.Collectors.joining()`:

```java
Observable
        .just(""foo"", ""bar"", ""baz"")
        .cast(CharSequence.class)
        .collect(joining("", ""));
```

The `.cast(CharSequence.class)` would then no longer be needed.

Should also be binary compatible?"Probably won't break anything. PR welcome. =||= {Flowable,Observable}.collect(Collector) contravariant on TAdded `? super` twice. Would resolve #7032.Jakob van Kruijssencardamon07/28/20, 11:05:02 AM
7039.07040FlowableFilter potentially corrupts the source after observeOn"I've tried version 3.0.2 and 3.0.4 and both versions have this issue.

So here's the code that's causing the issue:

```java
	private Publisher<ShortCode> findAll() {
		// Yes, this is not just for this code example. I'm actually using Flowable.empty().
		return Flowable.<Boolean>empty()
				.observeOn(Schedulers.io())
				.filter(_b -> {
					System.out.println(""111111111111111111111111111 "" + (_b == null));
					return _b;
				})
				.map(_b -> {
					System.out.println(""2222222222222222222222222222 "" + (_b == null));
					return _b;
				})
				// The Flowable is always empty, so casting to anything is safe
				.map(ShortCode.class::cast);
	}
```

The code causes the following NPE:

```
java.lang.NullPointerException: The mapper function returned a null value.
        at java.util.Objects.requireNonNull(Objects.java:228)
        at io.reactivex.rxjava3.internal.operators.flowable.FlowableMap$MapConditionalSubscriber.tryOnNext(FlowableMap.java:124)
```

The console output is:

```
2222222222222222222222222222 true
```

So the function inside `filter` never gets called, which is expected, but then the function inside `map` gets called with a `null` element, which is not expected. It seems like the `filter` has corrupted the source and has made it emit a `null` element.

And the weird thing is that, if you run that piece of code in a standalone main method, it will NOT cause the NPE.

Also, doing any of the following will stop the NPE from happening:

* Remove the `observeOn`.
* Move the `observeOn` after the `filter`.
* Add `.to(Flux::from)` after the `observeOn`.
* Replace `Flowable.<Boolean>empty().observeOn(Schedulers.io())` with `Flux.<Boolean>empty().publishOn(reactor.core.scheduler.Schedulers.elastic())`.

The examples involving `Flux` are simply to demonstrate that it is not an issue with Reactor Core.

I know that not being able to reproduce the NPE with just that code sample is not terribly helpful, but are there any circumstances where doing an `observeOn` followed by a `filter` can corrupt the source?

Thanks!""How are you consuming the problematic flow?

Could you place an Object.requireNonNull inside the map to see what is the code path that triggers the NPE? =||= Found the issue and posted a fix in #7040  =||= Thanks a lot!!! 🎉 =||= "3.x: Fix map() conditional chain causing NPE"Fix the case when an (async) fused `filter`-`map`-`filter` chain does not handle the null indicator in its conditional path inside `map`.

Fixes #7039 "David Karnokakarnokd07/25/20, 10:21:27 AM
7048.070493.x: Observable.window() operators do not dispose upstream while there is an active window"RxJava version: 3.0.5
OS: Android

Hello. Today I discovered an odd behaviour of some of the `Observable.window(...)` operators. Here are some samples:

**Sample 1**
```kotlin
        val disposable = Observable
            .create<Int> { emitter ->
                Log.v(""MyTest"", ""Upstream subscribed"")
                emitter.setCancellable { Log.v(""MyTest"", ""Upstream disposed"") }
                repeat(100) {
                    emitter.onNext(it)
                    Thread.sleep(100L)
                }
            }
            .subscribeOn(Schedulers.io())
            .window(50)
            .subscribe {
                it.subscribe({}, {}, { Log.v(""MyTest"", ""Window completed"") })
            }

        Handler().postDelayed(disposable::dispose, 1000L)
```

The output of the code is:
```
2020-08-03 17:34:45.193 11575-11614/com.badoo.reaktive.sample.android V/MyTest: Upstream subscribed
2020-08-03 17:34:50.158 11575-11614/com.badoo.reaktive.sample.android V/MyTest: Upstream disposed
2020-08-03 17:34:50.158 11575-11614/com.badoo.reaktive.sample.android V/MyTest: Window completed
```

If you comment the line `it.subscribe({}, {}, { Log.v(""MyTest"", ""Window completed"") })` then the output is:
```
2020-08-03 17:35:38.969 11704-11745/com.badoo.reaktive.sample.android V/MyTest: Upstream subscribed
```

Concerns: 
1. In the first case the upstream is disposed after 5 seconds, not after 1 second
2. In the second case the upstream is never disposed at all

**Sample 2**
The `window(timeSpan, TimeUnit)` operator behaves differently.

```kotlin
        val disposable = Observable
            .create<Int> { emitter ->
                Log.v(""MyTest"", ""Upstream subscribed"")
                emitter.setCancellable { Log.v(""MyTest"", ""Upstream disposed"") }
                repeat(100) {
                    emitter.onNext(it)
                    Thread.sleep(100L)
                }
            }
            .subscribeOn(Schedulers.io())
            .window(5000L, TimeUnit.MILLISECONDS)
            .subscribe {
                it.subscribe({}, {}, { Log.v(""MyTest"", ""Window completed"") })
            }

        Handler().postDelayed(disposable::dispose, 1000L)
```

So the output is: 
```
2020-08-03 17:32:04.738 11310-11361/com.badoo.reaktive.sample.android V/MyTest: Upstream subscribed
2020-08-03 17:32:09.736 11310-11360/com.badoo.reaktive.sample.android V/MyTest: Upstream disposed
2020-08-03 17:32:09.736 11310-11360/com.badoo.reaktive.sample.android V/MyTest: Window completed
```

If you comment the line `it.subscribe({}, {}, { Log.v(""MyTest"", ""Window completed"") })` ten the output is:
```
2020-08-03 17:33:23.535 11427-11480/com.badoo.reaktive.sample.android V/MyTest: Upstream subscribed
2020-08-03 17:33:24.536 11427-11427/com.badoo.reaktive.sample.android V/MyTest: Upstream disposed
```

Concerns:
1. In the first case the upstream is disposed after 5 seconds, not after 1 second (same as `window(count)`)
2. In the second case the upstream is disposed after 1 second (different from `window(count)`)

**Questions**
Is it by design or a bug? I would expect the upstream to be disposed and all active windows completed once the downstream is disposed. Or at least behaviour to be consistent across all `window(...)` operators.""Dispose after 5 seconds is expected, because you indicate no more windows should be created but you still have an active window consuming items that will run to its completion, then detect there no further windows can be created and thus the upstream should be cancelled.

I have to investigate Sample 1 Case 2 (sized window without subscribing to the windows themselves).
  =||= Thanks for the feedback. Sample 1 Case 2 is indeed a bug, namely the lack of proper cancellation accounting in `window()`. I'll post a fix tomorrow. =||= "3.x: Fix Observable.window (size, skip, overlap) dispose behavior"Disposing the main output of the `Observable.window` operator did not properly propagate the dispose call under certain circumstances, such as no current active window or the window(s) were abandoned immediately.

Fixes #7048"David Karnokakarnokd08/06/20, 06:09:48 AM
7050.07051onErrorResumeWith() javadoc has onErrorResumeNext() marble diagramdocumentation bug"Where exactly? There are hundreds of diagrams waiting to be redrawn... =||= Here: http://reactivex.io/RxJava/3.x/javadoc/ 
In the entry for `Observable<T>`, scroll down to `onErrorResumeWith()`. The marble diagram shows `onErrorResumeNext()`  =||= "3.x: Update marbles of onErrorResume(Next|With) + cleanup"- `onErrorResumeNext` marble now indicates the error and function-callback nature:

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeNext.v3.png)

- `onErrorResumeWith` marble now has the correct name (and retains the original onErrorResumeNext style):

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/onErrorResumeWith.v3.png)

- Address now deprecated API usage of Mockito.
- Few other style corrections.

Fixes #7050"David Karnokakarnokd08/06/20, 07:25:56 AM
7081.070832.x - Observable.toFlowable(ERROR) not releasing upstream on MissingBackPressure"Hi

Code sample :
```
Observable.interval(1, TimeUnit.MILLISECONDS)
				.doFinally(() -> System.err.println(""finally obs""))
				.toFlowable(BackpressureStrategy.ERROR)
				.doFinally(() -> System.err.println(""finally flow""))
				.observeOn(Schedulers.computation())
				.map(any -> {
					System.out.println(""any = "" + any);
					Thread.sleep(1000);
					return any;
				})
				.subscribe(any -> {
				}, err -> {
					System.err.println(err.getMessage());
				});
```
With this code, a MissingBackPressureException is quickly generated and propagated through the downstream of `.toFlowable(BackpressureStrategy.ERROR)`, but it looks like the upstream is never disposed. Am I missing something ?

Tested with rxjava 2.2.19"Thanks for reporting. This is a bug with the operator in both 2.x and 3.x. I'll post fixes shortly. =||= The fix works for me. Thanks for the quick answer and correction ! =||= 3.x: Fix toFlowable(ERROR) not cancelling on MBE"There was a missing `upstream.cancel()` for when the overflow happens.

Fixes #7081"David Karnokakarnokd09/23/20, 08:47:30 AM
7109.07110Flowable scan operators backpressure inconsistency"Hello,

Flowable operator scan (without initial value) pulls values according to downstream requests, but other scan variations will pull in buffersize() chunks.


RxJava version: 3.0.7

Code (if kotlin is not acceptable, let me know and I will amend to a Java version):

```
class ScanTest {
	@Test
	fun `scan with initial`() {
		var requested = 0L
		Flowable.never<Int>()
			.doOnRequest { requested += it }
			.scan(0, Int::plus)
			.test(2)

		assert(requested == 1L) { ""Requested was $requested and not 1"" }
	}

	@Test
	fun `scan without initial`() {
		var requested = 0L
		Flowable.never<Int>()
			.doOnRequest { requested += it }
			.scan(Int::plus)
			.test(1)

		assert(requested == 1L) { ""Requested was $requested and not 1"" }
	}

	@Test
	fun `scanWith`() {
		var requested = 0L
		Flowable.never<Int>()
			.doOnRequest { requested += it }
			.scanWith({ 0 }, Int::plus)
			.test(2)

		assert(requested == 1L) { ""Requested was $requested and not 1"" }
	}
}
```

only the second test passes.

Trace:

```
java.lang.AssertionError: Requested was 127 and not 1

	at ScanTest.scanWith(ScanTest.kt:35)


java.lang.AssertionError: Requested was 127 and not 1

	at ScanTest.scan with initial(ScanTest.kt:13)
```


My expectation would be that after supplying the initial value, the remaining values would be requested up as the downstream requires (akin to the no initial value scan).""> My expectation would be that after supplying the initial value, the remaining values would be requested up as the downstream requires

It is by design due to how asynchronous requesting can interact with that very first value emission vs the upstream. 

For example, the upstream may be completing asynchronously without any value exactly the time when the downstream requests 1 item (the initial value) thus there is a race and need for serialization. The straightforward solution is to use prefetching + queue just like many other operators, consequently, the downstream request pattern is lost in the process.

The prefetch amount is currently not exposed on the `scan` operator so in case you find the default too high, you can use [rebatchRequests](http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Flowable.html#rebatchRequests-int-) to lower the amount. =||= Many thanks for clarifying that.

Is it worth documenting the behavioural difference in the operator javadoc?

Edit: or perhaps provide a new BackpressureSupport value (like BUFFERED_IN) =||= Their documentation could include an expanded `Backpressure:` section:

```diff
     * <dl>
     *  <dt><b>Backpressure:</b></dt>
     *  <dd>
+    * The downstream request pattern is not preserved across this operator. 
+    * The upstream is requested {@link #bufferSize()} - 1 upfront and 75% of {@link #bufferSize()} thereafter.
     *  </dd>
```

Would you like to create a PR for such documentation change?

> Edit: or perhaps provide a new BackpressureSupport value (like BUFFERED_IN)

Not likely. =||= No problem. Will do =||= "3.x: Flowable scan/scanWith backpressure documentation update"Documented Flowable initial value scan variants upstream consumption pattern as it is different from the variant with no initial value.


Resolves #7109"Fabio Baratafsbarata11/12/20, 10:13:14 AM
7125.07126TestObserver error messages should include more information about values where possible"This applies to both 2.x and 3.x, and while I'd like this to be fixed in 2.x, it's more of a frustration than a bug.

Suppose I'm trying to assert that a value from a `TestObserver` is equal to a particular value. I write this test:
```kotlin
Single.just(""foo"").test().assertValue(""bar"")
```
and get this helpful error message:
```
java.lang.AssertionError: expected: bar (class: String) but was: foo (class: String) (latch = 0, values = 1, errors = 0, completions = 1)
Expected :bar (class: String) 
Actual   :foo (class: String) (latch = 0, values = 1, errors = 0, completions = 1)
```
(Never mind that the ""Actual"" in this case includes extra information, it conveys what it needs to.)

Suppose that I instead use a predicate:
```kotlin
Single.just(""foo"").test().assertValue { it.equals(""goodbye"", ignoreCase = true) }
```
Now I get this error message instead:
```
java.lang.AssertionError: Value not present (latch = 0, values = 1, errors = 0, completions = 1)
```
I'm told that the value isn't present, which is slightly misleading as ""not present"" is different than ""does not match predicate."" But more importantly, I don't see what the ""not present"" value is, which is immensely helpful when debugging the test. My usual solution here is to use something like this instead:
```kotlin
Single.just(""foo"").test().assertValue {
    assert(it).isEqualTo(""bar"", ignoreCase = true)
    true
}
```
This code is more clunky, but gives me the actual value in the error message:
```
java.lang.AssertionError: 
Expected :""[bar]""
Actual   :""[foo]""
```
The cost is that I lose useful `(latch = 0, values = 1, errors = 0, completions = 1)` information.

Instead of having to make a choice between these two, it would be most helpful if the simplest solution was also just as informative:
```
java.lang.AssertionError: Value bar (class: String) did not match predicate (latch = 0, values = 1, errors = 0, completions = 1)
```

This extends to many other assertions as well. For example, if I called `assertNoValues()` but there was a value? I'd like to know what that value was.""> The cost is that I lose useful (latch = 0, values = 1, errors = 0, completions = 1) information

With `Single`, you have 3 states: not finished, success, failure. You can rule out the first two via `assertComplete` and `assertNoErrors`, then use your predicate that captures the value for you. Since you are on Kotlin, you can even make an extension method for it. =||= If I change the order by checking `assertComplete` first:
```
BehaviorSubject.createDefault(""foo"").test().assertComplete().assertValue { it.equals(""bar"", ignoreCase = true)}
```
then if the chain is not completed, I will learn that first, without learning the value, even if knowing the value would be more useful for debugging:
```
java.lang.AssertionError: Not completed (latch = 1, values = 1, errors = 0, completions = 0)
```

Even then, with a more complicated workaround available, why shouldn't the library's provided assertion method provide information (the exact value that failedthe predicate) that any programmer would like to know when their test fails? The only drawback I can think of is if the value has an overly long and unhelpful `toString`, but that's a minor drawback compared to the usefulness of seeing the value in all cases. =||= The library provides a limited set of assertions based on community feedback and usage. For anything more complicated, the `TestObserver` can be extended and you'll have direct access to the [received events](https://github.com/ReactiveX/RxJava/blob/67c1a367397f1167f9ad5639dd5071b6608e4230/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java#L35-L39) as well as add on-class methods. This will also let you call [fail()](https://github.com/ReactiveX/RxJava/blob/67c1a367397f1167f9ad5639dd5071b6608e4230/src/main/java/io/reactivex/rxjava3/observers/BaseTestConsumer.java#L96) to produce that particular formatted error message. =||= I'm not asking for a new assertion to be added, but for the existing assertion to have a better error message. Is there a reason for the ""value not present"" error message to not contain the value that failed the predicate? =||= It didn't fit the pattern expected vs actual because with a predicate there is no way to tell the expected, hence the actual was not considered to be printed either.

After further considerations and looking at other methods, the error message across the tester class can be improved. I'll prepare a PR with the changes. =||= Thanks! =||= "3.x: Improve error messages in the test consumers"This PR improves the error messages reported in the `TestObserver` and `TestSubscriber`:

- `assertValue(Predicate)` now shows the value that didn't pass the predicate
- `assertValueAt(index, T)`:
  - If the index is out of range, the message includes the valid range
  - the message now includes the index argument where the failure happened
- `assertValueAt(index, Predicate)`:
  - If the index is out of range, the message includes the valid range
  - shows the value at index that didn't pass the predicate
  - the message now includes the index argument where the failure happened
- `assertError(Predicate)` is now worded to indicate the exception did not pass the predicate

In addition, the verification tests for the error messages were not actually testing the error message with `assertThrows` and have been updated.

Resolves #7125 "David Karnokakarnokd12/06/20, 09:32:53 PM
6995.071443.x: Observable.amb marble diagram is a bit incorrect (or maybe it's a bug?)"Version: 3.0.4

The marble diagram for the `Observable.amb` operator is as follows:
![amb](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/amb.png)

This means that the second (looser) `Observable` stays active (subscribed) while the whole `amb` executes. But in fact all `Observables` except the first (winner) are being cancelled (disposed).

Please consider the following code snippet:
```kotlin
        Observable
            .amb(
                listOf(
                    Observable
                        .create<Int> {
                            Thread.sleep(500L)
                            it.onNext(1)
                            Thread.sleep(500L)
                            it.onComplete()
                        }
                        .subscribeOn(Schedulers.computation())
                        .doOnNext { Log.v(""MyTest"", ""1: next, $it"") }
                        .doOnComplete { Log.v(""MyTest"", ""1: complete"") }
                        .doFinally { Log.v(""MyTest"", ""1: finally"") },
                    Observable
                        .create<Int> {
                            Thread.sleep(250L)
                            it.onNext(1)
                            Thread.sleep(500L)
                            it.onComplete()
                        }
                        .subscribeOn(Schedulers.computation())
                        .doOnNext { Log.v(""MyTest"", ""2: next, $it"") }
                        .doOnComplete { Log.v(""MyTest"", ""2: complete"") }
                        .doFinally { Log.v(""MyTest"", ""2: finally"") }
                )
            )
            .doOnNext { Log.v(""MyTest"", ""amb: next, $it"") }
            .doOnComplete { Log.v(""MyTest"", ""amb: complete"") }
            .doFinally { Log.v(""MyTest"", ""amb: finally"") }
            .subscribe()
```

This code produces the following output:
```
2020-05-22 16:37:01.724 5954-5979/? V/MyTest: 2: next, 1
2020-05-22 16:37:01.724 5954-5979/? V/MyTest: 1: finally
2020-05-22 16:37:01.724 5954-5979/? V/MyTest: amb: next, 1
2020-05-22 16:37:02.224 5954-5979/? V/MyTest: 2: complete
2020-05-22 16:37:02.224 5954-5979/? V/MyTest: amb: complete
2020-05-22 16:37:02.224 5954-5979/? V/MyTest: amb: finally
2020-05-22 16:37:02.224 5954-5979/? V/MyTest: 2: finally
```

Also it would be nice to describe this behavior explicitly in Java docs.""Some of the older diagrams haven't been updated to include dispose/cancel information. The [newer ones are](http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Maybe.html#amb-java.lang.Iterable-):

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Maybe.amb.png) 

> Also it would be nice to describe this behavior explicitly in Java docs.

PR welcome.
 =||= "3.x: Update marbles of amb(), ambArray() and ambWith()"Update the marble diagrams in `Flowable` and `Observable`, indicating cancellation of the non-winners.

Resolves #6995

![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.amb.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.ambArray.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Flowable.ambWith.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.amb.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.ambArray.png)
![image](https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/Observable.ambWith.png)"David Karnokakarnokd01/08/21, 10:05:11 AM
7149.071502.x, 3.x RejectionExecutionException is not handled properly in FlowableObserveOn operator"there is a bug: in case if RejectionExecutionException is thrown by Executor this exception is just swallowed and is not propagated to external code. As the result such subscription is stuck

TestSubscriber<Integer> s = new TestSubscriber<>();
Flowable.just(1,2,3,4,5).observerOn(scheduler).subscribe(s);
s <<< does not receive anything, neither values nor error nor completion
any subsequent values also will be ignored, the subscription is stuck""`RejectionExecutionException` would be thrown if the underlying `Executor` gets shut down or runs on a bounded pool.

For the first case (shutdown), don't just shut down the executor, but have all outstanding flows depending on that scheduler cancelled too.

For the second case (bounded pool), there is no reason to bound the pool underneath RxJava; just use `Flowable`s for backpressure and thus implicit limit the amount of work.

As I mentioned in the PR, this can't be handled reasonably within RxJava. In essence, threads are critical resources, similar to memory, thus unavailability is a fatal error that can't be handled or recovered from within RxJava.
 =||= but backpressure is about scope of one subscription.... what if I want to limit resources across the whole process and not to store all incoming tasks to my executor

it seems a big limitation of api (bounded pool) and critical bug, because consumer can't even understand what happened with subscription, it is very hard to investigate such issues

maybe fix could be copied from here?
https://github.com/reactor/reactor-core/blob/master/reactor-core/src/main/java/reactor/core/publisher/FluxPublishOn.java =||= What resources do you want to limit? Backpressure can limit the number of items, thus memory. Using `computation`, `single` or a fixed-parallelism Executor limits the task amount. Yes, you can still create an unlimited amount of Flowables, but in that case, make the creation of such Flowables itself a backpressured Flowable.

> it is very hard to investigate such issues

The global error handler is notified.

> maybe fix could be copied from here?

There was a discussion back then and I warned about the implications and consequences. You can see a [few](https://github.com/reactor/reactor-core/issues?q=is%3Aissue+RejectedExecutionException+is%3Aclosed) reported. So no, we won't adapt their way of dealing with the problem.


 =||= > Yes, you can still create an unlimited amount of Flowables, but in that case, make the creation of such Flowables itself a backpressured Flowable.

 Yes I meant this, that it is possible executor is limited and used to serve not only scheduler's tasks in the entire process

Ok I understood your position, does it make sense at least to mention this behavior and consequences of bounded pool usage in docs to `Schedulres.from` method? =||= > does it make sense at least to mention this behavior and consequences of bounded pool usage in docs to Schedulres.from method

Yes. I'll add the notes to the methods. =||= "3.x: Document Schedulers.from's RejectedExecutionException handling"Updates the 3 overloads of `Schedulers.from` to describe (in a concise manner) the cases when the `Executor` would throw a `RejectedExecutionException`. Such exceptions can't be reasonably handled from within RxJava.

There are typically two cases when such exception would occur:

1) **The underlying Executor is shut down.** 

Operators such as `observeOn` guarantee worker-confinement when calling `onNext`, `onError` and `onComplete`. A failure to schedule would at best bypass this confinement, notifying the downstream on the current thread, at worst cause overlapping execution downstream.

The recommended workaround is to cancel all flows using the particular `Scheduler` after which the Executor can be shut down safely.

2) **The underlying Executor temporarily rejects more work.**

Such temporary rejections are often used in traditional `Executor` usages to drop work or pause the submission of work. In RxJava though, there is often no 1:1 correspondence to signals (`onNext`, `onError` or `onComplete`). Some work may be correlated to several `onNext`s, other work may be due to downstream requests. Dropping any such work may lead to inconsistent flow state or livelocks.

The recommended workaround is to express limits on the execution via backpressure (e.g., `Flowable`s).    

Resolves #7149"David Karnokakarnokd01/19/21, 05:23:32 PM
7119.07163TestScheduler doesn't use RxJavaPlugins.onSchedule hook"RxJava 2.2.20 and 3.0.7.
`TestScheduler` doesn't use `RxJavaPlugins.onSchedule` hook when scheduling tasks.
I believe this is an omission and it should respect the hooks just as other Schedulers do.

""It was not meant to be hookable like the standard schedulers. What is your use case? =||= Long story short, to transfer the gRPC Context when scheduling the tasks with Rx Schedulers.
We replace the Schedulers with `TestScheduler` in some of our integration tests for timing control, but then the Context propagation breaks =||= I see. 

There are currently no plans to change the `TestScheduler` in this regard. You can instead create a delegating `Scheduler` implementation backed by a `TestScheduler` and intercept any `schedule*` method calls on it and its `Worker`. =||= "3.x: TestScheduler option to use onSchedule hook"The `TestScheduler` is a bit inconsistent regarding the use of `RxJavaPlugins.onSchedule`. It extends `Scheduler` so the `scheduleDirect` methods do invoke the hook whereas the worker's `schedule` methods don't.

This PR adds a constructor flag to enable the use of the hook in the worker's `schedule` methods as well. This addition should avoid issues with existing tests not expecting the hook to be invoked all of a sudden.

Resolves #7119"David Karnokakarnokd01/27/21, 09:22:04 AM
7161.07164ScheduledRunnable.wasScheduled ?"The javadoc of `NewThreadWorker.scheduleActual` [refers](https://github.com/ReactiveX/RxJava/blob/0668d042b47d3585f856af831bd3b1e1742c080f/src/main/java/io/reactivex/rxjava3/internal/schedulers/NewThreadWorker.java#L121-L122) to a non-existent method/property `wasScheduled`.

It can be removed."Updating documentation for scheduleActual method"Remove unnecessary sentence from `NewThreadWorker.scheduleActual`.

Resolves #7161"Archish ThakkarArchish2701/26/21, 05:23:18 PM
7061.07165blockingForEach doesn't receive events from concatMapSingle"Hi @akarnokd, it's been a while!

Playing with 3.0.4 I found something that doesn't work as I expected. Don't see any issues posted recently about it, so wondering if it's a user error on my part, or if something is wrong with concatMapSingle. 

Here is code that demonstrates it. The first example sticks to Observables and concatMap, and correctly ticks 10 times, printing to the console. The second one just switches the code to using Single and concatMapSingle, and never prints anything, even though it ticks internally.

```java
import java.util.Random;
import java.util.concurrent.TimeUnit;

import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Single;

public class TestForEach {

	private static final Random RAND = new Random();

	public static void main(String... args) {

		// concatMap with Observable
		var o = Observable.range(0, Integer.MAX_VALUE).concatMap(i -> {
			// random delay before ""sending"" the request to simulate variance
			int delay = Math.max(10, RAND.nextInt(300));
			return Observable.timer(delay, TimeUnit.MILLISECONDS).take(1).map(l -> ""tick "" + i);
		});

		o.take(10).blockingForEach(s -> {
			System.out.println(""concatMap: "" + s);
		});

		// concatMap with Observable
		// THIS DOES NOT WORK, BUT I EXPECT IT TO DO THE SAME AS ABOVE
		var o2 = Observable.range(0, Integer.MAX_VALUE).concatMapSingle(i -> {
			// random delay before ""sending"" the request to simulate variance
			int delay = Math.max(10, RAND.nextInt(300));
			return Single.timer(delay, TimeUnit.MILLISECONDS).map(l -> ""tick "" + i);
		});

		o2.take(10).blockingForEach(s -> {
			System.out.println(""concaptMapSingle"" + s);
		});
	}

}

```""Hi Ben.

Example 2 does print 10 lines eventually and at once for me and would be considered the expected behavior. What happens is the main thread starts spitting out numbers from `range` rapidly of which 10 will eventually signal enough values so that `take` will stop `range` asynchronously. This then passes the control to the drain of `blockingForEach` which then prints the 10 items queued up in its buffer until then.

Example 1 behaves differently because `range` and `concatMap` fuse together, thus `range` no longer spits out values rapidly like above. `concatMap` then subscribes to an inner source and backs out so that the main thread can go into `blockingForEach` to wait for a value. The inner source succeeds asynchronously that allows `blockingForEach` to move forward and start the next inner source. If you put `hide` between `range` and `concatMap`, you can make it behave like Example 1.

You can somewhat avoid this same-thread blocking by using `subscribeOn` in example 2 but beware that `Observable.range` will still spit out a lot of values very rapidly thus it will most likely bog down the system. =||= Isn't 'Single' supposed to be semantically equivalent to 'Observable.take(1)'? Why wouldn't the fusing behavior occur the same with 'Single' vs 'Observable.take(1)'? For me, the difference in behavior breaks the point of having 'Single', as it's no longer able to be a semantic (and performant) replacement as it was intended to be. 

So is it just that 'concatMapSingle' has not had the work done to fuse, or is there some other reason? =||= By the way, I can of course just use 'Flowable' and that solves the issue with 'concatMapSingle', as it adds the backpressure. And that's what I'm doing. I was just confused by why 'Single' vs 'Observable.take(1)' aren't semantically the same in the example I originally posted. I feel they should be, otherwise it's confusing as a user why 'concatMap' and 'concatMapSingle' don't behave exactly the same (when take(1) occurs on the Observable version).  =||= The main issue is that `Observable.range()` occupies the main thread where you also want to block for consumption. Fusion just somewhat mitigates this property. Consequently, the following source would not give up the main thread regardless of `concatMap` or `concatMapSingle`:

```java
Observable.create(emitter -> {
    int i = 0;
    while (!emitter.isDisposed() && i < Integer.MAX_VALUE) {
       emitter.onNext(++i);
    }
    emitter.onComplete();
});
```

> So is it just that 'concatMapSingle' has not had the work done to fuse,

Fusion is not implemented there but could be. =||= > Fusion is not implemented there but could be.

Ah, this answers the question then. Thank you.

That is what was surprising as a user, as from an API perspective it is expected that they behave the same. But because fusion is only implemented on one of them, the behavior is not the same. My perspective is that a user should not need to understand a very nuanced difference like this. (I'm treating v3 as a user only, and not digging into the code as I would have done years ago.)

I suggest keeping this on the list then as an improvement for the future, to have `concatMapSingle` implemented with fusion, so that `Observable` vs `Single` don't behave differently. 

And yes, I know there are multiple ways of working around this, like the one you gave, or just using `Flowable`. My suggestion is that working around it should not be necessary, and that 'concatMap' and 'concatMapSingle' behave the same. 

Thank you @akarnokd for the rapid responses on this. Have a good day! =||= "3.x: Add fusion support to concatMap{Maybe|Single|Completable}"This PR adds front fusion support to
- `Flowable.concatMapCompletable`
- `Flowable.concatMapMaybe`
- `Flowable.concatMapSingle`
- `Observable.concatMapCompletable`
- `Observable.concatMapMaybe`
- `Observable.concatMapSingle`

The operators have been tidied up by factoring out common code paths.

In addition, the `DeferredScalarSubscription`'s fusion-emission had to be fixed. In async fusion mode, `onNext(null)` is generally expected from the upstream but `DeferredScalarSubscription` sent the value itself. Now it correctly sends `null`. (`DeferredScalarDisposable` already did this correctly).

Resolves #7061"David Karnokakarnokd01/27/21, 03:46:34 PM
7154.071693.x Feature: introduce abstract time source for scheduler impl"Version:
rxjava:3.0.9

Related:
https://github.com/ReactiveX/RxJava/issues/2943

Precondition:
* Task with delay scheduled in a `Scheduler`

Problem:
When the linux kernel wakes up from suspension `System.currentTimeMillis` will be adjusted on linux x86 OpenJDK. In my case this is bad, because watchdogs/ timer will fire, which they shouldn't. I would like to use a different time-source, but can't, because `System.currentTimeMillis` is hard-coded.

```java
    public long now(@NonNull TimeUnit unit) {
        return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);
    }
```

Solution:
I would like to introduce a `TimeSource` interface, which can be set via `RxJavaPlugins`.

```kotlin
interface TimeSource {
    fun now(unit : TimeUnit) : Long
}
```

Impl
```kotlin
class NanoSource : TimeSource {
    override fun now(unit: TimeUnit): Long {
        return unit.convert(System.nanoTime(), TimeUnit.NANOSECONDS)
    }
}
```

In order to not break the current behavior the default TimeSource would still be `System.currentTimeMillis()`. 

This idea was pitched by: @artem-zinnatullin in https://github.com/ReactiveX/RxJava/issues/2943#issuecomment-102455813

If this is fine request is fine with the community I would try to implement it quickly and create a PR for it.""You can override `now` when implementing `Scheduler` and `Worker` and delegate the other methods to an existing `Scheduler` and `Worker`. =||= @akarnokd , 
thank you for your response.

I actually do not want to implement/ delegate, because this will probably only work 'new' scheduler. What about `Schedulers.single` or `Schedulers.from` (`ExecutorScheduler`).

For example, when I use `Schedulers.single.worker()`, the implementation for `public Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit)` will be used from `super`, which uses `System.currentTimeMillis`. That said, I am unable to re-use already existing `Scheduler`, because it uses a clock, which is not desired. In my case `deep sleep` is a feature, which will occur quite often and other developers in different departments probably do not know, that `System.currentTimeMillis` is used and just use `Schedulers.single` for everything, which could cause very subtle bugs. 

Regarding delegation and overriding: Yes I could just wrap another Scheduler and overwrite now for `Worker` and `Scheduler` and use `RxJavaPlugins` in order to overwrite e.g. `Schedulers.single`, but I think this is actually more difficult, then just overwriting `System.currentTimeMillis` with an interface, which return a `long` as time-source. 

Performance wise I would reckon, that C2/ ART would just inline the call to the time-source, if `hot` enough, but I would bench it first.

Do you have a better idea how to easily switch the time without requiring to re-implement schedulers (e.g. reuse `Schedulers.single`)?  =||= Another idea would be to use the Java standard `ScheduledExecutorService` (provided it doesn't have the same timing problem) to drive your sensitive flows through `Subject`s and/or `Observable.create` emitting the ticks.

Otherwise, yes, we would need to add indirection to the `now` calculation. The problem then is, should it be affecting any and all default `Scheduler` implementations or should it be more coarse grained? =||= > Another idea would be to use the Java standard `ScheduledExecutorService` (provided it doesn't have the same timing problem) to drive your sensitive flows through `Subject`s and/or `Observable.create` emitting the ticks.
> 
> Otherwise, yes, we would need to add indirection to the `now` calculation. The problem then is, should it be affecting any and all default `Scheduler` implementations or should it be more coarse grained?

Is this a bad idea to add a method to RxJavaPlugins to override the default time source?
Something like this:
```
 /**
     * Sets the specific hook function.
     * @param handler the hook function to set, null allowed
     */
    public static void setTimeSourceHandler(@Nullable Function<? super TimeSource, ? extends TimeSource> handler) {
        if (lockdown) {
            throw new IllegalStateException(""Plugins can't be changed anymore"");
        }
        onTimeSourceHandler = handler;
    }
```

@SergejIsbrecht RxJavaPlugins can also be used to override single, io and computational schedulers. This doesn't cover Schedulers.from(), but at least it covers computation().
 =||= > Is this a bad idea to add a method to RxJavaPlugins to override the default time source?

I generally prefer to modify RxJavaPlugins as a last resort. =||= Dear @akarnokd,

I have been looking into `RxJava`s `Scheduler` implementation. I will sum up my findings as follows:

Scheduler
```
Scheduler {
    Default:
        Disposable scheduleDirect(@NonNull Runnable run)
        Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) // depends on Worker default-impl
        Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, @NonNull TimeUnit unit) // uses now(TimeUnit) transitively from Worker default-impl
        long now(@NonNull TimeUnit unit)
    Abstract:
        abstract Worker createWorker()
}
```

Worker
```
Scheduler.Worker {
    Default:
        Disposable schedule(@NonNull Runnable run)
        Disposable schedulePeriodically(@NonNull Runnable run, final long initialDelay, final long period, @NonNull final TimeUnit unit) // uses now(TimeUnit.NANOSECONDS)
        long now(@NonNull TimeUnit unit)
    Abstract:
        abstract Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit)
}
```

Example implementation of `SingleScheduler`

```
SingleScheduler {
    Override:
        Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit)
        Disposable schedulePeriodicallyDirect(@NonNull Runnable run, long initialDelay, long period, TimeUnit unit)
        Worker createWorker()
}
```

```
SingleScheduler.Worker {
    Override:
        Disposable schedule(@NonNull Runnable run, long delay, @NonNull TimeUnit unit)
}
```

Condition
* `SingleScheduler` uses a `ScheduledExecutorService` internally 
* `ScheduledExecutorService` uses `System.nanoTime` and `SingleScheduler.Worker#schedulePeriodically` uses `System.currentTimeMillis`

Problem:
`SingleScheduler` uses default impl `schedulePeriodically` from `SingleScheduler.Worker`, but overwrites `Scheduler#scheduleDirect` (with delay) & `Scheduler#schedulePeriodicallyDirect`

Conclusion:
Even one scheduler, in this case `SingleScheduler`, might use two different times, which might cause subtile issues, when returning from suspension (S2R). Any idea why `SingleScheduler.Worker` does not overwrite `SingleScheduler.Worker#schedulePeriodically`, just like it is done with `SingleScheduler#schedulePeriodicallyDirect`? I did not find a way to create a scheduler, which uses only one time-source at every case (e.g. ExecutorScheduler)

Regarding you suggestion:
> You can override now when implementing Scheduler and Worker and delegate the other methods to an existing Scheduler and Worker.

I do see a problem with this approach:
* in order to wrap a `SingleScheduler`, I would implement a new Scheduler and delegate all the work to given `SingleScheduler` and overload `now` with my time-source of choice. When looking into the implementation of `Scheduler` and `Worker` it becomes apparent, that `now` is actually only used in one place: `Scheduler.Worker#schedulePeriodically`. This means that this method should not be delegated in the new implementation, when `SingleScheduler` uses the default implementation. It can not be delegated, because the delegate would call now this it's `this` and not the overloaded `now`. This brings me to my point. I do need internal knowledge when and where `now` is used, which can change at any time. If this happens, my wrapper will probably not do what I want.

Conclusion: 
It might be possible to use a different time source, but in the light of how RxJava implements/ delegates to Executors, the only option is actually to use `System.nanoTime`, in order to garantuee, that all methods use the same time-source. 

Resolution:
Maybe we do not need a global time-source interface, which is set via `RxJavaPlugins` but extend some factory methods to take a time-source as a parameter when creating. By default a singleton of `System.currentTimeMillis` will be used. What do you think about it?

> Otherwise, yes, we would need to add indirection to the now calculation. The problem then is, should it be affecting any and all default Scheduler implementations or should it be more coarse grained?

I would probably not do it. There might be a use-case, there you want to configure how each `Scheduler` should behave (e.g. fire directly after suspension, when times will be adjusted and time > timer_fires_time or not fire, because time was not adjusted and time < timer_fires_time), but this could be done with a simple overload, when creating a `new` Scheduler witth the factory provided by `Schedulers`. But in my opinion there is actually only one value, which should be allowed, and this is `System.nanoTime`, because all work is already delegate to ExecutorService, which internally uses this time-source. This would make sure, that all methods use the same time-source. As I see it, no one ever had such a problem or did not bother, therefore the time and resources are probably not well spend to extend RxJava to support fine grained editing of the time-source.

SchedulerWrapper-Impl:
https://gist.github.com/SergejIsbrecht/2a9d71e781c6f35d7b74e9ae2bc0c6ef =||= [ObservableInterval](https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/internal/operators/observable/ObservableInterval.java#L50) uses `schedulePeriodicallyDirect`. Would it work for your periodic needs?

> Any idea why SingleScheduler.Worker does not overwrite SingleScheduler.Worker#schedulePeriodically, just like it is done with SingleScheduler#schedulePeriodicallyDirect

I have to think about this.

 =||= > ObservableInterval uses schedulePeriodicallyDirect. Would it work for your periodic needs?

This is probably more of a isosteric problen, than a real one. Our developers probably use every method in the `Scheduler` and `Worker` class. This is why I can not say in advance, which operators will be used. 

`Scheduler.Worker#schedulePeriodically`
* FlowableInterval
* FlowableBufferTimed
* FlowableWindowTimed

`Scheduler#schedulePeriodicallyDirect`
* FlowableInterval
* FlowableSampleTimed
* FlowableWindowTimed

For example when I use a `SingleScheduler` and compose a Stream, which uses `Scheduler.Worker#schedulePeriodically` and `Scheduler#schedulePeriodicallyDirect` a developer might run into trouble, because a timer fires after suspension, and another one does not.

Example
```
        // Scheduler#schedulePeriodicallyDirect
        Flowable.interval(10, TimeUnit.SECONDS, Schedulers.single())
            // Scheduler.Worker#schedulePeriodically
            .buffer(5, TimeUnit.SECONDS, Schedulers.single())
``` =||= I see.

For a start, would the introduction of a system property `rx3.scheduler.drift-use-nanotime` and behavior help you?

 =||= > For a start, would the introduction of a system property rx3.scheduler.drift-use-nanotime and behavior help you?

Yes, of course. This would be enough for me. I would probably call it `rx3.scheduler.now-use-nanotime`, but either way is fine.

Edit: if this is the way, I would like to suggest, that I backport this change back to RxJava2, because we are currently using it and we would not need to change, before RxJava2 reaches EOL on `February 28, 2021`

If you would like, I would create an PR for RxJava3 and RxJava3, adding said property. =||= > PR for RxJava3 and RxJava3, adding said property

Sure, go ahead. Let's use `rx3.scheduler.drift-use-nanotime` because there could be an implicit assumption that `now(TimeUnit.MILLISECONDS)` is the current time.

 =||= "3.x: Introduce property rx3.scheduler.use-nanotimeFixes #7154SergejIsbrecht01/28/21, 03:29:05 PM
71702.x: Introduce property rx2.scheduler.use-nanotime (#7154)Fixes #7169 SergejIsbrecht01/28/21, 03:49:52 PM
7172.071733.x StackOverflowError on prinln of Disposable returned from Scheduler"Version:
io.reactivex.rxjava3:rxjava:3.0.6

Example
```kotlin
    @Test
    fun stackoverflow() {
        val scheduleDirect = Schedulers.single().scheduleDirect {
            while (true) { }
        }

        println(scheduleDirect)
    }
```

This fails as-well:
```kotlin
    @Test
    fun stackoverflow() {
        val scheduleDirect = Schedulers.single().scheduleDirect({
            while (true) {
                // break
            }
        }, 1000, TimeUnit.MILLISECONDS)

        println(scheduleDirect)
    }
```

but not this:
```kotlin
    @Test
    fun stackoverflow() {
        val scheduleDirect = Schedulers.single().scheduleDirect({
            while (true) {
                break
            }
        }, 0, TimeUnit.MILLISECONDS)

        Thread.sleep(1)

        println(scheduleDirect)
    }
```

StackTrace:
```
java.lang.StackOverflowError
	at java.base/java.util.concurrent.FutureTask.toString(FutureTask.java:497)
	at java.base/java.lang.String.valueOf(String.java:2951)
	at java.base/java.util.concurrent.atomic.AtomicReference.toString(AtomicReference.java:275)
	at java.base/java.lang.String.valueOf(String.java:2951)
	at java.base/java.lang.StringBuilder.append(StringBuilder.java:168)
	at java.base/java.util.concurrent.FutureTask.toString(FutureTask.java:513)
	at java.base/java.lang.String.valueOf(String.java:2951)
	at java.base/java.util.concurrent.atomic.AtomicReference.toString(AtomicReference.java:275)
	at java.base/java.lang.String.valueOf(String.java:2951)
	at java.base/java.lang.StringBuilder.append(StringBuilder.java:168)
	at java.base/java.util.concurrent.FutureTask.toString(FutureTask.java:513)
	at java.base/java.lang.String.valueOf(String.java:2951)
	at java.base/java.util.concurrent.atomic.AtomicReference.toString(AtomicReference.java:275)
```

Analysis:
kind of looks like the toString() has a self reference, which triggers a `StackOverflowError`

Note: when I set some breakpoints and debug slowly the issue will not happen.""Which Java version? There is no line FutureTask.java:497 in JDK 8. =||= On newer JDKs, `FutureTask.toString` prints the wrapped [`callable`](https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/util/concurrent/FutureTask.java#L513). However, that is essentially goes to an [`AtomicReference<Future<?>>`](https://github.com/ReactiveX/RxJava/blob/8dd6f21fbe7fde96b62e29d7b035fa4e7f55e52e/src/main/java/io/reactivex/rxjava3/internal/schedulers/AbstractDirectTask.java#L31) which is then set to the encompassing future.

The fix is to override `toString`, but it is not possible to test this without using a newer JDK. =||= java -version
openjdk version ""11.0.6"" 2020-01-14
OpenJDK Runtime Environment AdoptOpenJDK (build 11.0.6+10)
OpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.6+10, mixed mode)
 =||= > On newer JDKs, `FutureTask.toString` prints the wrapped [`callable`](https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/util/concurrent/FutureTask.java#L513). However, that is essentially goes to an [`AtomicReference<Future<?>>`](https://github.com/ReactiveX/RxJava/blob/8dd6f21fbe7fde96b62e29d7b035fa4e7f55e52e/src/main/java/io/reactivex/rxjava3/internal/schedulers/AbstractDirectTask.java#L31) which is then set to the encompassing future.
> 
> The fix is to override `toString`, but it is not possible to test this without using a newer JDK.

openjdk version ""1.8.0_265""
OpenJDK Runtime Environment (AdoptOpenJDK)(build 1.8.0_265-b01)
OpenJDK 64-Bit Server VM (AdoptOpenJDK)(build 25.265-b01, mixed mode)

Yes, looks like Java8 works as expected. Interesting. I did not though off this.
 =||= @akarnokd , do I get this right?

I call: 
```java
    public Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) {
        ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run));
        try {
            Future<?> f;
            if (delay <= 0L) {
                f = executor.get().submit(task);
            } else {
                f = executor.get().schedule(task, delay, unit);
            }
            task.setFuture(f);
            return task;
        } catch (RejectedExecutionException ex) {
            RxJavaPlugins.onError(ex);
            return EmptyDisposable.INSTANCE;
        }
    }
```

`f = executor.get().submit(task);` task as input Parameter `Callable<Void>

The submitted `task` is of type (as follows). Which is why it is possible to pass it into `#submit`
```
io.reactivex.rxjava3.internal.schedulers.ScheduledDirectTask 
                    is AtomicReference<Future<?>> 
                    & Disposable 
                    & SchedulerRunnableIntrospection 
                    & Callable<Void>
```

The `#toString` method is overloaded by `AtomicReference<T>` (inheritance)
```
    public String toString() {
        return String.valueOf(get());
    }
```
`get()` (Future<?>) returns the scheduled task by the `executor`, which is of type `ScheduledFutureTask` & `FutureTask`.

`#toString` is called upon returned `ScheduledFutureTask` from `#get()`, which is implemented as follows:
```

    public String toString() {
        final String status;
        switch (state) {
        ...
        
        default:
            final Callable<?> callable = this.callable;
            status = (callable == null)
                ? ""[Not completed]""
                : ""[Not completed, task = "" + callable + ""]"";
        }
        return super.toString() + status;
    }
```
Because the current state of the Future is currently in NEW or COMPLETING, following branch will be taken:
```
            status = (callable == null)
                ? ""[Not completed]""
                : ""[Not completed, task = "" + callable + ""]"";
```
By taking this branch `#toString()` will be called upon `callable` (Callable<Void>), which is actually a `ScheduledDirectTask`. It's `#toString()` method will be called again (`AtomicReference#toString`), and we are on our way to a `StackOverflowError`.

Do you think we should override the toString behavior for `ScheduledDirectTask#toString`?
Currently `#toString()` in Java8 returns: `java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask@530612ba` =||= "3.x: Workaround for FutureTask.toString + JDK 11 build"Starting from JDK 10, the `FutureTask.toString` can now print the inner callable routine, which if somehow references the parent `FutureTask` again, it leads to `StackOverflowError`. This can happen in RxJava because `AbstractDirectTask` and `ScheduledRunnable` store the `Future` object returned by the executor in a reference field that gets accessed by their default `toString` implementation.

The fix is to define custom `toString`s that break this cycle. Note that we can't print the underlying `Runnable` either because that could also reference something in a circular manner. In addition, the release of the `runner` `Thread` marker has been moved closer to the exit of the wrappers which helps with the state determination and self-cancellation.

To verify the fix works, a new GitHub Action has been added, targeting JDK 11 as the issue does not manifest itself under the main target JDK 8.

Resolves #7172"David Karnokakarnokd02/01/21, 08:47:58 AM
7179.07181Bintray is closing down in May 2021"https://jfrog.com/blog/into-the-sunset-bintray-jcenter-gocenter-and-chartcenter/

I don't fully understand what this means for release processes using `gradle-bintray-plugin` or how to migrate.
""Can't we push to mavenCentral directly? =||= There are a few problems:
- The private key is on bintray and can't be extracted, only overwritten. (Maybe @benjchristensen still has it.)
- If we need to generate a new private key, I don't know/remember what to do with it. (It's been years since I setup my own private key for my libraries I release from my machine via your plugin.)
- I don't know how to inject a private key into the GitHub Action. (Having a GH secret string of the key material is one thing, afaik, it has to be imported into a keystore every time so Gradle's sign task can use it.) =||= I have all the ReactiveX keys.  =||= Secrets can be added to GitHub: https://github.com/vanniktech/gradle-maven-publish-plugin/settings/secrets/actions (replace username / repo with target repo):

<img width=""1236"" alt=""Screenshot 2021-02-03 at 22 46 15"" src=""https://user-images.githubusercontent.com/5759366/106813686-a0cc1900-6671-11eb-9fd1-ad2736999ccc.png"">

And then they can be used in GitHub actions:

```yml
name: Publish Release

on:
  push:
    tags:
      - '*'

jobs:
  publish:

    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Install JDK 8
        uses: actions/setup-java@v1
        with:
          java-version: 1.8

      - name: Upload release
        run: ./gradlew uploadArchives --no-daemon --no-parallel
        env:
          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_USERNAME: ${{ secrets.SONATYPE_NEXUS_USERNAME }}
          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_PASSWORD: ${{ secrets.SONATYPE_NEXUS_PASSWORD }}
          ORG_GRADLE_PROJECT_SIGNING_PRIVATE_KEY: ${{ secrets.SIGNING_PRIVATE_KEY }}
          ORG_GRADLE_PROJECT_SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}

      - name: Publish release
        run: ./gradlew closeAndReleaseRepoistory --no-daemon --no-parallel
        env:
          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_USERNAME: ${{ secrets.SONATYPE_NEXUS_USERNAME }}
          ORG_GRADLE_PROJECT_SONATYPE_NEXUS_PASSWORD: ${{ secrets.SONATYPE_NEXUS_PASSWORD }}
```

[Source](https://github.com/vanniktech/gradle-maven-publish-plugin/blob/master/.github/workflows/publish-release.yml)

They key itself needs to be distributed in order for this to work though. Instructions are [here](https://central.sonatype.org/pages/working-with-pgp-signatures.html). =||= I don't think we need to generate new keys. 

How do we get the existing private key up there? Do we need a gpg file added to the project, then reference it from gradle.properties (consequently the key id & passwords are the secrets in your example)?





 =||= Ah, there is an in-memory option: [link](https://github.com/vanniktech/gradle-maven-publish-plugin/blob/master/build.gradle#L104-L108)

It needs an armored-ascii key string: [link](https://docs.gradle.org/current/userguide/signing_plugin.html#sec:in-memory-keys)

This is how to export it: [link](https://wiki.scn.sap.com/wiki/display/XI/Generating+ASCII+Armored+PGP+Key+Pairs#GeneratingASCIIArmoredPGPKeyPairs-GenerateASCIIArmoredKeysfromGPGKeys) =||= Posted #7181.

@benjchristensen Could you update `SIGNING_PRIVATE_KEY` and `SIGNING_PASSWORD`  in [secrets](https://github.com/ReactiveX/RxJava/settings/secrets/actions) with the current RxJava private key info? =||= Yes, I'll do that.  =||= Trying to figure out which of the keys it is ... it's been a while :-) =||= I've got on PGP key with a passphrase, and one without. Not sure which one needs to be used here, so I'll upload the one with a passphrase.  =||= Ok, I guess that can be tried now, and if that doesn't work, I can change it to the other one. Do you need the public key or do you have that already? =||= No need for the public key. =||= First step, ensure the snapshot is still working. https://github.com/ReactiveX/RxJava/runs/1840358093
Next step, create a pre-release for 3.0.11-RC1 to see if the new process works. =||= Pre-released 3.0.11-RC1: https://github.com/ReactiveX/RxJava/runs/1840960933 =||= Almost works, @vanniktech 

No staging repository prefixed with ""ioreactivexrxjava3"" found. Mae sure you called ./gradlew uploadArchives and `mavenPublish.nexus.groupId` is set correctly. =||= Now [it failed with something](https://github.com/ReactiveX/RxJava/runs/1841200311) and I see two staging repositories opened within 30 seconds of each other. =||= It worked [this time](https://github.com/ReactiveX/RxJava/runs/1841376226).

3.0.11-RC3 should be in [maven central shortly](https://repo1.maven.org/maven2/io/reactivex/rxjava3/rxjava/3.0.11-RC3/).

@benjchristensen I think the key setup worked. =||= "3.x: Release to Sonatype directly"Update the release process to use Sonatype directly via the help of the `com.vanniktech:gradle-maven-publish-plugin`.

In order for it to work, two secrets has to be set in the [settings](https://github.com/ReactiveX/RxJava/settings/secrets/actions):

 - `SIGNING_PRIVATE_KEY`
- `SIGNING_PASSWORD`

The `SIGNING_PRIVATE_KEY` should be the ascii-armored private key to sign the JAR files and can be generated from a pgp keychain:

```
gpg --export-secret-key --armor ___key_name_here___ > private_key.asc
```

The `SIGNING_PASSWORD` is then the password for that `private_key.asc`.

I tested the process on my local machine as much as I could, but we'll only know if it really works when doing an RxJava release.

Resolves #7179"David Karnokakarnokd02/05/21, 04:48:09 PM
7190.071912.x & 3.x Question: Will ParallelFlowable support RxJavaPlugins#onFlowableSubscribe? "Hi
I'm trying to inject context(put to ThreadLocal) when subscribing with `RxJavaPlugins#onXxxSubscribe` to make each operation can access the context.
After running the test case, the Flowable runs correctly, but if I use `Flowable#parallel`, I think each subscribe doesn't use `RxJavaPlugins.onSubscribe` and I can't customize the subscriber.
Curious if it's intentioned, or for example, ParallelMap needs to like below in subscribe?

```
 @Override
    public void subscribe(Subscriber<? super R>[] subscribers) {
       .....
        for (int i = 0; i < n; i++) {
            // wrap with hook here?
            Subscriber<? super R> a =  RxJavaPlugins.onSubscribe(this, subscribers[i]);
            if (a instanceof ConditionalSubscriber) {
                parents[i] = new ParallelMapConditionalSubscriber<T, R>((ConditionalSubscriber<? super R>)a, mapper);
            } else {
                parents[i] = new ParallelMapSubscriber<T, R>(a, mapper);
            }
        }
        source.subscribe(parents);
    }
```"`RxJavaPlugins` needs a new overload and infrastructure for it. I'll post the enhancements soon. =||= 3.x: Add onSubscribe hook to ParallelFlowable operators"Parallel operators were missing an `RxJavaPlugins.onSubscribe` hook.

Resolves #7190"David Karnokakarnokd02/24/21, 04:40:47 PM
7195.07196GC friendly `Single.zip` operator"Version 3.0.10

Hey there, 

My use case requires me to load huge datasets into memory. I need multiple of those datasets to cross compare them in their entirety. I decided to use the `Single.zip` operator to combine them.

Example:

```java
public static void main(String[] args)
{
  Single.zip(
      Single
          .defer(() -> Single.just(buildHumongousCollection()))
          .subscribeOn(Schedulers.computation()),

      Single
          .defer(() -> Single.just(buildHumongousCollection()))
          .subscribeOn(Schedulers.computation()),

      (z1, z2) -> new Collection[]{ z1, z2 }
  )
      .map(zip ->
      {
        // do anything with any operators, for example building new objects from the source set
        return new String[]{ ""Foo"", ""Bar"", ""Baz"" };
      })
      .blockingSubscribe(result ->
      {
        // just here to allow setting a breakpoint
        for ( final var msg : result ) { System.out.println(msg); }
      });
}

private static Collection<byte[]> buildHumongousCollection()
{
  final var rand = new Random();

  final var result = new LinkedList<byte[]>();
  for ( int i = 0; i < 50_000_000; i++ )
  {
    final var buff = new byte[32];
    rand.nextBytes(buff);
    result.add(buff);
  }

  return result;
}
```

I noticed that when I reach `onNext` of my Observer within `subscribe` in my execution chain, The memory is still allocated and will never be collected. So I started to investigate and found the cause of it.

The `ZipCoordinator` within `SingleZipArray` does not drop the local value collection after completion:

https://github.com/ReactiveX/RxJava/blob/09b2b1b4c9428616b2634a67bea0ee5a09201007/src/main/java/io/reactivex/rxjava3/internal/operators/single/SingleZipArray.java#L106-L121

Since the ZipCoordinator will always reside within the stack of one of the living threads, the garbage collector will never collect the it and therefore also the dataset even though it can never be used again. The only way to access it is through private fields.

I'd suggest to insert
```java
values = null;
```
at 118 - it should allow gc to free the memory.""A temporary workaround for you could be `onTerminateDetach`.

`Arrays.fill` would be better so that `values` can remain final. Also `dispose` could clean the values too. `Maybe` could be verified in this regard. Would you like to submit a PR? =||= "3.x: Allow Single.zip and Maybe.zip result to be garbage collectedResolves #7195LinkiPinki02/25/21, 07:02:59 AM
7201.072033.x Flowable#sample may complete on an interrupted thread"Hi !

Using version 3.0.10, and the following code:
```java
int i = 0;
while (true) {
        System.out.println(""i = "" + i++);
        PublishSubject<Long> subj = PublishSubject.create();
        subj.toFlowable(BackpressureStrategy.ERROR)
	        .sample(10, TimeUnit.MILLISECONDS)
	        .doFinally(() -> {
		        System.out.println(String.format(""Current thread %s is interrupted: %b"", 
                                        Thread.currentThread().getName(),
				        Thread.currentThread().isInterrupted())
                        );
		        if (Thread.currentThread().isInterrupted()) {
			        System.exit(1);
		        }
	        })
	        .subscribe();
        subj.onNext(1L);
        
        Observable.timer(10, TimeUnit.MILLISECONDS)
	        .blockingSubscribe(any -> subj.onComplete());
}
```
the loop ends after a few iterations (usually between 250 and 300 on my device).

The first iterations give: `Current thread main is interrupted: false`.
And the last: `Current thread RxComputationThreadPool-7 is interrupted: true`.

I quite understand why I get this result, but I'm still surprised by it. Is it an known/accepted/intended behavior ?

NB 1: Using `buffer` unstead of `sample` gives the same result.
NB 2: Changing `sample` scheduler to `Schedulers.from(Executors.newSingleThreadExecutor(...))` causes the loop to never end.
NB 3: First observed with RxJava2, with no change in behavior.""This is possible behavior because your completion races with the sampling. When the upstream completes, the timer for the sampler thread is cancelled which interrupts it if it happens to run.

If you want to avoid interruption, run the `sample` on a non-interruptible scheduler via [Schedulers.from(Executor, boolean)](http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/schedulers/Schedulers.html#from-java.util.concurrent.Executor-boolean-). =||= Thanks for the explanation and the work-around.

I have been doing a few tests with `Schedulers.from(Executor, boolean)`.
Using `Executors.newSingleThreadExecutor()` has given the expected result (ie an interrupted thread with a value `true` for the boolean, no interruption otherwise).
Using `Executors.newSingleThreadScheduledExecutor()` has not. In both case my code ended with an interruption.
Is there something I have been missing ?
 =||= I don't understand what you are saying. Are you saying you tried my suggestion with those executors and still got the interruption in doFinally? =||= That's it.
I ran the code provided in my first post, with only one modification: I specified a scheduler for the `sample` operator.

I tried the following schedulers:

`Schedulers.from(Executors.newSingleThreadExecutor())`
`Schedulers.from(Executors.newSingleThreadExecutor(), true)`
Both had the expected result.

`Schedulers.from(Executors.newSingleThreadScheduledExecutor(), false)`
`Schedulers.from(Executors.newSingleThreadScheduledExecutor(), true)`
Both ended with an interruption. =||= I see.

Looks like the case with `ScheduledExecutorService` was missed when the non-interruptible feature was added. I'll fix it tomorrow. =||= "3.x: Fix Schedulers.from to honor interruptibleWorker across methods"The direct scheduling methods of the `ExecutorScheduler` created via `Schedulers.from(Executor, boolean)` did not fully honor the `interruptibleWorker` settings.

Fixes #7201 "David Karnokakarnokd03/05/21, 09:30:00 AM
7204.072053.x: Convert License from dangling Javadoc to block comment"The License block at the beginning of all java files is a dangling Javadoc which results in a minorly annoying warning in Intellij. Convert all headers to regular Java block comment. Licenses are not all standardized across files. Use most common License as standard.

Update Checkstyle to validate all Java files have License header. Remove custom unit test FixLicenseHeaders currently used to validate License."Closing via #7205 =||= Standardize java source headers"Convert License headers to block comments instead of dangling Javadoc comments. Use Checkstyle to validate Java source files have Licenses attached. Updated Checkstyle to most recent version. Updated Checkstyle configuration to remove mostly commented out code and update to correct DTD.

Removed unit test FixLicenseHeaders as the functionality is handled by the Checkstyle header validation.

One commit is Checkstyle and Gradle updates. Second commit is for all the Java source License updates.

Fixes #7204"benjamintboyle03/05/21, 09:23:18 AM
7211.07212CompositeException.printStackTrace vulnerable to OOM when there are too many exceptions wrapped."Hi RxJava community,

This is Quinn from Databricks engineering team. We recently encountered an OOM issue in our service, caused by the CompositeException.printStackTrace function, and would like to inform you about the context and suggest a follow-up.

Below are the details:

In the current implementation of printStackTrace in the class CompositeException (https://github.com/ReactiveX/RxJava/blob/3.x/src/main/java/io/reactivex/rxjava3/exceptions/CompositeException.java#L206),  it will append stackTraces from all exceptions in the `exceptions` attribute. In the worst case, if there are too many exceptions wrapped, the generated string can be very large. Additionally, the StringBuilder used in that function doesn't have any limit.

In the recent issue we encountered, there are 2834 exceptions in that exceptions attribute, generated a string of 100+Mb, causing the thread to run out of memory.

As a followup, there are multiple approaches to take:
1. Avoid using one StringBuilder for everything, and always flush into the PrintStreamOrWriter when possible.
2. Limit the size of the attribute `exceptions`
3. Reduce the size of `exceptions` by only printing distinct exceptions.


Some more context
* RxJava version: v3.0.x

Please let me know if you have any comment, thank you very much!"3.x: CompositeException.printStackTrace to write directly into PrintStream/PrintWriter"I don't remember why the stacktrace it wasn't printed directly via the PrintStream/PrintWriter; no reason to aggregate the entire string output.

Fixes: #7211"David Karnokakarnokd03/12/21, 03:13:12 PM
7226.072273.x: Migrate to native GitHub Dependabot"GitHub supports a native Dependabot implementation which provides better/easier integration with GitHub. Logs and details for dependencies will appear in the ""Insights"" menu on the GitHub repository page.

Steps to migrate to the native Dependabot:

- Disable dependabot-preview by removing RxJava repository from dependabot.com
- Dependabot [security updates enabled](https://docs.github.com/en/code-security/supply-chain-security/configuring-dependabot-security-updates#enabling-or-disabling-dependabot-security-updates-for-an-individual-repository) on GitHub repository
- dependabot.yml configuration file added to .github directory

An Administrator must perform the first two bullets. I will provide a pull request for the configuration file."Initial commit for dependabot.yml config file"This is the third part of converting to the native GitHub Dependabot per Issue #7226.

Note, this should probably not be merged until dependabot-preview has been disabled (first bullet of Issue #7226).

Resolves #7226"benjamintboyle04/09/21, 06:33:39 AM
7271.072722.x  Is this a typo in the Completable documentation ?"https://github.com/ReactiveX/RxJava/blob/2.x/src/main/java/io/reactivex/Completable.java

In line 52, 53:
Like Observable, a running Completable can be stopped through the Disposable instance provided to consumers through SingleObserver.onSubscribe.

It seems that ""CompletableObserver.onSubscribe"" has been typed into ""SingleObserver.onSubscribe"" here."Indeed there is a copy-paste error, including 3.x. I'll post a fix shortly. =||= 3.x: Fix copy-paste error in Completable javadoc"It was incorrectly referencing `SingleObserver` in one of the sentences.

Resolves: #7271"David Karnokakarnokd05/12/21, 12:21:02 PM
