Issue_NumberPR_NumberIssue_TitleIssue_BodyIssue_CommentsPR_TitlePR_BodyPR_CommentsPR_Author_NamePR_Author_UsernamePR_Closed_Date
155.0176Internal Comparator violates its general contract"Log from my test run:

java.lang.IllegalArgumentException: Comparison method violates its general contract!
    at java.util.TimSort.mergeHi(TimSort.java:868)
    at java.util.TimSort.mergeAt(TimSort.java:485)
    at java.util.TimSort.mergeForceCollapse(TimSort.java:426)
    at java.util.TimSort.sort(TimSort.java:223)
    at java.util.TimSort.sort(TimSort.java:173)
    at java.util.Arrays.sort(Arrays.java:659)
    at java.util.Collections.sort(Collections.java:217)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.orderedInstanceFieldsFrom(PropertyAndSetterInjection.java:125)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.injectMockCandidates(PropertyAndSetterInjection.java:100)
    at org.mockito.internal.configuration.injection.PropertyAndSetterInjection.processInjection(PropertyAndSetterInjection.java:77)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:68)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(MockInjectionStrategy.java:89)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:71)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.relayProcessToNextStrategy(MockInjectionStrategy.java:89)
    at org.mockito.internal.configuration.injection.MockInjectionStrategy.process(MockInjectionStrategy.java:71)
    at org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.apply(MockInjection.java:92)
    at org.mockito.internal.configuration.DefaultInjectionEngine.injectMocksOnFields(DefaultInjectionEngine.java:20)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.injectMocks(InjectingAnnotationEngine.java:100)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.processInjectMocks(InjectingAnnotationEngine.java:62)
    at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:56)
    at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:108)""It occures when bean under test has many fields (declaredFields.size = 44)
 =||= "Make PropertyAndSetterInjection field sorting consistent"#155 is caused by calling `Collections.sort` with a comparator that isn't always transitive, as in the case where sorting by name and sorting by type hierarchy imply different orders.

For example, with fields of type `[Iterable, Integer, Number]`, it gives `Iterable == Integer` and `Iterable == Number`, but also an inconsistent `Integer < Number`.

I'm not sure it's possible to sort consistently with a stateless `Comparator`, so this change switches to a `sortSuperTypesLast` method that first sorts by name and then shuffles any subclasses to after their superclasses. It's slower, but should be deterministic. The existing tests are preserved by leaving behind a dummy `Comparator` that uses the new sort method. New tests make sure that the sorted ordering doesn't depend on the original order.

Fixes #155."Joseph Waltonjosephw02/26/15, 10:28:02 PM
188.0211ArgumentCaptor no longer working for varargsI ran into the issue described here: http://stackoverflow.com/questions/27303562/why-does-upgrading-mockito-from-1-9-5-to-1-10-8-break-this-captor"Hi sorry for the late reply.
I reproduced the issue, not sure when I will be able to fix though.
 =||= fixed by #211 
 =||= "ArgumentCaptor no longer working for varargsFixes #188 . These commits should fix issue with capturing varargs.Lukasz Szewclukasz-szewc06/05/15, 02:18:58 PM
251.0252Unit tests improvements: migrate from legacy FEST Assert code to AssertJTriggered by #250.[#251] Migrate Fest Assert code to AssertJFixes #251Marcin Zajączkowskiszpak07/08/15, 04:16:33 PM
183.0286Feature request: Method to reset mock interactions/invocations without resetting stubs"I'm still missing the ability to reset the invocations on a mock, while keeping all the stubbing, so this is a GitHub equivalent of https://code.google.com/p/mockito/issues/detail?id=316

Some background discussion exists in a [thread](https://groups.google.com/forum/#!topic/mockito/5G-XnpIhP3s) that also refers to [issue 84](https://code.google.com/p/mockito/issues/detail?id=84) for which there already [is a GitHub issue](https://github.com/mockito/mockito/issues/86).""Hi, in your use case could you be interested to stubbing only i.e. not interested by verifications ?

In this case there's this setting may prove useful : `withSettings().stubOnly()`
 =||= No, that would not solve my problem.

My current issue is that I have a large number of permutations (x \* y) of input data, and the plan was to create reusable methods for one of the ""dimensions"" (`x_case1()`, `x_case2()`, `x_case3()`, ...) and then from each test case of the other dimensions (`@Test y_case1()`) call the methods of the first dimension **and pass a mock as a parameter**. That way I can set up the stubbing once, for the Y dimension, and then test and `verify()` the different X scenarios with that stub.

The workaround in this case could be to pass a lambda that does the stubbing, after each scenario has created it's mock.

(I do agree it would be preferable in this particular case to refactor this to something that is more testable, and hopefully I can get part of the way there, but sometimes reality is just complex and it is definitely not the first time I've missed this particular feature in Mockito.)
 =||= OK

Well at the moment the team is clearly busy in other RL projects. If you manage to make a nice PR (see the contributing guide) of this feature before we do work on it, which seems most probable we may integrate your work :)
 =||= I created a new issue (#284) for removing any invocations which have been verified. In my optioning resetting the invocations would then not been needed anymore and the current reset can stay as-is. This also give you a stronger guarantee that you're really verifying all invocations of the mock.
 =||= "Add new API method to reset invocations of a mock, while maintaining all existing stubbing"Add new API method to reset invocations of a mock, while maintaining all existing stubbing.

---

**EDIT by mockito team** : Fixes #183"Tim van der LippeTimvdLippe12/08/15, 02:03:02 PM
124.0287Concise way to collect multiple verify failures, ideally with JUnitCollector or  derivative"If you are using more than one verify statement as test post-conditions, it would be nice to be able to collect each failure and continue with the remaining verify statements or asserts that follow.  JUnit provides the ErrorCollector @Rule to facilitate this kid of thing, but the current [ErrorCollector API](http://junit.org/apidocs/org/junit/rules/ErrorCollector.html) requires either
- a Matcher<T> and a value to compare
- or a Callable<Object>

The Mockito verify statements only return void, however, since they depend on throwing exceptions.  I have not thought of an ideal, non-disruptive way to use JUnit's ErrorCollector to aggregate multiple Mockito verify failure""As a possible example of the way to handle it, maybe it could be modeled after the same way that AssertJ added deferred composite assertion handling through [their own JUnit @Rule](http://joel-costigliola.github.io/assertj/assertj-core-features-highlight.html#soft-assertions):
 =||= "Implement VerificationCollector which can collect multiple verifications.It will report in the end the result of multiple statements. Fixes #124 Tim van der LippeTimvdLippe12/08/15, 09:34:58 AM
245.0293Serializable check is too harsh"Hi, apologies if this has been discussed.

While upgrading my company's Mockito to 1.10.19, I ran into a lot of this error:

```
org.mockito.exceptions.base.MockitoException: 
You are using the setting 'withSettings().serializable()' however the type you are trying to mock 'OpportunityClient'
do not implement Serializable AND do not have a no-arg constructor.
This combination is requested, otherwise you will get an 'java.io.InvalidClassException' when the mock will be serialized
```

In summary, there are two cases triggering this error.
1. The SubjectUnderTest accepts an object Foo and requires it to be Serializable. And yet Foo doesn't implement Serializable nor has a default constructor.
2. Foo itself is Serializable. But the test calls `when(foo.createBar()).thenReturn(bar)`, which behind the scene puts the `bar` mock onto the state of foo, which requires bar itself to be Serializable. In production, bar isn't required to be Serializable.

I feel case 1 is possibly reasonable (although it's still kind of harsh. I'll get to it in a bit).

Case 2 should not require Bar to be Serializable as it does today. In version 1.9.5, our tests worked around it by using `mock(Bar.class, withSettings().serilizable()`. But in version 1.10.19, this workaround breaks if Bar has no default constructor.

Possibly the [Serializable Proxy Pattern](http://stackoverflow.com/questions/702357/what-is-the-serialization-proxy-pattern) could be used to solve this nicely by stashing the ""mock specifications"" into a proxy object that can later on deserialize itself back into a mock Bar with the same number of when().thenReturn().

Now let me try to explain why I think even case 1 is too harsh.

Philosophically, I feel that it's not Mockito's job to ensure the mocked object works in real life. It's a mock object after all. It isn't expected to meet all required specification of the real object.

When in a test I say `@Mock(serializable=true) Foo foo;`, I'm explicitly asking Mockito to ""please pretend my object be Serializable. I don't want to worry about the real object in this test"". Would the real object be serializable when I pass it into SubjectUnderTest? Well:
1. There is nothing guaranteeing that production code passes Foo to SubjectUnderTest. It could likely pass a cousin class RealFoo2 that implements Serializable just fine (or not, but the test doesn't help me with that). It needs to be tested, but IMHO not against a mock foo, especially when Mockito's when().thenReturn() syntax adds non-existent Serializable requirement to the mock object.
2. Given the proxy pattern, that Foo doesn't _look like_ a serializable class isn't a guarantee that it can't be. So by throwing this error, Mockito enforces stricter constraint than what's technically necessary.

I agree that checking basic Serializable requirement in Mockito can catch some bugs. If case 2 can be fixed, it's likely that case 1 would not have triggered so many false positives.

But with all our workarounds already added because of case 2 and the fair number of our tests triggering this error, the amount of work to fix all of them before we can upgrade Mockito looks daunting.

So, I guess my question is: **can we do away with MockCreationValidator.validateSerializable() or make it an opt-in?**

Sorry for the long message.""Here's a real example. The subject under test looks like this:

```
class SubjectUnderTest implements Serializable {
  private final FooFactory factory;

  SubjectUnderTest(FooFactory factory) {
    this.factory= factory;
  }

  ...
  Foo foo = factory.createFoo();
  ...
}
```

The testing framework actually tries to serialize SubjectUnderTest so FooFactory needs to be Serializable too.

The test using Mockito looks like this:

```
Foo foo = mock(Foo.class);
FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
when(mockFactory.createFoo()).thenReturn(foo);
SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
```

But when the framework serializes `subject`, we get an exception, because the line of `when(mockFactory.createFoo()).thenReturn(foo)` implicitly adds 'foo' as part of `mockFactory` state.

To work around the problem, our tests had to make foo serializable too:

```
Foo foo = mock(Foo.class, withSettings().serializable());
...
```

Again, production code doesn't need Foo to be Serializable and it may not have a default constructor.

That's status quo.

Now with v1.10.19, the above work-around breaks, because Foo doesn't implement Serializable nor has a default constructor.

Back to square one, if I had the choice, I would strongly discourage the code that mocks either FooFactory or Foo. Instead, it should just be a plain old FooFactory subclass that returns Foo. With Java 8, the syntax would actually become more concise than the mockito syntax. 

But I can't go back and fix so many teams' code. As it stands today, this is the biggest issue blocking the upgrade.

Hopefully I've made a clear case.
 =||= Thanks for reporting.

I'm ok with removing the check or making it smarter. It seems to be a legit
use case. Brice?

Cheers!

On Fri, Jul 3, 2015 at 2:50 PM, Ben Yu notifications@github.com wrote:

> Here's a real example. The subject under test looks like this:
> 
> class SubjectUnderTest implements Serializable {
>   private final FooFactory factory;
> 
>   SubjectUnderTest(FooFactory factory) {
>     this.factory= factory;
>   }
> 
>   ...
>   Foo foo = factory.createFoo();
>   ...
> }
> 
> The testing framework actually tries to serialize SubjectUnderTest so
> FooFactory needs to be Serializable too.
> 
> The test using Mockito looks like this:
> 
> Foo foo = mock(Foo.class);
> FooFactory mockFactory = mock(FooFactory.class, withSettings().serializable());
> when(mockFactory.createFoo()).thenReturn(foo);
> SubjectUnderTest subject = new SubjectUnderTest(mockFactory);
> 
> But when the framework serializes subject, we get an exception, because
> the line of when(mockFactory.createFoo()).thenReturn(foo) implicitly adds
> 'foo' as part of mockFactory state.
> 
> To work around the problem, our tests had to make foo serializable too:
> 
> Foo foo = mock(Foo.class, withSettings().serializable());
> ...
> 
> Again, production code doesn't need Foo to be Serializable and it may not
> have a default constructor.
> 
> That's status quo.
> 
> Now with v1.10.19, the above work-around breaks, because Foo doesn't
> implement Serializable nor has a default constructor.
> 
> Back to square one, if I had the choice, I would strongly discourage the
> code that mocks either FooFactory or Foo. Instead, it should just be a
> plain old FooFactory subclass that returns Foo. With Java 8, the syntax
> would actually become more concise than the mockito syntax.
> 
> But I can't go back and fix so many teams' code. As it stands today, this
> is the biggest issue blocking the upgrade.
> 
> Hopefully I've made a clear case.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-118431952.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Hi, is this reasonable? I can send a PR to remove this check, if it's okay with you guys.
 =||= Let's remove the check unless Brice objects ;)

On Fri, Sep 18, 2015 at 9:08 PM, Ben Yu notifications@github.com wrote:

> Hi, is this reasonable? I can send a PR to remove this check, if it's okay
> with you guys.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/245#issuecomment-141618665.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= @szczepiq @fluentfuture is this fix available in any of the mockito releases?
 =||= @vikkyrk since 2.0.31-beta
 =||= Thanks 
 =||= "Remove validateSerializable()"Fixes #245:

Remove serializable validation."Ben Yufluentfuture10/10/15, 06:19:04 PM
311.0314Add BDD version of verifyNoMoreInteractions()"Current state:

``` java
then(file).should().moveTo(directory);
verifyNoMoreInteractions(file);
```

Would be great to have BDD replacement for `verifyNoMoreInteractions()`. Then the test would be even nicer:

``` java
then(file).should().moveTo(directory);
then(file).shouldHaveNoMoreInteractions();
```

If you agree, I will submit a PR."Add shouldHaveNoMoreInteractions() to BDDMockito"Replicates `verifyNoMoreInteractions` on the BDD API.

---

**EDIT by mockito team** : Fixes #311"Michal Kordasmkordas12/08/15, 11:52:28 AM
316.0317"modify StackTraceFilter to not strip away ""good"" elements from the middle""according to javadoc of org.mockito.internal.exceptions.stacktrace.StackTraceFilter, filter works like this:
[a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, g+]
it would be better to not strip away ""good"" d and e elements:
[a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, d+, e+, g+]
What do you think about this? For me current behaviour is very inconvenient, I had to turn it off.""Modify StackTraceFilter to not exclude ""good"" stack trace elements""currently StackTraceFilter filters in this way (example from javadoc):
[a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, g+]

this patch makes it work:
[a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, d+, e+, g+]

Not sure why it was implemented first time in this strange manner.

---

**EDIT by Mockito team** : Fixes #316"Evgeny Astafyevastafev03/09/16, 02:13:05 PM
365.0373Simplify the InvocationOnMock-API to get a casted argument"The 2nd argument of  `InvocationOnMock.getArgumentAt(int,Class<T>)` can be removed cause it is not neccessary.

Intuitively on would write this to get a ""auto casted"" argument:
`String text = invocation.getArgumentAt(1,String.class)`

The type can be ommited without side effects (the implementation of InvocationOnMock discards it anyway).
`String text = invocation.getArgumentAt(1,null)`

Therefore Mockito 2.0 should consider to simplify the API and ommit the `Class`-argument here. Maybe it is also a good chance to simplify the method name too. What about  `getArgument(int index)` ?

This is how the 'new' API could look like:
`String text = invocation.getArgument(1)`""I would like to mention that sometimes class argument can be useful.

In my case I would like to catch object passed to mock and write to mongo database.
The code I would like to have is:

```
// test setup
doAnswer(invocation -> mongoTemplate.insert(invocation.getArgument(0, Person.class)))
  .when(mock)
  .myMethod(any());

// test execution 
mock.myMethod(new Person(""Joe"", ""Doe""))
```
The reason of problem is that `MongoTemplate` has 2 similar methods:
```
public <T> ExecutableInsert<T> insert(Class<T> domainType) {...) //(1)
public void insert(Object objectToSave) {..) //(2)
```
AFAIU, when I setup `doAnswer(invocation -> mongoTemplate.insert(invocation.getArgument(0))`, type inference will choose method (1) and finally I get class cast exception `Person` -> `Class`

Unfortunately, code `doAnswer(invocation -> mongoTemplate.insert((Person)invocation.getArgument(0))` does not compile

To implement my test, I have to define anonymous class `Answer` so my code is long-winded - one-liner looks much better
 =||= "Fixes #365 Simplify the InvocationOnMock-API to get a casted argument"This pull request fixes #365 by introducing `T getArgument(int)` and deprecating `T getArgumentAt(int,Class<T>)` in type `InvocationOnMock`. This improves the readabilty of custom Answers. 

This...
`String text = invocation.getArgumentAt(1,String.class)` 
can be replaced by... 
`String text = invocation.getArgument(1)` "Christian SchwarzChristianSchwarz04/22/16, 12:34:06 PM
312.0381ThrowsExceptionClass is urealiable - exception doesn't containt stack trace"The `ThrowsExceptionClass` is using `ObjenesisHelper.newInstance` which happens to have different strategy of creating objects depending on the JVM used. 
I'm using Java HotSpot VM. On this machine ,created `Throwable`, is initalized with all nulls.
As a result calling `throwable.fillInStackTrace()` has no effect and there is no chance the stack trace is ever filled. You can easily observe this behaviour by this sample code:

``` java
Throwable t = (Throwable) ObjenesisHelper.newInstance(Throwable.class);
t.fillInStackTrace();
t.printStackTrace();
```

After a bit of struggling I ended up using `ThrowsException` instead of `ThrowsExceptionClass`.

Objenesis strategy to create instances is dependent on VM name (returned by `System.getProperty(""java.vm.name"")`) so there is no 100% guarantee that this behaviour is reproduced on your machine.""OK thanks for the report, can you make a pull request to document that behaviour for `ThrowsExceptionClass`
 =||= Thanks @zbigniewTomczak for doing the research on this.  I just added the documentation.  It's in PR #381.
 =||= "Fixes #312.  Added documentation in OngoingStubbing.thenThrow().This fixes #312.  Added documentation in OngoingStubbing.thenThrow where new ThrowsExceptionClass() is used to create a new Throwable using Objenesis.Jonathan Lloydlloydjm7706/13/16, 07:22:24 AM
374.0404Remove deprecated API from Mockito 2 "# This is a reminder to remove all deprecated API's from the upcoming mockito 2.

This issue blocks #123 [Release Mockito 2.0](123)

Relates to 
-  #273 [Get rid of ReturnValues](273)"Fixes #374 Removed deprecated classes and methodsFixes #374 removed deprecated classes and methodsChristian SchwarzChristianSchwarz05/27/16, 06:48:10 PM
20.0424Implemented support for InOrder evaluation of Timeout VerificationMode"Fixed for [issue 292](https://code.google.com/p/mockito/issues/detail?id=292)

Note that while the provided wrapping mechanism is generic enough to support both 'timeout' and 'after' usage, the current implementation of VerificationWithTimeoutTest.java prevents correct usage with 'after'. This is because it repeatedly verifies until the timeout has elapsed, thus marking all invocations that may have matched in the meantime as verified. This will of course 'exhaust' correct invocations and more often than not fail on the verification before the 'ager time' has elapsed.""Hi, I'm basically ok with the PR, however I have a few remarks :
- I don't like the name `VerificationWrapperInOrderWrapper`, I would prefer something more meaningful, in the same way the existing `VerificationWrapper` could be renamed as well. If you have some proposition, I'll gladly hear them.
- Also it might be interesting to refactor existing code to support `VerificationInOrderMode` so the code don't have to check against `VerificationWrapper` class
 =||= I'll review it soon. Thanks for the PR!
 =||= This is a feature I'd like too. What's the status of this? Any plans to merge it or put it on the road map?
 =||= We want to merge it but so far there wasn't enough time. Sorry!
 =||= I could also use this feature! :+1: 
 =||= @sirchia could you please rebase this PR on current master, then I can take a look and review. Sorry for the extremely delayed response, hopefully you are still interested in making this contribution up-to-date.

If this PR is not updated within 2 weeks, I will close it as stale.
 =||= @TimvdLippe I had actually done that for my own private usage a while back. I've provided a https://github.com/mockito/mockito/pull/424 that rebases the original PR by @sirchia
 =||= "Inorder timeouts"  *Fixes issue https://code.google.com/archive/p/mockito/issues/292
  *Updated code provided by https://github.com/sirchia in PR #20

Closes #20"Michael PinnegarJazzepi06/19/16, 11:40:26 AM
426.0427Refactor instance based utility classes to static utility classes"The internal implementation of Mockito contains numerous helper classed that serve as a container for useful methods. By its nature these classes don't have a state. Currently some them are instance based in other word you need to create the utility class to call a helper method. This not only pollutes the heap but also the code cause instance methods can't be imported statically. 

Here is an example:

```java
Helper helper = new Helper();
if (helper.isInputValid(input)){
  [...] 
}
```

vs. static import of Helper.isInputValid

```java
if (isInputValid(input)){
  [...] 
}
```

The aim of this ticket is to identify canidates that can be refactored to static utility classes. If you like to refactoring and mockito feel free to send a PR and reference this issue.

Refactoring canidates:
- [ ] `AccessibilityChanger`
- [ ] `BeanPropertySetter`
- [ ] `ConditionalStackTraceFilter`
- [ ] `FieldCopier`
- [ ] `FieldReader`
- [ ] `GenericMaster` should be integrate into `GenericTypeResolver`
- [ ] `JUnitFailureHacker` can be removed when the deprecated `VerboseMockitoJUnitRunner` is removed
- [ ] `LenientCopyTool`
- [ ] `MatcherBinder`
- [ ] `MockitoCore` should better be a singleton
- [x] `MockCreationValidator`
- [ ] `RemoveFirstLine`
- [x] #591 `ArgumentMatchingTool`
- [x] #515 `AllInvocationsFinder`
- [x] #502 `ArgumentsComparator`
- [x] #540 `ArrayUtils`
- [x] #490 `AtLeastXNumberOfInvocationsChecker`
- [x] #490 `AtLeastXNumberOfInvocationsInOrderChecker`
- [ ] #912 `Constructors`
- [x] #427 `FieldSetter`
- [x] #908 `FriendlyExceptionMaker`
- [x] #431 `HandyReturnValues` 
- [x] #432 `InvocationMarker`
- [x] #462 `InvocationsFinder`
- [x] #908 `JUnitDetecter`
- [x] #490 `MissingInvocationChecker`
- [x] #490 `MissingInvocationInOrderChecker`
- [x] #514 `MockUtil`
- [x] #503 `NonGreedyNumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsInOrderChecker`
- [x] #907 `NumberOfInvocationsChecker`
- [x] #547 `ObjectMethodsGuru`
- [x] #427 `Reporter`
- [x] #535 `SuperTypesLastSorter`
- [x] #501 `TestMethodFinder`
- [x] #515 `VerifiableInvocationsFinder`""@raphw thanks for merging the PR that fast!  Would you mind reopening this ticket? There are more classes that can be refactored that way, I would like to extend the list.
 =||= Big :+1: for me btw, but please keep the pull requests managable and as small as possible. Preferably refactoring 1 method at a time. That way it is a lot easier to review.
 =||= I agree, there is nothing wrong with multiple PRs, the quick merge is a reaction to an easy overview (and being stuck at an Ukrainian airport without access to the Eurocup).
 =||= There are still two unit tests failing, could you have a look @ChristianSchwarz - I just had a quick look and there are two unit tests failing which seems related to the way you refactored the previous stubbing of the `Reporter`.

I should have checked more thoroughly before merging, hopefully you can fix the problem soon. Alternatively, I will just rollback the one commit (the first one is good) and we can reapply the patch once you fixed the two unit tests. Thank you, really, this was great clean-up.
 =||= I fixed the one test error. I push it tonight.

PS: I also fixed a bug in the stack trace cleaner. Not a biggy but please do not `@Ignore` tests. Especially in big commits, it is easy to miss that single annotation.
 =||= @raphw Which test(s) is/are failing? I will fix it asap! Too bad that some test fail on a regulare base, is it possible to ignore them in the ide only?
 =||= You can see the build output here: https://travis-ci.org/mockito/mockito#L254-L269

I advise you to run the tests with `./gradlew build`. This should work.
 =||= @TimvdLippe know what you mean! The next PR's include only one refactored class at a time.
 =||= I have it all fixed on local but I did not have access to wifi without 22 blocked. Will commit soon.
 =||= @raphw can you please reopen this issue 
 =||= Sorry, GitHub automatically closes issues that reference a PR.
 =||= @ChristianSchwarz If a commit contains a comment like ""Fixes #426"" the mentioned issue is automatically closed by github.
 =||= @PascalSchumacher Good to know! I will leave it out for the upcoming PR's. Thanks!
 =||= Now that we are pulling in static methods, I would like to propose a new (linter) rule. To make it easier to read a file, I would like that all methods invoked in the current class are referenced with `this.` (and `super.` for that matter). Therefore if we see `this.verify`, we know it is in the current class and the same object, whereas `verify` references a static method in this class, or an imported static method. Do you agree @mockito/developers ?
 =||= > I would like that all methods invoked in the current class are referenced with this. (and super. for that matter).

To me it feels like unnecessary/duplicate code cause `this` is implicit. Adding `this.` before every instance call would create a lot more text and would IMHO reduce readability. E.g.:

`this.doSometing(this.withPrivateMethod())` vs. `doSomething(withPrivateMethod())`

> Therefore if we see this.verify, we know it is in the current class and the same object, whereas verify references a static method in this class, or an imported static method.

An other option avoid ambiguity is to qualify static methods via its class name.  This way you can also distinguish which verify(..) is called ( `MockitoCore.verify(..)` / `Mocktio.verify(..)`) , which is not an easy task when a static import is used.
 =||= I'm not coding too much in Mockito ATM (hopefully now after SpringOne conference I'll have more time) but I fully agree with @ChristianSchwarz . IMO the best solution is to: 
- omit `this` before method calls. 
- if necessary provide the class for static method call
 =||= Respectful -1

I like when the class formally declares collaborators instead of calling out to static methods. This makes it easy to reason about the code. I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc. Another use case is when we discover missing/incorrect unit test coverage (or we do some larger refactorings) and we cannot easily write tests because code is too procedural.

The benefits for converting to static utilities have minimal significance to me. Yet, there is a downside I care about (e.g. maintainability of procedural code, static methods that consume static methods, that consume static methods...).

Hence, I down vote this sort of changes. Going down this path, all stateless classes in Mockito would become static utilities :)

You can get +1's from other maintainers and have your changes merged - I'm not here to block your changes but to give honest feedback. I see merit in arguments for static utilities. They do not outweigh the cost in my opinion.
 =||= I'm mitigated about this as well. I understand well that mockito creates garbage, but they are short lived and **most probably** won't go in the old generation especially in the test phase. Yet the faster the tests are the more developers will run them, it **may** have impacts on big projects. Also design wise I don't like much static methods too.

However I don't totally agree with the above points : 

> I don't need to read every line of code in the class to find out external couplings realized via static methods. I can see the couplings via fields, I can easily query how the field variable is used, etc.

Coupling appears also in the import section ; static methods are visible there. And modern IDE usually highlight this. IntelliJ even have a warning if import section is too big, just as there's warning if there's too many fields. This point should not be the reason to avoid static methods.

> maintainability of procedural code, static methods that consume static methods, that consume static methods...

Having instance methods does not protect again procedural code.

---

I believe there's middle ground there : 
- Mockito project contains a lot of small utility stateless objects that are supporting mockito features, these are usually collections tools, reflection tools, those could are good candidate for static methods. Objects like `FieldSetter`, `FieldCopier`, `LenientCopyTool` could be nice candidate for static methods
- Mockito features could be backed by object instances. Objects like `MockitoCore`, `MockCreationValidator`, `ArgumentMatchingTool` are candidate to stay objects.
 =||= Exactly the middle ground described by Brice is my motivation for merging most of the PRs. This is also the reason I have not yet merged the MockitoCore PR for this exact reason.

If an object is not a attribute or parameter, but an internal creation and immediately dismissed, I value a pure function more.
 =||= Thought: when we switch to Java 8, we can use interfaces with default
methods. The switch from static utility to interface is very easy now (just
a couple of text replaces, no method reference modifications).

On Fri, 12 Aug 2016, 17:23 Brice Dutheil, notifications@github.com wrote:

> I'm mitigated about this as well. I understand well that mockito creates
> garbage, but they are short lived and _most probably_ won't go in the old
> generation especially in the test phase. Yet the faster the tests are the
> more developers will run them, it _may_ have impacts on big projects.
> Also design wise I don't like much static methods too.
> 
> However I don't totally agree with the above points :
> 
> I don't need to read every line of code in the class to find out external
> couplings realized via static methods. I can see the couplings via fields,
> I can easily query how the field variable is used, etc.
> 
> Coupling appears also in the import section ; static methods are visible
> there. And modern IDE usually highlight this. IntelliJ even have a warning
> if import section is too big, just as there's warning if there's too many
> fields. This point should not be the reason to avoid static methods.
> 
> maintainability of procedural code, static methods that consume static
> methods, that consume static methods...
> 
> ## Having instance methods does not protect again procedural code.
> 
> I believe there's middle ground there :
> 
>    -
> 
>    Mockito project contains a lot of small utility stateless objects that
>    are supporting mockito features, these are usually collections tools,
>    reflection tools, those could are good candidate for static methods.
>    Objects like FieldSetter, FieldCopier, LenientCopyTool could be nice
>    candidate for static methods
>    -
> 
>    Mockito features could be backed by object instances. Objects like
>    MockitoCore, MockCreationValidator, ArgumentMatchingTool are candidate
>    to stay objects.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/426#issuecomment-239476519,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDb6QVlVesWgPAhurimgSUPQTRcTZSks5qfJALgaJpZM4IzjKm
> .
 =||= This feels like a misuse of the default methods.
 =||= I think you mean static-methods in interfaces here? Default-methods require an instance to be called on.
Anyway I don't think that it is a good idea.  It would a result in an interface that is not intended to be implemented or extended and only serves as container for utility methods. IMHO a class with private constructor is the best construct to do this.
 =||= > > Thought: when we switch to Java 8, we can use interfaces with default
> > methods.
> 
> Default-methods require an instance to be called on.

I was thinking exactly that, default methods in the interface plus instance (either as a separate file or as a singleton declared within the interface).
 =||= @ChristianSchwarz What do you think to continue the work here with the middle ground described [here](https://github.com/mockito/mockito/issues/426#issuecomment-239476519) ?
 =||= I am attempting to refactor the MatcherBinder class to a static utility class and am having trouble refactoring the following from MockHandlerImplTest.java: `
handler.matchersBinder = new MatchersBinder() {
            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
                throw new InvalidUseOfMatchersException();
            }
}; `
How can I maintain the abstract class definition when I am not able to create an object of MatcherBinder?

Any help is appreciated!  =||= Let's close this ticket. Refactorings can be done as needed as we work with the code. =||= "Refactored class Reporter to a static utillity"Fixes #426 for class Reporter 

This PR changes the way errors are created and thrown. All methods of the Reporter are now static so they can be imported statically and return an exception instead of throwing it directly. This improves the readability and eliminates the use of hacks to satisfiy the compiler.

Here is a sample:

```
public List<T> getLastVarargs() {
        if (arguments.isEmpty()) {
            Reporter().noArgumentValueWasCaptured();
            return null;
        } else {
            return arguments.getLast();
        }
}
```

The above code snipped can be rewritten to this:

```
public List<T> getLastVarargs() {
        if (arguments.isEmpty()) {
            throw noArgumentValueWasCaptured();
        } 
        return arguments.getLast();
}
```"Christian SchwarzChristianSchwarz06/11/16, 03:16:41 PM
304.0442Problem verifying bridge methods"Hello, I think there might be a bug in mockito when verifying bridge methods.
The bug is present both in version 2.0.31-beta, and in version 1.10.19.

``` java
import java.io.Serializable;
import org.junit.Test;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;

public class MockitoBridgeTest {

    @Test
    public void test() {
        Extended ext = mock(Extended.class);
        ext.test(""123"");
        verify(ext).test(""123""); // Passes
        ((Base<String>)ext).test(""456"");
        verify(ext).test(""456""); // Fails
    }

    public interface Base<T extends Serializable> {
        int test(T value);
    }

    public interface Extended extends Base<String> {
        @Override
        int test(String value);
    }

}
```""The problem here is the following: Byte Buddy does not intercept bridge methods but assumes that these methods should be dispatched _as they are_. Therefore, the actual method is still invoked which is then intercepted. As a result, the `Method` instance that is bound to this interception is the actual method, i.e. `test(String)` and not `test(Serializable)` which was identified as the bridge. The behavior of cglib is similar.

Mockito on the other hand picks up the invoked method from the call site which is `test(Serializable)` fpr the secod example. Therefore, Mockito claims that another method is invoked. Instead, Mockito would need to resolve the method to its actual target in order to validate that this method is a bridge for `test(String)`.

I am going to look into how this can be added to Mockito. This requires resolving parameterized tyes along the hierarchy in order to find out to what method the bridge is actually pointing to.
 =||= Since somebody else has this issue, I found a workaround to make the test pass:

``` java

        ((Base<String>)ext).test(""456"");
        verify(ext).test(""456""); // Fails
        ((Base<String>)verify(ext)).test(""456""); // Passes (workaround)
```
 =||= @bric3 Would it be a feasible solution if I relied on Byte Buddy APIs to resolve this? I implemented a rather elaborate algorithm that I have tried to port to Mockito. However, its not as easy as I thought since the algorithm and related data structure are quite bound into the Byte Buddy APIs. I would of course add an interface that does not rely on Byte Buddy for querying this information but asking the library to do it would be the most straight-forward solution.
 =||= @raphw That is possible, maybe in the form of a _`Plugin`_ that ByteBuddy mockmaker implement, maybe we would need a default implementation, i.e. that does nothing.
 =||= "enable some ignored tests of BridgeMethodsHitAgainTest and DetectingF…"…inalMethodsTest

This worked locally, so let's see if this also works on the ci server.

Fixes #304 "Pascal SchumacherPascalSchumacher06/19/16, 11:43:27 AM
438.0444Add ElementType.PARAMETER to @Mock"Parameterized tests are becoming more common - JUnit 5 explicitly allows parameters and the sample [MockitoExtension](https://github.com/junit-team/junit5-samples/tree/master/junit5-mockito-extension/src/main/java/com/example/mockito) currently includes an @InjectMock to trigger the creation of a mock parameter.  It would be so much cleaner to use @Mock in both places.

This shouldn't be an issue for most legacy test systems since they don't allow test parameters (by default). ""@smoyer64 I think that is a reasonable addition. Do you maybe have a sample JUnit test case that I can add to our test suite as regression test?
 =||= @TimvdLippe,

Will this change be going into Mockito 1.x or 2.x (or both)?
 =||= @sbrannen Mockito 2.0. We might be able to port back to Mockito 1.x but I would prefer not to. Is there an explicit requirement for this change to be included in 1.x?
 =||= Regarding a regression test, this should do the job!

``` java
import static org.junit.Assert.assertTrue;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

import org.junit.Test;
import org.mockito.Mock;

/**
 * It's actually sufficient if this class compiles. The test methods
 * are therefore a bit superfluous.
 *
 * @author Sam Brannen
 */
public class MockAnnotationDeclarationTests {

    @Mock
    String foo;

    void bar(@Mock String baz) {
    }

    @Test
    public void mockAnnotationCanBeDeclaredOnField() throws Exception {
        Field field = getClass().getDeclaredField(""foo"");
        assertTrue(field.isAnnotationPresent(Mock.class));
    }

    @Test
    public void mockAnnotationCanBeDeclaredOnParameter() throws Exception {
        Method method = getClass().getDeclaredMethod(""bar"", String.class);
        assertTrue(method.getParameters()[0].isAnnotationPresent(Mock.class));
    }

}
```

So feel free to use that.

Cheers,

Sam
 =||= @TimvdLippe,

I don't suppose there is an explicit _requirement_ per se to have this support in 1.x; however, I feel it could well benefit 1.x users who also wish to use JUnit 5. Furthermore, I cannot foresee any possible negative side effects for 1.x users: it's 100% backwards compatible.
 =||= I do not think we really have an infrastructure to still publish Mockito 1 artifacts. We did however not change much in 2 and 99% of all Mockito code should run as expected after updating. Mainly, we removed deprecated code that people had years to upgrade.

I think adding this should be okay even though there is no scenario where Mockito itself would process the annotation. Would adding an annotation to the JUnit plugin not be another altivertive? I wonder if that was a cleaner solution.
 =||= > Would adding an annotation to the JUnit plugin not be another altivertive? I wonder if that was a cleaner solution.

Introducing a new annotation in Mockito's official JUnit 5 support is of course technically possible -- that's what our proof-of-concept `MockitoExtension` does today (i.e., we created an `@InjectMock` annotation).

But... I don't think I would call that a _cleaner solution_. IMHO, a single annotation from Mockito would be the cleanest solution since it would result in the **element of least surprise** for users of Mockito.

FWIW, we have already hashed out the [exact same discussion for the Spring Framework](https://jira.spring.io/browse/SPR-14057) with regard to Spring's `@Autowired` annotation. Previously, it was not allowed to be declared on a constructor or method parameter, but we changed this for Spring 4.3.
 =||= Ok, considering that JUnit and Mockito is such a common combination, let's just make it as easy as possible.
 =||= Sounds good! 👍 
 =||= Wow ... a lot of work got done while I was out celebrating Father's Day.  From a user's perspective, this all looks perfect.  How often do you get everything you ask for?  I guess I have one final  question which, since this issue is closed, is more academic - where should an official, production ready MockitoExtension for JUnit 5 be hosted?  MockitoJunit is obviously part of the Mockito project and the MokitoExtension will always rely on both Mockito and JUnit 5.

Maintaining the status quo would be fine, but it might also make sense to create a junit5-extensions project for ""common combinations"" (using the wording above), where a combination of project maintainers could collaborate on code that is essentially the intersection of their projects?  External Extensions and TestEngines are going to be documented in the JUnit 5 wiki per issue https://github.com/junit-team/junit5/issues/297 and, given the collaboration demonstrated by this thread, maybe the whole question is moot.

In any case, thanks for all the hard work that's gone into both projects!
 =||= @smoyer64 You got lucky we are working hard on releasing Mockito 2.0 :smile: 

I am not sure what the stance is of the JUnit team regarding such extensions. Could you open an issue on JUnit5 to discuss where such extensions should be placed?
 =||= @TimvdLippe 

The question has been posed to the JUnit 5 team in issue https://github.com/junit-team/junit5/issues/321.  @sbrannen is a member of that team, so I'm guessing he's already seen the question ;).  And I'm just one of those pesky users (trying to help identify use cases and stress-test the new code)!
 =||= Thanks a lot. Looking forward to their response.
 =||= "Add PARAMETER ElementType to @Mock"TODO: Add a regression test to also show how this functionality can be used. CC @smoyer64

Fixes #438 "Tim van der LippeTimvdLippe06/19/16, 04:43:18 PM
385.0471OSGi metadata is incorrectThe manifest is incorrectly exporting the org.objenesis package. This package is not included in the mockito jar, so this package needs to be imported rather than exported."Is it a duplicate of #383? 

We need help fixing OSGi support. See my comment in #383 

Thanks for reporting!
 =||= @seanrohead Which version are you referring to? I just checked the manifest of the latest version (`2.0.63-beta`) and the only mention of `org.objenesis` in the import package section. I guess https://github.com/mockito/mockito/pull/388 fixed this issue. I would be nice if you could give `2.0.63-beta` a try and let us know if it works for you. Thanks!
 =||= It looks like the metadata is now correct, however when running tests in an osgi container, I am unable to mock classes (see error below). I built a custom version of the mockito jar and embedded the byte-buddy and objenesis classes inside the mockito jar (instead of loading them as separate bundles) and the error went away. I think the problem is that byte-buddy classloader doesn't have access to the same classes as the mockito classloader when they are in separate bundles. I'm happy to send a copy of the jar file that I was able to get to working.

This is the error I get if I use the mockito jar file in maven (org.mockito:mockito-core:2.0.70-beta):

```
com.proofpoint.governance.agent.tagging.file.sync.test.TaggedFileSyncServiceIntegrationTest STANDARD_ERROR
    org.mockito.exceptions.base.MockitoException:
    Mockito cannot mock this class: interface com.proofpoint.governance.agent.tagging.file.sync.api.ServerTaggedFileSyncService

    Mockito can only mock visible & non-final classes.
    If you're not sure why you're getting this error, please report to the mailing list.

    Underlying exception : java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#findClass

        at com.proofpoint.governance.agent.tagging.file.sync.test.osgi.FileTaggingSyncTestActivator.init(FileTaggingSyncTestActivator.java:14)
        at com.proofpoint.governance.common.osgi.api.BaseActivator.init(BaseActivator.java:36)
        at org.apache.felix.dm.DependencyActivatorBase.start(DependencyActivatorBase.java:75)
        at org.apache.felix.framework.util.SecureAction.startActivator(SecureAction.java:697)
        at org.apache.felix.framework.Felix.activateBundle(Felix.java:2226)
        at org.apache.felix.framework.Felix.startBundle(Felix.java:2144)
        at org.apache.felix.framework.Felix.setActiveStartLevel(Felix.java:1371)
        at org.apache.felix.framework.FrameworkStartLevelImpl.run(FrameworkStartLevelImpl.java:308)
        at java.lang.Thread.run(Thread.java:745)
    Caused by: java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#findClass
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Resolved.loadClass(ClassInjector.java:401)
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:210)
        at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:204)
        at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default.load(ClassLoadingStrategy.java:119)
        at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4350)
        at org.mockito.internal.creation.bytebuddy.MockBytecodeGenerator.generateMockClass(MockBytecodeGenerator.java:60)
        at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator$CachedBytecodeGenerator.generate(CachingMockBytecodeGenerator.java:73)
        at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator$CachedBytecodeGenerator.getOrGenerateMockClass(CachingMockBytecodeGenerator.java:65)
        at org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator.get(CachingMockBytecodeGenerator.java:28)
        at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createProxyClass(ByteBuddyMockMaker.java:54)
        at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:27)
        at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:33)
        at org.mockito.internal.MockitoCore.mock(MockitoCore.java:64)
        at org.mockito.Mockito.mock(Mockito.java:1559)
        at org.mockito.Mockito.mock(Mockito.java:1472)
        ... 9 more
    Caused by: java.lang.NoClassDefFoundError: org/mockito/internal/creation/bytebuddy/MockMethodInterceptor$MockAccess
        at java.lang.ClassLoader.defineClass1(Native Method)
        at java.lang.ClassLoader.defineClass(ClassLoader.java:763)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Resolved.loadClass(ClassInjector.java:397)
        ... 23 more
    Caused by: java.lang.ClassNotFoundException: org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$MockAccess
        at java.lang.ClassLoader.findClass(ClassLoader.java:530)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at net.bytebuddy.dynamic.loading.MultipleParentClassLoader.loadClass(MultipleParentClassLoader.java:67)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        ... 30 more
```
 =||= I think you are right and we did it wrong when we ported the old ""searching class loader"" to Byte Buddy's multiple parent class loader. The old solution strongly referenced types defined by cglib while Byte Buddy short wires the interceptors from Mockito without creating any Byte Buddy dependency. Typically, Byte Buddy's and Mockito's class loaders are equal. This is only not the case when exporting both libraries as OSGi bundles. If you bundle both libraries in the same jar, this class loader equality is reinstated which is why this works.

As a consequence of the change code generation strategy, we do not even need to export Byte Buddy, it is never exposed by Mockito in the generated code.

As you already created a custom build, can you try changing the `MockBytecodeGenerator` to create a multiple parent class loader as follows:

``` java
new MultipleParentClassLoader.Builder()
  .append(features.mockedType)
  .append(features.interfaces)
  .append(Thread.currentThread().getContextClassLoader())
  .append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
  .append(MockMethodInterceptor.class, 
               MockMethodInterceptor.ForHashCode.class, 
               MockMethodInterceptor.ForEquals.class)
```

Thank you for your analysis and help so far, we appreciate it!
 =||= "Reference correct types for multiple parent class loader if user class and Mockito are loaded by different loaders (e.g. OSGi)Fixes #385.Rafael Winterhalterraphw06/28/16, 09:24:44 AM
226.0481Exclude internal package from javadoc"Internal package don't need to be included in the javadoc generation, just like the jdk doesn't have `com.sun` package

In the javadoc that may be done via a doclet since `exclude '**/internal/**'` raise javadoc errors

``` groovy
doclet = ""qualified.name.of.DocletExclude""
docletpath = [rootProject.file('./gradle/doclet-exclude.jar')]
```""Great idea.
 =||= "Exclude mockito internal packages from the Javadoc"This one was a toughy, but I managed to write a Doclet that post-processes the generated classes. It filters all internal classes. This way, there are no compilation failures when generating the Javadoc if you would use `exclude ""**/internal/**""`.

Fixes #226 "Tim van der LippeTimvdLippe07/06/16, 12:36:15 PM
123.0483Release Mockito 2.0"Incompatible changes:
- [x] stop producing mockito-all #153
- [x] stop depending on hamcrest internally #154
- [x] use newer hamcrest #232
- [x] make the anyXxx and any(Xxx) matchers intuitive #134, #194
- ~~fix the site links~~
- [x] push cglib mockmaker to a separate jar #248
- [x] stop using ant for producing OSGi bundles. No more ant in the build #249
- [x] remove jars from source distribution #250
- ~~perhaps introduce is() matcher~~ #246
- ~~richer and smarter stubbing~~ #303
- ~~support java8 features for capturing arguments and matchers~~
- [x] make the JUnitRule and the runner verbose
- [x] ensure release notes can be neatly generated for the RC #582

Possibly compatible (and hence, could be released pre-2.0 if needed)
- [x] drop deprecated code
- [x] unincubate API
- ~~drop serialVersionUID~~""Is it still planned for 2.0 to give users an option to use an alternative to cglib (like Byte Buddy)?
 =||= This kind of feature can be added any time (e.g. it's not a backwards-incompatible change). It's just someone needs to implement it :) 

So short answer is 'no', it's not planned for 2.0 (but I would love to have this feature soon)
 =||= If possible I would really like to replace CGLIB by bytebuddy.

I wanted to craft an external MockMaker but I'm way too much overwhelmed at the moment. The code exists in my clone though.
 =||= @bric3, you mean that you're keen on changing default proxy mechanism in 2.0? I'm fine with this :) I do want to publish 2.0 this year though and I won't be very active it this part of the code. So, if you make it, it can be included :)
 =||= @szczepiq You mean by the end of 2014 ?

What I hoped was to build a mockmaker that could be tested on the 1.x. But the code may replace CGLIB now if necessary. Beta have to be tested by other people though, I especially think about uncommon environment like OSGI, etc...
 =||= 1>You mean by the end of 2014 ?

haha, yeah ;)

> What I hoped was to build a mockmaker that could be tested on the 1.x.

Like an opt-in feature for 1.x?

I definitely think that given we have the bytebuddy impl of MockMaker, we
should make it conveniently pluggable instead of just replacing cglib
completely. You mentioned earlier that you had the ByteBuddy MockMaker
working with Mockito test suite?

Cheers!

On Mon, Nov 24, 2014 at 4:18 PM, Brice Dutheil notifications@github.com
wrote:

> You mean by the end of 2014 ?
> 
> What I hoped was to build a mockmaker that could be tested on the 1.x. But
> the code may replace CGLIB now if necessary. Beta have to be tested by
> other people though, I especially think about uncommon environment like
> OSGI, etc...
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-64208043.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= > > What I hoped was to build a mockmaker that could be tested on the 1.x.
> 
> Like an opt-in feature for 1.x?

Yes. But, meanwhile replacing CGLIB in mockito 2.0.

> You mentioned earlier that you had the ByteBuddy MockMaker working with Mockito test suite?

Yes it does. I just would like to ensure it works with uncommon environment like OSGI.
 =||= Do you think it is worthwhile to keep support for cglib once we have
bytebuddy?

Do you think we should shade bytebuddy? What dependencies bytebuddy brings?

On Mon, Nov 24, 2014 at 6:26 PM, Brice Dutheil notifications@github.com
wrote:

>  What I hoped was to build a mockmaker that could be tested on the 1.x.
> Like an opt-in feature for 1.x?
> 
>  Yes. But, meanwhile replacing CGLIB in mockito 2.0.
> 
> You mentioned earlier that you had the ByteBuddy MockMaker working with
> Mockito test suite?
> 
> Yes it does. I just would like to ensure it works with uncommon
> environment like OSGI.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-64229927.

## 

Szczepan Faber
Core dev@gradle; Founder@mockito
 =||= No I don't think it is necessary, however we can make a CGLIB mock maker, for people that may depend on it.
 =||= I am curious: Do you guys have a time-line for the 2.0 release? I am more than happy to support any code-generation releated issues. However, my vacation is approaching so I will be gone for a couple of weeks starting mid-August.

In particular, I wonder you guys wanted to try integrating Byte Buddy 0.7 with support for generic type retention already in 2.0 which I hope to complete before my vacation. One word of warning: Generic types are awefully complex. Byte Buddy needs to parse stringified type information and resolve the full type hierarchy, i.e. bind type variables of super types / interfaces to their actual values in order to appropriately resolve a type variable's value while dealing with the possibility of raw types and potentially illegally formatted generic types (the JVM does not verify generic type infromation which simply exists as meta data). There is a chance for corner case errors even though I isolated the functionality pretty much to fall back to type erasure if any illegal type information is disovered. At the same time, mocks would behave better when a generic type is read by a class processing a mock.
 =||= It must happen in 2015. I hope we are ready in the next few months. In
theory, there's not much left work :)

Cheers!

On Fri, Jul 10, 2015 at 5:31 AM, Rafael Winterhalter <
notifications@github.com> wrote:

> I am curious: Do you guys have a time-line for the 2.0 release? I am more
> than happy to support any code-generation releated issues. However, my
> vacation is approaching so I will be gone for a couple of weeks starting
> mid-August.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-120399539.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= I think mockito 2.0 is nearly in shape to be released, most work should go in polishing remaining bits of the public API. IMHO current byte buddy version is fine, and already provide subtitle but needed enhancements.

More specifically on generics I believe current support is OK, after all mockito is a TDD tool for a rapid feedback loop, both on the dev workstation and the ci bots. I believe current generics support in the deepstubs answer is enough. About the issue you mention the support class I wrote is probably incomplete but enough, and I agree parsing this metadata is hard. Anyway at the moment if any extended support should be provided on this front it should be provided via a mockmaker plugin.
 =||= Thanks for the info. I just released Byte Buddy 0.7 but I recommend you to not yet update. Generic types are tricky and I already found a corner case in the bridge method resolution that does not work. I'll try to make it stable until the mid of August, though.
 =||= Any guess on when 2.0 will be released?
 =||= It's been silent for past couple of months, everybody busy, etc. Since
yesterday, I'm focusing my spare time on Mockito. I will not stop until 2.0
is out. We cannot guarantee any dates but 2.0 must be released in 2015.

On Sat, Sep 19, 2015 at 8:40 AM, David J. M. Karlsen <
notifications@github.com> wrote:

> Any guess on when 2.0 will be released?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-141681244.

## 

Szczepan Faber
Founder mockito.org; Core dev gradle.org
tweets as @szczepiq; blogs at blog.mockito.org
 =||= Any updates on when we might see a 2.0 release?
 =||= 2015 is soon over ;) At some point, we need to do a cut in features. I think everybody is quite budy right now. As always, the time before Christmas are busy month for consultant work.
 =||= Soon. This year for sure. Sorry I was distracted! We will probably deliver
2.0 with what we have, no new fancy features ;)
On Nov 10, 2015 4:52 AM, ""Rafael Winterhalter"" notifications@github.com
wrote:

> 2015 is soon over ;) At some point, we need to do a cut in features. I
> think everybody is quite budy right now. As always, the time before
> Christmas are busy month for consultant work.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-155412454.
 =||= Can this task https://github.com/mockito/mockito/issues/300 be included in 2.0 release?
 =||= Feel free to add #374 to the todo list
 =||= 2.0  is coming so slow.
 =||= It's way too slow. I'm on it. Thank you guys for pushing.
 =||= @szczepiq How can we/the community support the mockito core team ?
 =||= > @szczepiq https://github.com/szczepiq How can we/the community support
> the mockito core team ?
> 
> You already are. You guys are great. Thank you for patience and pushing us
> to deliver.

The lagging of beta is my fault. I've started the beta cycle and I should
have completed it. I'm back in the game, though.

Once 2.x final is out we need clarify how community can drive supporting
and maintaining Mockito.

Note that Mockito is continuously delivered so you can open PR to change
the version to ""2.1.0"", and that's it :)

Cheers!

> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-206757516
 =||= @szczepiq I left a pull request for removing deprecated code which is an 2.0 milestone issue - can you pull it/looks good?
 =||= I haven't reviewed yet. THANKS!
On Sun, Apr 10, 2016 at 03:12 David J. M. Karlsen notifications@github.com
wrote:

> @szczepiq https://github.com/szczepiq I left a pull request for
> removing deprecated code which is an 2.0 milestone issue - can you pull
> it/looks good?
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly or view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-207953253
 =||= Per Mockito developers discussion:

We want to target publishing the release on July 31st with a release candidate on June 30th.

There is one issue which must be resolved for that, which is #194. Other than that I just found 1 minor TODO [in the Mockito documentation](https://github.com/mockito/mockito/blob/dff5510cb3e97dae414e58ba85825ad01b273c72/src/main/java/org/mockito/Mockito.java#L1091). The other issues can be fixed in a later minor version.
 =||= @TimvdLippe  what about https://github.com/mockito/mockito/issues/300?
 =||= @skabashnyuk I think that we still want to do this, but is not a blocker for the release. We must do it when we have time, but it is okay in my opinion to release it in a later minor version. I have to be honest that I was not participating in the original discussion so I do not know the exact details. @bric3 is the man to talk to :)
 =||= @TimvdLippe @skabashnyuk Humm I think we should really focus energy on mockito 2, TestNG could come later.
 =||= > TestNG could come later.

@bric3 No problem. But why this can't be done in parallel? Code is ready, looks like this is an infrastructure-deployment issue. Or you are planning to do something bigger than just deploy artifacts?
 =||= @skabashnyuk Currently we are focused on releasing Mockito 2.0. This leaves little to no time for other issues sadly. If you are able to configure the deployment, we are happy to accept your pull request! We can devote some of our time to the TestNG issue after we have released Mockito 2.0.
 =||= Some update.

We're not ready for the release but there's good momentum. Let's plan out
what else needs to be done (announcement information, really documentation
around why to upgrade and how, solid plan what's next after the release
candidate, etc.).

I'm confident the RC will be out in August. I plan to announce everywhere
that we plan RB in August. If we don't meet the date there will high degree
of shame ;) Thoughts?

On Sat, Jun 25, 2016 at 3:59 AM, Tim van der Lippe <notifications@github.com

> wrote:
> 
> @skabashnyuk https://github.com/skabashnyuk Currently we are focused on
> releasing Mockito 2.0. This leaves little to no time for other issues
> sadly. If you are able to configure the deployment, we are happy to accept
> your pull request! We can devote some of our time to the TestNG issue after
> we have released Mockito 2.0.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/123#issuecomment-228532419,
> or mute the thread
> https://github.com/notifications/unsubscribe/AABgp8m2jG-9Rj7USJ1V2s6GJNHLzbdwks5qPQodgaJpZM4C_fdm
> .

## 

Szczepan Faber
Founder @ mockito.org | Twitter @ szczepiq
Author @ https://www.linkedin.com/today/author/6016386
 =||= I think most of the work should be focused on the upgrade guide, there's not much left for 2.0, follow up tasks can be completed in 2.1
 =||= I think we can publish the release candidate while working on the actual upgrade guide (state this in the github release for users to follow). The only two issues that are non-documentation are #384 with PR #527 of @szczepiq and #489 with PR #491 of myself. #527 has some feedback to be processed and #491 is more of a discussion regarding the runner.

Once these two are resolved, we can merge #483 and the release candidate is published :tada: 

For an up-to-date status, see https://waffle.io/mockito/mockito and https://github.com/mockito/mockito/milestone/1
 =||= This is great stuff!!! Thanks a lot Tim for pushing the release forward & organizing it so well.

I'm making good progress on the warnings stuff for JUnit rule and the listener - will update the PR very soon.
 =||= I'm confused why this ticket is closed. I don't see 2.0 in maven central :)
 =||= @szczepiq because this issue was referenced in #483 which I just merged
 =||= ah, GH smartness :)
 =||= As promised here’s suggested plan to get 2.0 out. Please give feedback, sing up for tasks and commit to ETA so that we get 2.0 out :)

Step 1:
- [ ] prepare RC release notes + announcement (highlights, motivation, request for feedback) - #582
- [ ] review and update documentation for 2.0.0 - #596
- [ ] ensure & test manual Mockito releases - #586
- [ ] update CI / build scripts (releasing betas from branch, etc) - #594

Step 2:
- [ ] branch out / fixes to release / Travis - #594

Step 3:
- [ ] pull the trigger for RC!!!!!, close darn #123 !!!!!!
 =||= ![image](https://cloud.githubusercontent.com/assets/5948271/18092170/97fac1ca-6ecb-11e6-83e0-fd2953833359.png)
 =||= I think we have updated all relevant documentation. @bric3 once you branch out to `release/2.x` we can publish the release candidate :tada: 
 =||= I went ahead and published the release candidate. You can download `2.1.0-RC.1` at https://bintray.com/szczepiq/maven/mockito/2.1.0-RC.1#
 =||= By the way I would prefer to have mockito account on bintray 
 =||= Yes agreed. Let's extract a separate issue for that.
 =||= Mockito 2.1.0 has been released, upgrade today :tada: 
 =||= "Update version scheme to publish release candidate"Beta releases now follow the official semver scheme of `MAJOR.MINOR.PATCH-beta.BETAVERSION`. This PR also updates the current version to a release candidate.

We should decide after the release candiate what the version of Mockito 2.0 should be. E.g. should it be `2.0.0`? That would mean we go down on our `PATCH` number which might confuses people. For the Mockito 3.0 beta is to set the version to `3.0.0-beta.BETAVERSION` to not confuse with the `PATCH` number, but it still leaves us with the question regarding the official release of Mockito 2.0 :cry: 

Closes #123 "Tim van der LippeTimvdLippe08/23/16, 04:34:57 PM
489.0491Remove Whitebox classThe original question stems from #422 where additional changes were requested. This class seems to stimulate bad testing practices. Mockito only uses this class in [JUnitFailureHacker](https://github.com/mockito/mockito/blob/196ff979da156caa07e19f57e4849637d8bede1a/src/main/java/org/mockito/internal/util/junit/JUnitFailureHacker.java) which consequently is only used in [VerboseMockitoJUnitRunner](https://github.com/mockito/mockito/blob/196ff979da156caa07e19f57e4849637d8bede1a/src/main/java/org/mockito/runners/VerboseMockitoJUnitRunner.java). Given the nature of this class and only 1 usage in the library, I think we should remove it to prevent users from obtaining bad testing habits."Oh yeah - please do :P
 =||= Usages on GitHub code derived with Google BigQuery: https://bigquery.cloud.google.com/results/eco-silicon-124112:bquijob_30e42d3_155cf5a5f13?pli=1

``` sql
SELECT
  cont.sample_repo_name,
  repo.watch_count
FROM
  [fh-bigquery:github_extracts.contents_java_2016] as cont
JOIN [bigquery-public-data:github_repos.sample_repos] as repo
  ON cont.sample_repo_name = repo.repo_name  
WHERE
  cont.content CONTAINS 'import org.mockito.internal.util.reflection.Whitebox'
GROUP BY cont.sample_repo_name, repo.watch_count
ORDER BY repo.watch_count DESC
LIMIT
  500;
```

Most of the repositories seem to rely on PowerMock instead, which already has a different Whitebox class defined. Therefore I think it is safe to say we can deprecate and remove the class and those users who are explicitly relying on the behavior are likely users of PowerMock too.
 =||= Yes go on.
 =||= Thanks for removing this class. It's an internal class. People should never depend it. If they did, they need handle the problem ;)
 =||= "Deprecate whitebox and corresponding verboserunner and junitfailureha…"A quick google showed that there are almost zero usages of this runner. Moreover it was relying on a very hackish implementation. I think we can do a better job by creating a new runner with JUnit 5 as part of #390. Therefore the intent is to deprecate these classes and remove them in Mockito 3.0.

Fixes #489"Tim van der LippeTimvdLippe08/16/16, 08:22:36 AM
482.0492Restore depecated Answers.get() method"Commit da5e750957b494e7fa0548bf1286d67b8b0386d5 removed the deprecated `Answers.get()` method, however the method was only deprecated in the 2.0 BETA line and never made it into a GA release. It would be helpful if the method could remain in the deprecated form in 2.0 to give people an opportunity to move away from it.

(originally raise by a Spring Boot user [here](https://github.com/spring-projects/spring-boot/pull/6323))""On a related note adding a ""as of"" to the deprecated description would also be useful:

``` java
/**
 * @deprecated as of 2.0 in favor of using the enum-constant directly. This method will be removed in a future release<br> 
 * E.g. instead of <code>Answers.CALLS_REAL_METHODS.get()</code> use <code>Answers.CALLS_REAL_METHODS</code> .
 */
```
 =||= I would agree with @philwebb that this method had been made deprecated in 2.0 (-beta.2) not in 1.10.x (in fact at first it was [removed](https://github.com/mockito/mockito/commit/34f4436d988f04eaf7635b0497067ee8df7971a6) completely and one month later [restored](https://github.com/mockito/mockito/commit/32dce3ea56fb2891b54be48c16a13d2a9eb0cd33) as deprecated), but what is more important `Answers` started implementing `Answer` then. Because of that when I was fixing that issue in Spring Boot it was hard to keep code compatible with both versions at runtime (for 1.x casting using it as Answer does not work, for never 2.x `get()` is not available). In the end I had to [do](https://github.com/spring-projects/spring-boot/pull/6323/files) ugly casting through `Object` to fool the compiler. With that Spring Boot should work fine (at least with changes related to `Answers` :) ), but there could be other tools (PowerMock?) that after removing this method cannot be easily compatible with both Mockito 1.x and 2.x. IMHO it would be good to keep this method in 2.x and remove in 3.x.
 =||= Yes that seems like a good idea. Mind want to open a pull request?
 =||= ""Revert ""Remove deprecated method""""Simple git revert for an accidental removal of a deprecated api since 2.0 instead of 1.X.

Fixes #482."Tim van der LippeTimvdLippe07/11/16, 01:16:45 PM
465.0493Delivery drone breaks codecov"Since the commits of the delivery drone have `[ci skip]`, there is no coverage report for that specific commit. As a result, when a pull request has as base such a commit, CodeCov reports that it could not generate a coverage report.

Maybe we can depend executing `gradle release` if the commit is from a user other than the delivery drone, to not break codecov."Code cov on releases"Releases are now triggering CI builds to generate the code coverage reports.
An example of a normal build can be found at https://travis-ci.org/mockito/mockito/builds/143765346#L334-L374
An example of a build ignored as the commit message contained `[ci skip-release]` can be found at https://travis-ci.org/mockito/mockito/builds/143765834#L311-L314

Fixes #465"Tim van der LippeTimvdLippe08/07/16, 09:04:50 AM
401.0499JUnit runner detects unused stubs"It is useful to know that stubbing in the test was not used. Perhaps the stubbing is not needed? Removal of unnecessary code from the test is important for code clarity.

More details:
- we detect unused stubs only for passing tests (adding different failure to an existing failure could be confusing)
- need to have something similar for JUnit rules (will create separate ticket)
- stubbing in @Before or class constructor should be used in at least one test
- stubbing in test needs to be used in that test""The current impl is not thread safe. Reopening.
 =||= "Fixes #401 - makes the JUnit runner detect unused stubs"Fixes #401

This is a breaking change because JUnit runner will now fail the test class if there is an unused stubbing.

Feedback is welcome. Sorry for working on it for a long time and big number of commits."Szczepan Fabermockitoguy07/24/16, 04:46:12 PM
506.0507Improved exception message for wanted but not invoked"Currently, Mockito prints following message when specific verification fails:

```
Wanted but not invoked:
mock.simpleMethod();
-> at ....

However, there were other interactions with this mock:
mock.otherMethod();
-> at ....
mock.booleanReturningMethod();
-> at ....
```

It would be useful to print the number of invocations:

```
Wanted but not invoked:
mock.simpleMethod();
-> at ....

However, there were exactly 2 interactions with this mock:
mock.otherMethod();
-> at ....
mock.booleanReturningMethod();
-> at ....
```"Improved exception message - fixes issue 506Fixes #506 Szczepan Fabermockitoguy07/25/16, 05:31:06 PM
497.0549DEEP_STUBS tries to mock final class"```
    <dependency>
        <groupId>org.mockito</groupId>
        <artifactId>mockito-core</artifactId>
        <version>1.10.19</version>
        <scope>test</scope>
    </dependency>
```

```
$ java -version
java version ""1.8.0_91""
Java(TM) SE Runtime Environment (build 1.8.0_91-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.91-b14, mixed mode)
```

```
import static org.junit.Assert.assertNull;
import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
import static org.mockito.Mockito.mock;

import org.junit.Test;

public class MockitoBug {
  public interface Supplier<T> {
    public T get();
  }

  public interface StringSupplier extends Supplier<String> {}

  public interface InheritedSupplier extends StringSupplier {}

  @Test
  public void deepStubs() {
    StringSupplier mock = mock(StringSupplier.class, RETURNS_DEEP_STUBS);
    String s = mock.get();
    assertNull(s);
  }

  @Test
  public void inheritedDeepStubs() {
    InheritedSupplier mock = mock(InheritedSupplier.class, RETURNS_DEEP_STUBS);
    String s = mock.get();  // ClassCastException
    assertNull(s);
  }
}
```

```
java.lang.ClassCastException: org.mockito.internal.creation.cglib.ClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$322ebf6e cannot be cast to java.lang.String
    at MockitoBug.inheritedDeepStubs(MockitoBug.java:26)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
```

I expect the behavior for `StringSupplier` and `InheritedSupplier` to be the same: return `null` for `get`. However, `InheritedSupplier` tries to return a mock `Object` for `get`.""I have a hacky workaround using Guava's `TypeToken`:

```
  private static final MockUtil mockUtil = new MockUtil();

  @SuppressWarnings(""unchecked"")
  private static <T> T createSmartDeepMock(TypeToken<T> mockType) {
    return (T) mock(mockType.getRawType(), createSmartDeepMockAnswer(mockType));
  }

  private static Answer<?> createSmartDeepMockAnswer(TypeToken<?> mockType) {
    Map<Method, Object> mocks = new LinkedHashMap<>();

    return invocation -> {
      Method method = invocation.getMethod();
      if (mocks.containsKey(method)) {
        return mocks.get(method);
      }

      Type returnType = method.getGenericReturnType();
      TypeToken<?> resolvedReturnType = mockType.resolveType(returnType);
      Class<?> returnClass = resolvedReturnType.getRawType();

      if (!mockUtil.isTypeMockable(returnClass)) {
        return Mockito.RETURNS_DEFAULTS.answer(invocation);
      } else {
        Object mock = createSmartDeepMock(resolvedReturnType);
        mocks.put(method, mock);
        return mock;
      }
    };
  }
```
 =||= "Fully register a class ancestry for GenericMetadataSupport"The old implemention would take a class X and consider all of its superclasses
and the interfaces implemented by X and the interfaces implemented by all of
its superclasses.

The new implementation also considers the superinterfaces of the interfaces
implemented by X and the superinterfaces of the interfaces implemented by its
superclasses.

Fixes #497"Jeffrey FalgoutJeffreyFalgout08/15/16, 03:53:18 PM
538.0550Improve error message when @InjectMocks is uses on an interface or enum field"By accident a tests delares a field of an interface type instead of the implementing class.  

```
@InjectMocks
public InterfaceType unitUnderTest;
```

Injection is not possible on interfaces or enums. The error message should make this clear, the currenta message that doesn't help much:

```
org.mockito.exceptions.base.MockitoException: 
Cannot instantiate @InjectMocks field named 'configurationManager'.
You haven't provided the instance at field declaration so I tried to construct the instance.
However, I failed because: the type 'ConfigurationManager' is an interface.
Examples of correct usage of @InjectMocks:
   @InjectMocks Service service = new Service();
   @InjectMocks Service service;
   //also, don't forget about MockitoAnnotations.initMocks();
   //and... don't forget about some @Mocks for injection :)
```

The error message should be someting like:
`The field 'unitUnderTest' can not be annotated with @InjectMocks cause the type 'InterfaceType ' not a class!
`"Fixed #538 changed error message in case initialization for mock injection fails."Fixed #538

If a filed is annotated with @InjectMocks and the type of a field is an enum, inner class, interface or local class the error message is now: _""Mock injection failed on field 'fieldName' cause the type 'AbstractCollection' is an abstract class._"""Christian SchwarzChristianSchwarz08/15/16, 01:22:45 PM
551.0556Unexpected new public API: VerificationWrapper, VerificationWrapperInOrder, VerificationCollectorImpl"It looks like some classes leaked to the public API: VerificationWrapper, VerificationWrapperInOrder, VerificationCollectorImpl

They seem like internal classes because:
a) they are concrete implementation where public API should be an interface
b) no javadoc
c) looking at their API, they don't seem like something we want to expose to the users :)

We need to fix it before 2.0, perhaps it's just the matter of moving it to internal packages.""`VerificationCollectorImpl` is package-protected and is not generated in the Javadoc either: http://site.mockito.org/mockito/docs/current/org/mockito/junit/package-summary.html

The other `VerificationWrapper`s can be package-protected too.
 =||= This is a good point!

I suggest we move it to internal package anyway. This way:
- it is consistent how we manage public / private API
- it can be used more easily by devs who experiment / hack (e.g. they know what they are doing when using private API :)
- it is less error prone (e.g. when someone forgets to remove 'public' or when someone adds 'public' not realizing consequences)
 =||= "Move Mockito internal classes to internal packageFixes #551Tim van der LippeTimvdLippe08/15/16, 03:53:32 PM
533.0557Remove code.google.com from javadocLooks like the javadoc still has some references to code.google.com, let's replace them with up to date links.Replace or remove code.google.com links in documentation"Most links are replaced by their GitHub equivalent. Some links were pointing to issues on code.google.com, but given the large amount of documentation on these methods I decided to remove them.

Fixes #533"Tim van der LippeTimvdLippe08/15/16, 03:44:47 PM
332.0568Finalize Mockito Runners"Currently, we have a couple of Mockito Runners that are a part of public API but they are largely unknown:
- ConsoleSpammingMockitoJUnitRunner
- VerboseMockitoJUnitRunner

They attempt to improve the testing / TDD experience by adding warnings for following scenarios:
     - a) unused stubbing
     - b) stubbed method called with different args (and a special variant of a)

Example of a warning:

---

 **\* Stubbing warnings from Mockito: ***

stubbed with those args here   -> at org.mockitousage.junitrunner.ModellingVerb
BUT called with different args -> at org.mockitousage.junitrunner.ModellingVerboseMockitoTest.shouldLogUnusedS
This stubbing was never used   -> at org.mockitousage.junitrunner.ModellingVerboseMockitoTest.shouldLogUnusedStubbingWarning
This stubbing was never used   -> at org.mockitousage.junitrunner.ModellingVerboseMockitoTest.shouldLogUnusedStubbingWarningWh

---

The rationale is explained in the javadoc of the above runners. In 2.0 let’s include stubbing warnings in the default behavior of JUnit rule and the default runner.

Challenges that need thinking through:
- feature parity with JUnit rule
- clean API so that the warning system can be integrated with other runners
- some API to get hold of those warnings programmatically
- feature toggle
  - disable completely
  - disable by test / test class / stubbing?
- how can this be tested?""> how can this be tested?

Using `JUnitCore`, there's already a few tests that uses it.

> - feature toggle
>   - disable completely
>   - disable by test / test class / stubbing?

Using the plugin switch functionality ?
Note there's some idea in the pull request to toggle stuff per test / test class. However I don't feel this is mature enough to be integrated, in mockito yet.

In my opinion the `Rule` is the the right place to configure mockito per test.
 =||= "Ensured that MockitoJUnitRunner is thread safe wrt unused stubs detection"This PR concludes #401 Yay!!!!

Highlights:
- fixed the thread safety problem by leveraging the same API that JUnit rules used for hinting at unused stubs
- removed StubbingListener API (it could not work to the thread safety levels we support in Mockito, see also #545)

Closes #332
Fixes #401"Szczepan Fabermockitoguy08/21/16, 11:43:09 PM
541.0569improve Mockito.mockingDetails API"In order to make the API cleaner & expose useful information:
1. MockingDetails.getInvocations() throws meaningful exception when passed object is not a mock and documents this behavior
2. getMockedType() and getExtraInterfaces() are replaced with getMockCreationSettings() that returns MockCreationSettings instance.""OK but let's deprecate them instead of removing them (possibly in mockito 3).
 =||= Given that getMockedType() and getExtraInterfaces() are unreleased yet (e.g. 2.0), do you still opt for deprecation?
 =||= good point, let's remove them then !
 =||= "Improved the public API of MockingDetails"Fixes #541, highlights:
- started exposing full mock creation information instead of just type to mock and extra interfaces
- changed public API but only for methods that were introduced in 2.x. So it is _not_ backwards incompatible change as far as 1.10 is concerned."Szczepan Fabermockitoguy08/21/16, 03:27:05 PM
564.0576Publish Mockito build results to Gradle Build ScansLet's start publishing Mockito build results to Gradle Build Scans. This way we have extra intel about Gradle builds. This also helps friends at Gradle as they will have more projects on board!Bumped Gradle and enabled Build Scans"- Fixes #564 
- Bumped Gradle to latest 2.\* (regenerated Gradle wrapper)
- Added build scans support
- Removed TODO I decided to not work on (fixes #544)"Szczepan Fabermockitoguy08/21/16, 03:35:46 PM
544.0576improve stubbing warnings formattingFollow up after #384, let's get the stubbing warnings look good in case there are many instances to report (text padding)."@bric3 suggested:

String.format(""%4d. %s %s %n"", x++, "". Unused... "", m.getKey().getLocation())
4 is hard coded here, but that would work up to 9999 hint. It's still possible to compute that value if hard coded value don't work.
 =||= I tested it out with lots of unstubbed calls and the current behavior is completely acceptable. Is not completely aligned but it is still decent. I'm not fixing this cosmetic issue.
 =||= "Bumped Gradle and enabled Build Scans"- Fixes #564 
- Bumped Gradle to latest 2.\* (regenerated Gradle wrapper)
- Added build scans support
- Removed TODO I decided to not work on (fixes #544)"Szczepan Fabermockitoguy08/21/16, 03:35:46 PM
552.0589Fix again javadoc stylesheet"Previously we had a nice javadoc stylesheet. That worked well with JDK6.
Then we used travis that was only allowing OracleJDK7, that came with a better javadoc stylesheet so we dropped ours.

Now since the release of mockito 2.x is using openjdk6, we should reintroduce a better stylesheet.

Current state ❌ 
http://site.mockito.org/mockito/docs/2.0.100-beta/org/mockito/Mockito.html
<img width=""712"" alt=""screen shot 2016-08-13 at 19 41 59"" src=""https://cloud.githubusercontent.com/assets/803621/17644719/cecc5ec4-618e-11e6-912e-9b0dcd7e94db.png"">

Previous ✅ 
http://site.mockito.org/mockito/docs/2.0.0-beta/org/mockito/Mockito.html
<img width=""877"" alt=""screen shot 2016-08-13 at 19 45 32"" src=""https://cloud.githubusercontent.com/assets/803621/17644722/d71bcd08-618e-11e6-831a-a01c47e8cc61.png"">""Is this as simple as turning back on this line? https://github.com/mockito/mockito/blob/b0393eafeeb81b6c75e40a82b81672543777ca9a/gradle/javadoc.gradle#L55
 =||= Probably but I need to check before. The file may have been removed. And the javadoc tool is _picky_ especially in old version of the JDK.
 =||= Actually we should revert this commit 3a057b3eff2be528a1fed41852a990cff87a72c1, when JDK7 was the only option on travis
 =||= It seems the javadoc tool of openjdk6 generates a different HTML than Sun JDK 6. Thus the stylesheet is not working properly.

<img width=""748"" alt=""screen shot 2016-08-24 at 11 56 56"" src=""https://cloud.githubusercontent.com/assets/803621/17926642/35b9d2cc-69f2-11e6-9614-61648cafeb18.png"">

Yet again an issue with OpenJDK6...
 =||= "Reintroduces javadoc stylesheet"Fixes #552

Since artifacts are built with openjdk6, we can reintroduce a good looking javadoc stylesheet."Brice Dutheilbric308/23/16, 06:04:06 PM
593.0597Mockito Javadoc has a TODO about hamcrest"``` java
 * TODO rework the documentation, write about hamcrest.
 *
 */
@SuppressWarnings(""unchecked"")
public class Mockito extends ArgumentMatchers {
```

https://github.com/bric3/mockito/blob/18133aa0cb5b51c0472fb8b33ab0a22aa9f0fbf3/src/main/java/org/mockito/Mockito.java#L1207-L1207

Let's remove it or fix it.""On it. Thanks!
 =||= "Removed TODO and dead code"- Sweeped through all TODOs, found some dead code to remove
- Hamcrest docs looks good overall, TODO is obsolete
- Updated javadoc for deprecated Mockito.debug()

Fixes #593 "Szczepan Fabermockitoguy08/25/16, 06:56:53 AM
603.0604Release notes group improvements by labels"For clearer release notes overlook we should group improvements by labels. 

This was originally contributed by @szpak, then lost during the early days of continuous integration, now it's back and it will rock!!!"Release notes group improvements by labels"Fixes #603 

I will generate a demo release notes and check-in to some throw-away branch.

Here's a demo of generated release notes. Note that final notes will have some manual edits (some narrative, announcement, etc.): https://github.com/mockito/mockito/blob/rc-release-notes-demo/doc/release-notes/official.md

IMHO the current level of automation of release notes is enough :) It's time to work on the announcement, etc. In the process we can tweak the labels on tickets so that generation is more accurate."Szczepan Fabermockitoguy08/28/16, 02:04:39 PM
614.0617AdditionalAnswers.answer family leaks internal classes"`AdditionalAnswers.answer` family leaks the internal `AnswerFunctionalInterfaces`, I believe these _arity_ interfaces should be public, either in the package `org.mockito.stubbing` or within `org.mockito.stubbing.Answer`

```
public static <T, A, B> Answer<T> answer(AnswerFunctionalInterfaces.Answer1<T, A> answer)
public static <A, B> Answer<Void> answerVoid(AnswerFunctionalInterfaces.VoidAnswer1<A> answer) {
public static <T, A, B> Answer<T> answer(AnswerFunctionalInterfaces.Answer2<T, A, B> answer) {
...
```""Good catch!
 =||= "Moves arity interfaces of java8 helper answers to public API"The Java 8 helper interfaces have been introduced in #338. However the public `AdditionalAnswers.answer` family leak the functional interfaces.

These _parameter arity_ interfaces can be public, hence they are moved next to `Answer` in the `org.mockito.stubbing` package.

I'm however in favor of adding the `@Incubating` annotation on those APIs and related objects. Thoughts ?

Fixes #614"Brice Dutheilbric309/01/16, 01:00:22 PM
594.0627Make the build script aware of the release branch"Releasing from the `master` branch has advantages developer wise, however when users that are hit by a bug and that `master` has significantly changed we cannot propose a stable enough release (example 2.0 betas releases, even the 1.10.x series had some instabilities API wise).

In order to enable the team and contributors in general to fix issues while still allowing bigger work on the next version I propose the following change in branch and release _process_.
1. Branch out to `release/2.x`
   1. Release `2.0.0`
   2. Patch issue
   3. Release `2.0.1`
   4. Additional work on 2.1
   5. Release `2.1.0`
   6. ...
   7. Forget about `2.1.x`
   8. Critical fixes only get released
2. Upgrade `master` to `3.0.0-beta-<build number>`
   1. Start mockito `3.0.0` progress there (like java 8 only, drop APIs)

Also with recent change in the build script we could now release and check the release version with the branch.

See 
- https://github.com/mockito/mockito/commit/b6a402f16e9222605638efe9b57eccc80a197f9e#diff-33cf41d9669aaef72ca19c641dc57d47R68
- https://github.com/mockito/mockito/issues/586#issuecomment-242076979
- https://github.com/mockito/mockito/pull/483#issuecomment-231323266""@bric3, this is great. Thank you for finally describing the workflow!!!
 =||= ~~I'll try to work on this this week. Yet this ticket is not mandatory for releasing (hence no milestone assignment).~~

EDIT in the end I couldn't find time this week fo this
 =||= The plan makes perfect sense. Let's zoom into implementation details. For example:
1. Create 2 active branches: ""master"" and ""release""
2. Set version.properties in ""master"" to 3.0.0-beta.1, automatically publish per push
3. Set version.properties in ""release"" to 2.1.0-rc.1, automatically publish per push (?)
   a. At some point change version.properties in ""release"" to ""2.1.0"", automatically publish per push

I know that travis can now get version from commit message. How would this work for keeping 2 active branches / publishing RCs?
 =||= If you want to publish a RC for the v2 branch, you checkout that branch, then commit with `Prepare release candidate [ci-release v2.1.0-RC.1]` on that branch and it should be good to go.
 =||= I'd rather go for a branch out model like described in https://github.com/mockito/mockito/issues/594#issue-172969427, so we (and interested parties) can still release a important patch for an old mockito version.
 =||= @szczepiq I'm waiting on the release note of #582 to branch out to `release/2.x`
 =||= That should be working fine right? With the versionproperties separate in each branch (and the manual releases).
 =||= Yes, but not with a single `release` branch.

> 1. Create 2 active branches: ""master"" and ""release""
 =||= Oh sorry, I misread that. Yes we must have a release branch for every major semver version. Reading is hard sometimes :stuck_out_tongue_winking_eye: So +1 for me for @bric3 model, which I also was trying to describe.
 =||= When do we use magic incantation in the commit message and when not?

There is an approach with fully automated releases:
1. Create ""v2"" branch (or something like that), that still publishes Beta.
2. Test it out, so that Beta is neatly released from ""v2"".
3. Change version in ""v2"" into RC, remove top of the release notes, push.
4. Iterate on the fixes, every push creates new RC.
5. At some point, change version to ""2.1.0"", push.
6. Any push to ""v2"" publishes new 2.1.*

For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking v2 release, we can do it later.

Awesome, I'm getting excited, we'll have RC before JavaOne! :)
 =||= > Any push to ""v2"" publishes new 2.1.*

I would instead have the drone only push betas. E.g. 2.1.1-beta.*.

On Thu, 1 Sep 2016, 07:18 Szczepan Faber, notifications@github.com wrote:

> When do we use magic incantation in the commit message and when not?
> 
> There is an approach with fully automated releases:
> 1. Create ""v2"" branch (or something like that), that still publishes
>    Beta.
> 2. Test it out, so that Beta is neatly released from ""v2"".
> 3. Change version in ""v2"" into RC, remove top of the release notes,
>    push.
> 4. Iterate on the fixes, every push creates new RC.
> 5. At some point, change version to ""2.1.0"", push.
> 6. Any push to ""v2"" publishes new 2.1.*
> 
> For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to
> split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking
> v2 release, we can do it later.
> 
> Awesome, I'm getting excited, we'll have RC before JavaOne! :)
> 
> —
> You are receiving this because you commented.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/mockito/mockito/issues/594#issuecomment-243978550,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AFrDbxJRdQ7Q3PHv8p0kxCZveqCVpp9Fks5qlmA6gaJpZM4JsE40
> .
 =||= No more betas please :) Continuous delivery is signature feature of Mockito project.
 =||= While that is true, for every pull request we would release a new patch version. I am not a fan of that. Preferably update less, but more meaningful for the end-user. If you are continuously producing new non-beta artifacts, I think end-users tend to wait with upgrading instead. It's sad that gradle/maven can't import from master instead, but I think we should try to keep our semver versions clean.
 =||= This is an old debate, that we had on the mailing list a couple of years ago.

@szczepiq I know you are an advocate of each commit can be a release, I heard about your talk. This is really nice pushing forward for continuous delivery however I don't agree that every single commit should be released especially on libraries. For some projects it maybe ok, but for some I'd be more conservative.

For example 1.10.x series was nice but felt less stable to many users. Some merged PR introduced the Mockito rule and the API had to be changed. Some incorrect behavior had to be fixed, some were fixed later in the beta. I'm not sure this builds trust in the library.

Also with this big changes cannot fit in your model : should we have released in between PR of the JUnit feature, after all there was enough interesting and working features already. 
For mockito 3 we will target java 8, there's a lot of clean up, maybe some rewriting, doing so we may break things, that happens even with tests, this phase should not be seen as something else than a beta.
 =||= > For 2 active dev branches (e.g. mockito3 beta in master and v2) we need to split release notes (e.g. notes/v2.md and notes/v3.md). It's not blocking v2 release, we can do it later. 

Exactly. Note that 2.x branch should see most activities, but the scope is limited. And after 2.1 we could declare 2.x in_maintainance_ mode.
 =||= I'm happy to rekindle the discussion. If you convince me, I win win because I learn more :)

> Also with this big changes cannot fit in your model

Why cannot the big feature be developed in a branch?

> For example 1.10.x series was nice but felt less stable to many users.

""felt less stable"" - do you have concrete data?

Some thoughts:
- users don't have to upgrade to every version
- we could do minor version bump every month or so, combine the release notes and do bigger announcement

> Some merged PR introduced the Mockito rule and the API had to be changed
> Some incorrect behavior had to be fixed, some were fixed later in the beta.

I'm not convinced that this is a problem of CD. This could happen in the traditional release model, too.

I'm a fan of CD because:
- it forces to care about quality, documentation, compatibility of every PR
- it gives features to users faster
- it provides features incrementally, the smaller the change, the lower chance of regression
- it helps with project maintenance - users test and pick up new versions faster

Let's say that we don't do CD. How would the release look like? You would release once in a while using magic String in commit message?
 =||= @szczepiq I don't say abandon CD, I like the CD, for the reason you mentioned. But let's not make a  release per se, like today maybe label them as `beta` or `build` this builds shows progress and still allows interested users to try mockito current work.

> > Also with this big changes cannot fit in your model
> 
> Why cannot the big feature be developed in a branch?

Yes they can, but sometime those are incomplete or buggy. Like having thread safety, or whatever else. 
And even so when these features land it is just possible to go back on some features, APIs, behaviour that was developed in a previous release.
 =||= > > For example 1.10.x series was nice but felt less stable to many users.
> 
> ""felt less stable"" - do you have concrete data?

Actually this _data_ comes the issue and PR we had at that time, questions asked on SO and from my own colleagues experience. However I don't have those question/gh issues in mind as it's been a long time ago.
 =||= > - users don't have to upgrade to every version

Indeed.

> - we could do minor version bump every month or so, combine the release notes and do bigger announcement

Yeah that works, but with previous point I think this could just be intermediary _preview_ / _milestone_ releases along with other regular beta builds.
 =||= > Yes they can, but sometime those are incomplete or buggy. Like having thread safety, or whatever else.
> And even so when these features land it is just possible to go back on some features, APIs, behaviour that was developed in a previous release.

Let's not push buggy or incomplete features :) The stability problem should be solved by high quality PRs, well designed, documented, and tested.

We can push ""build"" versions, etc. from branch if we see that it's a good idea.

> Actually this data comes the issue and PR we had at that time, questions asked on SO and from my own colleagues experience. However I don't have those question/gh issues in mind as it's been a long time ago.

It seems there aren't concrete datapoints at this time. I'd rather not change the CD strategy, wait for concrete data, re-evaluate as needed.
 =||= In the end I couldn't work on it this week, I'll try next week.
 =||= "Release procedure for branches and some javadoc"Sorry for the amount of commits. It happened due to merging. **Please squash** when applying the change.

Fixes #594 - now it should be possible to release from branches. It worked for the release/test branch so it should work for release/2.x :)"Szczepan Fabermockitoguy09/09/16, 05:12:07 AM
439.0635ArgumentCaptor and ArgumentMatcher can't be mixed in varargs"In the given test below the ArgumentCaptor should captor only the char 'c':

```
    @Captor
    private ArgumentCaptor<Character> argumentCaptor;

    @Test
    public void capturesVararg() throws Exception {
        mock.varargs(42, 'c');

        verify(mock).varargs(eq(42), argumentCaptor.capture());

       assertThat(argumentCaptor.getAllValues()).containsExactly('c');
    }
```

The test fails with this message:

```
Actual and expected should have same size but actual size was:
  <2>
while expected size was:
  <1>
Actual was:
  <[42, 'c']>
Expected was:
  <['c']>
```

Note that we see here 2 bugs:
- a wrong argument index was captored
- an `int`was captored by an  `ArgumentCaptor<Character>` -> #565""Yes `ArgumentCaptor` was not designed to be type aware. Though I like API with the least surprises, it should be fixed.

Thanks for reporting.
 =||= Note to my self: here is the solution [Gist ](https://gist.github.com/ChristianSchwarz/d755aa54e3637b0bd5f76bde3b882605)
 =||= This improvement makes Mockito easier to use and more intuitive. That's exactly the direction we should take Mockito. Thanks!!!
 =||= "Unified logic of argument matching and capturing"The logic of argument matching and capturing is the same but can be found in ArgumentsComparator and InvocationMatcher. This PR unifies the decision logic how matchers are applied to argument+varargs by introducing a `MatcherApplicationStrategy`. This strategy can apply an action to an pair of ArgumentMatcher and Argument. One action is used to perform the ArgumentMatcher.matches(arg) call and an other is used to perfrom the capturing.
- fixes #439 ArgumentCaptor and ArgumentMatcher's can now be mixed in varargs
- fixes #583 No more NPE when null is passed to an varargs 
- added 25 regression tests in VarargsTest (5 are ignored cause they belong to other issues and fail currently) 
- reduced logic duplication"Christian SchwarzChristianSchwarz10/17/16, 04:29:52 PM
583.0635ArgumentCaptor: NPE when an null array is passed to a varargs method"A NullPointerException is thrown if an null array is passed to a varargs method.

```
@Test
public void shouldCaptureVarArgs_nullArrayArg() {
        String[] argArray = null;
        mock.varargs(argArray);

        verify(mock).varargs(captor.capture()); //<- Kaboom NPE
}
```

Since an vararg is simply an array the ArgumentCaptor should reject it silently. This relates to #565.

```
java.lang.NullPointerException
    at java.lang.reflect.Array.getLength(Native Method)
    at org.mockito.internal.invocation.InvocationMatcher.captureVarargsPart(InvocationMatcher.java:142)
    at org.mockito.internal.invocation.InvocationMatcher.captureArgumentsFrom(InvocationMatcher.java:122)
    at org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:24)
    at org.mockito.internal.invocation.InvocationMarker.markVerified(InvocationMarker.java:18)
    at org.mockito.internal.verification.checkers.NumberOfInvocationsChecker.check(NumberOfInvocationsChecker.java:43)
    at org.mockito.internal.verification.Times.verify(Times.java:40)
    at org.mockito.internal.verification.MockAwareVerificationMode.verify(MockAwareVerificationMode.java:21)
    at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:73)
    at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:32)
    at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:37)
    at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:36)
    at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.access$0(MockMethodInterceptor.java:32)
    at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:113)
    at org.mockitousage.IMethods$MockitoMock$81506210.varargs(Unknown Source)
    at org.mockitousage.matchers.VarargsTest.shouldCaptureVarArgs_nullArrayArg(VarargsTest.java:182)
```""Probably related to #567
 =||= "Unified logic of argument matching and capturing"The logic of argument matching and capturing is the same but can be found in ArgumentsComparator and InvocationMatcher. This PR unifies the decision logic how matchers are applied to argument+varargs by introducing a `MatcherApplicationStrategy`. This strategy can apply an action to an pair of ArgumentMatcher and Argument. One action is used to perform the ArgumentMatcher.matches(arg) call and an other is used to perfrom the capturing.
- fixes #439 ArgumentCaptor and ArgumentMatcher's can now be mixed in varargs
- fixes #583 No more NPE when null is passed to an varargs 
- added 25 regression tests in VarargsTest (5 are ignored cause they belong to other issues and fail currently) 
- reduced logic duplication"Christian SchwarzChristianSchwarz10/17/16, 04:29:52 PM
561.0637Update Gradle to 3.0Gradle 3.0 is released so we can look into upgrading. Potentially we can rewrite our scripts into Kotlin."After we branch out `release/2.x` ;)
 =||= Kotlin? We need to discuss it before ;)
 =||= Yes we can discuss it in this issue. I have not looked into Kotlin at all so have no opinion atm. You do?
 =||= There are some limitations in Kotlin scripts. It is highlighted also in the [release notes](https://docs.gradle.org/3.0/release-notes):

> ... we are working intensely to make Gradle Script Kotlin fully production ready by the end of the year ...

In addition we have quite extensive build logic written in Groovy and I don't know it is worth to rewrite it just to have nicer code completion in Idea for those not very often times where there is something to change.
 =||= Seem decent arguments to not switch to Kotlin yet :+1: 
 =||= However gradle 3.0 still allows groovy, so that's not a blocker to switch
 =||= And should ""always"" will:

> Groovy is still the primary build language for Gradle scripts and will **always** be supported
 =||= +1 to keeping groovy build scripts :)
 =||= We cannot do it right now because Gradle 3.0 does not build with java6 and current release is still for java6 :( Let's close and revisit later. We won't forget to bump Gradle :)
 =||= We will switch from Java 6 soon and this issue has not been resolved yet. Therefore reopening to be tracked in waffle.
 =||= "Upgrade to Gradle 3.0"This bumps Gradle to 3.0. I was unable to reproduce the issue reported by @szpak in #521 about a failing compilation locally. Maybe Gradle fixed this after the release candidate was published which was originally used in #521.

Fixes #561 
Closes #521 "Tim van der LippeTimvdLippe09/17/16, 02:55:06 PM
521.0637Remove com.sun.* references"Currently build with gradle 3.0-milestone-2 fails with:

```
:buildSrc:compileJava/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:4: error: package com.sun.tools.doclets.formats.html does not exist
import com.sun.tools.doclets.formats.html.HtmlDoclet;
                                         ^
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:20: error: cannot find symbol
        return HtmlDoclet.optionLength(var0);
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:25: error: cannot find symbol
        return HtmlDoclet.start((RootDoc) Proxy.newProxyInstance(clz.getClassLoader(), clz.getInterfaces(), new ExcludeHandler(root)));
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:29: error: cannot find symbol
        return HtmlDoclet.validOptions(var0, var1);
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
/mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java:33: error: cannot find symbol
        return HtmlDoclet.languageVersion();
               ^
  symbol:   variable HtmlDoclet
  location: class JavadocExclude
Note: /mnt/homeold/szpak/cosie/code/inne/mockito/buildSrc/src/main/java/org/mockito/javadoc/JavadocExclude.java uses or overrides a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
5 errors
 FAILED
```

Related to #520.""This doclet is required to skip generating Javadoc for internal classes. Is there a mention in the Java 9 jdk of this breaking change?
 =||= This seems the corresponding JIRA ticket: https://bugs.openjdk.java.net/browse/JDK-8154399
 =||= I'm on a mobile device so couldn't check much, but the ticket mention a replacement for `com.sun....Standard` with the rewritten javadoc tool (`jdk.javadoc.doclets.StandardDoclet`) I didn't saw yet the `HtmlDocklet` yet it should be there as well.
 =||= I will be taking a stab at this tomorrow after switching to Java 8.
 =||= I think we have to (in jdk9) to move to `StandardDoclet`: http://hg.openjdk.java.net/jdk9/dev/langtools/file/6077dc32728a/src/jdk.javadoc/share/classes/jdk/javadoc/doclets/StandardDoclet.java However, this class does not exist in jdk8 so I am not sure what our options are.
 =||= I think we could have both doclet in [javadoc.gradle](https://www.theguardian.com/lifeandstyle/2016/apr/29/how-to-have-a-great-conversation-with-someone-who-is-going-to-die)

``` java
if (JavaVersion.current().isJava9Compatible()) {
    options.doclet ""org.mockito.javadoc.Java9JavadocExclude""
} else {
    options.doclet ""org.mockito.javadoc.JavadocExclude""
}
```

[Gradle 3 `JavaVersion` javadoc](https://docs.gradle.org/current/javadoc/org/gradle/api/JavaVersion.html)
 =||= @bric3 Yes that was what I implemented at https://github.com/mockito/mockito/pull/639/files#diff-39cbd22b5198600bd49c364c42e0aaa9R17 :)
 =||= Has been fixed in several PRs and the doclet was later removed. =||= "Upgrade to Gradle 3.0"This bumps Gradle to 3.0. I was unable to reproduce the issue reported by @szpak in #521 about a failing compilation locally. Maybe Gradle fixed this after the release candidate was published which was originally used in #521.

Fixes #561 
Closes #521 "Tim van der LippeTimvdLippe09/17/16, 02:55:06 PM
633.0641Update core dev team in gradle"For example https://mvnrepository.com/artifact/org.mockito/mockito-core/2.1.0-RC.1 only lists @bric3 and @szczepiq. We need to include all @mockito/developers e.g. @timvdlippe, @raphw, @marcingrzejszczak and @szpak 

@szczepiq For the 3.0.0-beta.1 should we remove you from the list or what is the expected timeline for you?""P.S. @szczepiq if you still want to contribute to Mockito that is of course possible too. We are just wondering what the status is :) (if you decide to stay, we also have to invite you for our Slack, which I need your email for)
 =||= I haven't done much for 2.x. I'm comfortable with not being on the list right now. Maybe with 3.x I would have bigger contribution to the project.

I'm against removing Szczepan from the list. He created this project and he deserves to be on the developers list forever. What's more Szczepan currently is quite active, so maybe he will change his mind to leave the project :).

At the worst I would change developer to former-developer, founder or something like that.
 =||= Yeah the same with me in terms of 2.x. I did close to nothing.  I fully agree with @szpak  about Szczepan.
 =||= @TimvdLippe, the list can be updated in ""pom.gradle"". I don't see good reasons why we should remove people from this list. All former and current team members should happily remain there, including @szpak and @marcingrzejszczak :)

I'll let you know when I step down completely, not just yet ;) If I become inactive due to other priorities the team should move forward with growing and improving Mockito.
 =||= @szczepiq Yes I agree with the others to not remove people so I submitted #641 which does not remove anyone from the list, only add them :smile: 
 =||= "Update generated pom.xml with more project information"I added some more information based on the specification at https://maven.apache.org/pom.html

Fixes #633"Tim van der LippeTimvdLippe09/17/16, 03:38:04 PM
640.0646Improve exception message to hint at upgrading java minor version to latestDriven by #636"Can be closed...
 =||= "Fixes #640 Warns user to upgrade if Java 8 version is to low"Fixes #640 Warns user to upgrade if Java 8 version is to low.

Also took the opportunity to log other platform details if mock class cannot be created."Brice Dutheilbric309/26/16, 07:58:18 AM
650.0651Update AssertJ to 3Since AssertJ 3 relies on Java 8, we can now update on master. It seems that there are very few breaking changes so hopefully this should not be a big hassle.Update AssertJ to 3.5.2"AssertJ 3 requires Java 8 and was therefore a breaking change,
but there are no other changes breaking our test suite.

Fixes #650 "Tim van der LippeTimvdLippe09/24/16, 02:33:30 PM
653.0654Typos in FailureDetecter`FailureDetecter` should be `FailureDetector`. Its method `isSussessful()` should probably be `isSuccessful()`."PR? :)
 =||= Check. See #654.
 =||= "Renamed FailureDetecter to Failure Detector."Also renamed misspelled isSussessful() to isSuccessful().

Fixes: #653."Oliver Drotbohmodrotbohm09/27/16, 02:50:35 PM
661.0662Update Gradle to 3.1Keep mockito up-to-date with Gradle. 3.1 is released and it brings some performance improvements, fixes and features: https://docs.gradle.org/3.1/release-notesUpgrade to Gradle 3.1"Upgrading Gradle version to 3.1

Fixes #661"Jonatan Ivanovjonatan-ivanov09/30/16, 01:40:30 PM
669.0670Publish mockito artifacts to 'mockito' organization in BintrayInstead of publishing to 'szczepiq' user, the artifacts should be published to 'mockito' organization in Bintray."In progress. I transferred ownership of ""szczepiq/maven"" repository to the ""mockito"" org. It takes forever to complete in Bintray UI api. Keeping thumbs up ;)

I spent 1.5 hours poking around oss nexus and bintray. Too long to get stuff done.
 =||= Things that matter can take time ;)
 =||= Reopening because it is not merged yet to the main branch (this also make it appear in release notes twice as PR and as an issue).
 =||= Let's close it. We will merge all from release branch -> master anyway.
 =||= "Artifacts are now published to 'mockito' org in BintrayFixes #669, more details in the commit message.Szczepan Fabermockitoguy10/04/16, 01:37:33 PM
727.0746Copyright notice missing on filesLet's add automation that will make consistent copyright notice on all source files."If nobody's working on it I can send you a PR.
 =||= @DmitriyZaitsev Looking forward to it 😄 
 =||= "Add missing copyright headers"- [x] Fixes #727 
- [x] Add missing copyrights using [license-gradle-plugin](https://github.com/hierynomus/license-gradle-plugin).
- [x] Updated only source files. Test files were skipped. Existing copyright headers were not modified."Dmitriy ZaitsevDmitriyZaitsev11/08/16, 08:06:56 PM
609.0754Silent JUnit runner and quiet JUnit rule are better expose in the docsSee great feedback from a user in #384"https://github.com/mockito/mockito/issues/384#issuecomment-243044175
 =||= @szczepiq This is not the javadoc but I've mentioned a bit the runner in the what's new / migration guide in the wiki in the improvement section 

https://github.com/mockito/mockito/wiki/What%27s-new-in-Mockito-2
 =||= Per https://github.com/mockito/mockito/issues/720#issuecomment-257087017 the message of `UnnecessaryStubbingException` should be improved to mention `MockitoJUnitRunner.Silent`.
 =||= "Improved documentation regarding unused stubbing detectionImproved documentation regarding unused stubbing detection, fixes #609Szczepan Fabermockitoguy11/14/16, 11:09:43 AM
756.0795Deep stubbing and UnnecessaryStubbingException"Mocks that return deep stubs sometimes cause UnnecessaryStubbingExceptions to be thrown, when I don't think that they should. Here's a small self-contained example.

```
package some.package;

import org.jboss.netty.channel.ChannelFuture;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Answers;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class MockitoDeepStubsTest {

    private final ClassUnderTest classUnderTest = new ClassUnderTest();

    @Mock(answer = Answers.RETURNS_DEEP_STUBS) private ChannelFuture mockChannelFuture;

    @Test
    public void shouldAllowDeepStubsUnnecessaryStubbing() {
        classUnderTest.methodUnderTest(mockChannelFuture);
    }

    public static class ClassUnderTest {

        public void methodUnderTest(ChannelFuture future) {
            future.getChannel().close();
        }

    }
}
```
Running this test prints the following output:
```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected in test class: MockitoDeepStubsTest
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -> at some.package.MockitoDeepStubsTest$ClassUnderTest.methodUnderTest(MockitoDeepStubsTest.java:25)
Please remove unnecessary stubbings. More info: javadoc for UnnecessaryStubbingException class.

	at org.mockito.internal.exceptions.Reporter.formatUnncessaryStubbingException(Reporter.java:838)
	at org.mockito.internal.junit.UnnecessaryStubbingsReporter.validateUnusedStubs(UnnecessaryStubbingsReporter.java:30)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:45)
	at org.mockito.runners.MockitoJUnitRunner.run(MockitoJUnitRunner.java:104)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```

Versions: Mockito 2.2.8
JDK: OpenJDK 1.8.0_111
OS: CentOS 7
Netty: 3.10.6.Final

I know that I can suppress the error with the Silent runner, but I like the unnecessary stubbing checking and don't really want to disable it. For now, we're working around it, but this doesn't seem like correct behaviour.""Fantastic bug report: reproducible sample, clear motivation. Thanks! I'm looking at it now.
 =||= I was able to repro this with a smaller example that does not use netty. It's a bug that needs to be fixed. Thank you for reporting!

``` java
@RunWith(MockitoJUnitRunner.class)
public class MockitoDeepStubsTest {

    private final ClassUnderTest classUnderTest = new ClassUnderTest();

    @Mock(answer = Answers.RETURNS_DEEP_STUBS) private ChannelFuture mockChannelFuture;

    @Test
    public void shouldAllowDeepStubsUnnecessaryStubbing() {
        classUnderTest.methodUnderTest(mockChannelFuture);
    }

    public static class ClassUnderTest {
        void methodUnderTest(ChannelFuture future) {
            future.getChannel().close();
        }
    }

    interface ChannelFuture {
        Channel getChannel();
    }

    interface Channel {
        void close();
    }
}
```
 =||= @bschelberg, thank you for reporting! Stay tuned for Mockito 2.3.0 that will come with even better support for cleaner and easier to debug tests! =||= "Deep stubs no longer cause unnecessary stubbing exception with JUnit runnerFixes #756Szczepan Fabermockitoguy12/02/16, 01:40:36 PM
798.0813Update Jacoco to stable minor version 0.7.8 when released"See https://github.com/jacoco/jacoco/issues/467#issuecomment-264311016

The snapshot version of Jacoco are removed and could fail our CI. The version of Jacoco is required to build on JDK9"Release approaching ;) =||= `0.7.8` has been released: https://github.com/jacoco/jacoco/issues/467#issuecomment-266305876 =||= Fixed by #798. =||= [#798] Upgrade Jacoco to stable 0.7.8Fixes #798.Marcin Zajączkowskiszpak12/12/16, 09:17:41 PM
818.0823StackOverflow occurs when mocking a HashMap with mockmaker"As investigated in #752, mocking a `HashMap` halts with a stack overflow when using `mock-maker-inline`:

```
Mockito.mock(HashMap.class);

Exception in thread ""Reference Handler"" java.lang.StackOverflowError
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethod(Class.java:2128)
	at java.util.HashMap.get(HashMap.java:556)
	at sun.reflect.Reflection.filterMethods(Reflection.java:291)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethod(Class.java:2128)
	at java.util.HashMap.get(HashMap.java:556)
	at sun.reflect.Reflection.filterMethods(Reflection.java:291)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethod(Class.java:2128)
	at java.util.HashMap.get(HashMap.java:556)
	at sun.reflect.Reflection.filterMethods(Reflection.java:291)
	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
	at java.lang.Class.getDeclaredMethod(Class.java:2128)
	at java.util.HashMap.get(HashMap.java:556)
	at sun.reflect.Reflection.filterMethods(Reflection.java:291)
```

This does not occur when mocking `Map`.
Verified against Mockito 2.2.28."Only resolve instrumented method after validating that an instance is…This is both a performance improvement and a way of ensuring that no stack overflow error occurs upon looking up a `Method` instance which requires using a `HashMap` which causes an infitite loop upon mocking the hash map type. Fixes #818.Rafael Winterhalterraphw12/15/16, 10:16:59 AM
866.0867When custom exception fillInstackTrace() returns null, Exception mock cannot work properly"```java
public class CustomException extends Exception {

    public CustomException() {
        super();
    }

    @Override
    public Exception fillInStackTrace() {
        return null;
    }
}
```

TestCase like this
```java
 when(demo.process()).thenThrow(new CustomException())

//... test code
```

```
java.lang.NullPointerException
	at org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter.filter(ConditionalStackTraceFilter.java:23)
	at org.mockito.internal.stubbing.answers.ThrowsException.answer(ThrowsException.java:32)
	at org.mockito.internal.stubbing.StubbedInvocationMatcher.answer(StubbedInvocationMatcher.java:35)
	at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:95)
```""This is a bug in the user code. Yet Mockito should handle that gracefully.

Thanks for reporting. =||= "Fixes #866 should not throw NPE, when custom Exception fillInStackTrace returns nullfixes #866.wuwenwuwen501/04/17, 04:58:43 PM
860.0868Jacoco 0.7.8 breaks tests for the new plugin mechanism"Jacoco 0.7.8 breaks the tests for the new plugin mechanism (#811) with:

```
:test

org.mockitoutil.ClassLoadersTest > cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded FAILED
    java.lang.AssertionError: 
    Expecting a throwable with cause being an instance of:
     <java.lang.NoClassDefFoundError>
    but was an instance of:
     <java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$2 with modifiers ""private static transient"">
        at org.mockitoutil.ClassLoadersTest.cannot_load_runnable_in_given_classloader_if_some_type_cant_be_loaded(ClassLoadersTest.java:324)

org.mockitoutil.ClassLoadersTest > can_run_in_given_classloader FAILED
    java.lang.IllegalStateException: Given task could not be loaded properly in the given classloader 'org.mockitoutil.ClassLoadersTest$1@46dcdf84', error 'java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

        Caused by:
        java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

            Caused by:
            java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockitoutil.ClassLoadersTest$1 with modifiers ""private static transient""

org.mockito.internal.configuration.GlobalConfigurationTest > returns_mockito_annotation_engine_of_Plugins_if_no_MockitoConfiguration FAILED
    java.lang.IllegalStateException: Given task could not be loaded properly in the given classloader 'org.mockito.internal.configuration.GlobalConfigurationTest$1@5adb485', error 'java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

        Caused by:
        java.lang.IllegalStateException: java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

            Caused by:
            java.lang.IllegalAccessException: Class org.mockitoutil.ClassLoaders$ClassLoaderExecutor can not access a member of class org.mockito.internal.configuration.GlobalConfigurationTest$1 with modifiers ""private static transient""

1701 tests completed, 3 failed, 42 skipped
:test FAILED
```

The corresponding Travis build: https://travis-ci.org/mockito/mockito/jobs/187043982#L431"@bric3 Can you identify the minimal scenario that reproduce this issue to be able to report it to the JaCoCo team? =||= Fixes #860, jacaco synthetic fields are not anymore final in 0.7.8"Fixes #860 

This internal assumed JaCoCo fields will always be `static final`, obviously not. JaCoCo 0.7.8 changed that. The simple fix was to make the source field _accessible_ instead of skipping this field.

Hence removing the test exclusion."Brice Dutheilbric301/04/17, 03:02:15 PM
871.0886Travis builds from non-core developers fail on assertEnvVariables"Example build: https://travis-ci.org/mockito/mockito/jobs/188911380

Seems that this does not affect core developers, as my build has been succesful: https://travis-ci.org/mockito/mockito/builds/188321204 as well as those in #865 and #859"I think the easiest solution is to not assert the GH_TOKEN if the build is a pull request =||= Can't we just disable the checks if the repo is not mockito/mockito ? =||= Pull requests always have `mockito/mockito` as repository? =||= No only ours, external contributors have a fork. Since the GH_TOKEN assertion don't fail for our pull request I think this is safe assumption. =||= @szczepiq could you make this high priority on your list? Failing builds discourages external developers from publishing their work =||= Fixed build for external contributors"Moved the validation of env variables required for release to further release step. We don't need to assert the variables if the release is skipped.

Fixes #871

Merge at will. Reordering those release steps is safe. Those steps do not impact the release process in any way. Removing those steps completely would not break the release. It would  just make it fail later VS fast, and would make the failure less readable. Hence, the validation steps are useful but reordering them does not impact the release.

I tested it by running ""./gradlew release -PdryRun"". If you export the variables, you can actually use above to dry run the release."Szczepan Fabermockitoguy01/15/17, 07:13:01 PM
882.0887Upgrading to Objenesis 2.5"Mockito already uses Objenesis 2.4.
However Objenesis 2.5 was just released and supports the latest [JDK 9 build 151 jigsaw](http://objenesis.org/notes.html)"Fixes #882: Upgrade to Objenesis 2.5"Upgrade to Objenesis 2.5 in order to properly support Java 9.

Cherry picked from master commit d1faf7b82c9e0823ebba9b9ded6c6b179ba57102, fixed conflicts and verified.

This PR fixes #882 ."Allon Murienikmureinik01/15/17, 09:03:21 PM
874.0891Overridden abstract methods using generics are not longer called for partial mock (working with Mockito 1.10.19)"Hi,

We migrated to Mockito 2.x not so long ago and we came across a test that used to works back in Mockito 1 (1.10.19) and no longer works with the latest 2.x version (2.5.6).

Here is the SSCCE to replicate the issue:

```
package com.some.company;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;

import javax.swing.JButton;

import org.junit.Test;

public class Mockito2Issue
{
	public abstract class SomeAbstractClass<T>
	{
		protected abstract String getRealValue(T value);

		public String getValue(T value)
		{
			return getRealValue(value);
		}
	}

	public class SomeConcreteClass<T extends java.awt.Component> extends SomeAbstractClass<T>
	{
		@Override
		protected String getRealValue(T value)
		{
			return ""RealValue"";
		}
	}

	@Test
	public void testBug() throws IOException, InstantiationException, IllegalAccessException, InvocationTargetException
	{
		SomeConcreteClass<java.awt.Component> testBug = spy(new SomeConcreteClass<java.awt.Component>());
		assertEquals(""RealValue"", testBug.getValue(new JButton()));
	}
}
```

**Before (1.10.19):**
Used to works

**After (2.5.6)**
```
java.lang.AssertionError: expected:<RealValue> but was:<null>
	at org.junit.Assert.fail(Assert.java:91)
	at org.junit.Assert.failNotEquals(Assert.java:645)
	at org.junit.Assert.assertEquals(Assert.java:126)
	at org.junit.Assert.assertEquals(Assert.java:145)
	at com.some.company.Mockito2Issue.testBug(Mockito2Issue.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)
	at org.junit.runners.BlockJUnit4ClassRunner.runNotIgnored(BlockJUnit4ClassRunner.java:79)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:71)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:49)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:193)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:52)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:191)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:42)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:184)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:236)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)
```

We performed a few side tests and here are the results:
- if we change the method `getRealValue` in class `SomeAbstractClass` to be non-abstract but rather throw an exception, the test pass:
```
		protected String getRealValue(T value)
		{
			throw new UnsupportedOperationException();
		}
```
- if we no longer use generic on the method (e.g. using Object rather than T), the test pass.

Can you take a look at this?


Environment details:

Component | Version
--------- | ------
OS | Ubuntu 16.10
Java | Oracle Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Eclipse | Neon.2
JUnit | 4.8.2
Mockito | 1.10.19 (before), 2.5.6 (after)""This is probably a regression after adopting Byte-Buddy. @raphw did you encounter such issues with Byte-Buddy? =||= It is indeed a problem in Byte Buddy when processing raw types (Mockito extends the generic type without implementing the type variable) in the method graph compiler. I already added a test case to Byte Buddy and I will try to fix the problem some time next week.

I do now understand the problem. Mockito extends `SomeConcreteClass` as a raw type as it does not define any type variables. By this, any type is considered as raw in alignment with the Java specification. Therefore, `getRealValue(Object)` and `getRealValue(Component)` are not merged in the graph and the attempt to invoke `getRealValue(Object)` results in returning `null` via the default answer as it is no longer considered a bridge.

This is actually a bit tricky but I will think of something. =||= Tracked in: https://github.com/raphw/byte-buddy/issues/255 =||= Thanks @domtoupin for the SSCCE !
Thanks @raphw for the quick tracking of the issue. =||= "Update to Byte Buddy 1.6.4: Fixes bridge method resolution for generic typesFixes #874.Rafael Winterhalterraphw01/19/17, 05:06:30 PM
895.0896Documentation missing clarification for consecutive stubbing"The [documentation](https://static.javadoc.io/org.mockito/mockito-core/2.6.3/org/mockito/Mockito.html#10) for consecutive stubbing is missing a clarification.

When multiple when/thenReturn statements are being used instead of chaining .thenReturn() statements, each stubbing overrides the existing one.

"I am going to submit a Pull Request, adding an additional clarification with code example in the docs. =||= Clarify documentation for consecutive stubbing"Fixes #895

As of now, the documentation does not clarify the difference of behaviour between chaining multiple .thenReturn() statements and using multiple when/thenReturn statements, when someone attempts to perform consecutive stubbing.

I added a warning/clarification in the documentation with a corresponding example, so that it's more clear (especially for new users of Mockito)."Dimos Raptisdimosr01/21/17, 12:29:26 PM
897CleansEmpty value returns empty arrays"Fixes #876 and do a bit more cleanup

* Moves returning empty array from `ReturnsMoreEmtpyValues` to `ReturnsEmptyValues`
* Cleans up javadoc
* Removes reflection for Java8 types (implementation and tests)

Best to review commit by commit."Brice Dutheilbric301/23/17, 01:48:12 PM
929.0931New 'mockito-inline' artifact does not work"mockito-inline 2.7.2

build.gradle:
```groovy
apply plugin: 'java'

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

repositories {
    jcenter()
}

dependencies {
    testCompile 'junit:junit:4.12'
    testCompile 'org.mockito:mockito-inline:2.7.2'
}
```

Test target:
```java
final class Foo {

}
```

Test for Foo:
```java
public class FooTest {

    @Test
    public void test() {
        Mockito.mock(Foo.class);
    }

}
```

Test command:
```
$ ./gradlew clean test
:clean
:compileJava
:processResources UP-TO-DATE
:classes
:compileTestJava
:processTestResources UP-TO-DATE
:testClasses
:test

com.example.FooTest > test FAILED
    org.mockito.exceptions.base.MockitoException at FooTest.java:10

1 test completed, 1 failed
:test FAILED

FAILURE: Build failed with an exception.
```

Test report:
```
org.mockito.exceptions.base.MockitoException: 
Cannot mock/spy class com.example.Foo
Mockito cannot mock/spy because :
 - final class
	at com.example.FooTest.test(FooTest.java:10)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
```

### Reason

`mockito-extensions/org.mockito.plugins.MockMaker` is not included in the mockito-inline.jar.
```
$ jar tvf mockito-inline-2.7.2.jar 
     0 Sat Feb 04 12:02:54 JST 2017 META-INF/
    25 Sat Feb 04 12:02:54 JST 2017 META-INF/MANIFEST.MF
```

In [the inline subproject](https://github.com/mockito/mockito/tree/release/2.x/subprojects/inline), org.mockito.plugins.MockMaker is in `src/resources/mockito-extensions` directory.
Is this correct?

In [the android subproject](https://github.com/mockito/mockito/tree/release/2.x/subprojects/android), the file is in src/**main**/resources/mockito-extensions.""Reproducible project:
[mockito_issue_929.zip](https://github.com/mockito/mockito/files/756407/mockito_issue_929.zip)
 =||= Seems like our Gradle build is not set up to include this file on Travis. It does work on my local machine, though. Strange things, thanks for reporting! =||= "Fixes #929: Move the resources directory to src/main"Moved the resources directory to src/main so that the MockMaker file is included in mockito-inline.jar.
Also added two tests to verify plugin-type is inline.

This PR fixes #929."Tsuyoshi Murakamitmurakami02/07/17, 06:09:26 PM
903.0932Review usage of linter during build"Given the amount of stylistic changes lately in primarily @bric3 PRs, I think we should consider installing a linter to make sure the style is enforced project wide. In my opinion this linter should be extremely lenient, just enforce some very simple rules.

We can look into configuring Checkstyle such that it checks a handful of properties. We can always later decide to make the linter more strict."I have to push the code style decided a few months ago, maybe gradle can generate a section with the mockito style for IDEA (and eclipse and netbeans) =||= Absolutely great idea. Perhaps it's worth waiting for Mockito3 before we do that to avoid merging problems? =||= Checkstyle conf. to enforce whitespace rules"After PR #928 cleaned up some whitespace issues in the codebase (see
details there), this patch adds the checkstyle plugin to build to
enforce the standard established there:
1. A line may not end with trailing whitespaces
2. A file must end with the newline character

Note that this PR by no means intends to provide a full checkstyle configuration to the project.
It merely introduces the framework and two basic checks discussed in PR #928. Additional patches could easily add (or remove) additional checks as the dev community sees fit.

Usage note:
With this change applied, checkstyle would be run as part fo the gradle build. If a line in a `.java` source file ends with trailing whitespaces, the build will fail and an error message would be printed to the console. Additionally, an HTML report with all the errors would be generated. 

E.g.:

```
[ant:checkstyle] /home/amureini/src/git/mockito/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidByteBuddyMockMaker.java:14: Line has trailing spaces.
:android:checkstyleMain FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':android:checkstyleMain'.
> Checkstyle rule violations were found. See the report at: file:///home/amureini/src/git/mockito/subprojects/android/build/reports/checkstyle/main.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
```

Fixes #903"Allon Murienikmureinik02/17/17, 04:04:14 PM
927.0933Mockito can't unbox Void"Hi,

The following [bug](https://github.com/powermock/powermock/issues/708) was created for PowerMock:  

> PowerMockito doesn't seem to unbox java.lang.Void.
> I am writing a test for my code that uses Google cloud storage API to delete a file. Google API returns Void for deleting a file. Code works fine but when I instruct my test as PowerMockito.doNothing().when(delete).execute(); It complains that execute has a return value of Void.

But PowerMock just delegates call to Mockito in this case and Mockito throws exception: 

```
org.mockito.exceptions.base.MockitoException: 
Only void methods can doNothing()!
Example of correct use of doNothing():
    doNothing().
    doThrow(new RuntimeException())
    .when(mock).someVoidMethod();
Above means:
someVoidMethod() does nothing the 1st time but throws an exception the 2nd time is called
```

I have doubts about expected behaviour. For one side, method return something, but it return a `Void` which always is just `Void` and nothing could be changed. 

Anyway, it could be fixed only on Mockito side (without dirty hacks). "Support for return type 'Void' in DoesNothingAnswer"fixes #927 
This PR allows to use `doNothing(..)` for methods with return type `java.lang.Void` like void-methods.  

To solve this `InvocationInfo.isVoid()` checks now the return type for the pseudo-type of the keyword `void` or `Void`."Christian SchwarzChristianSchwarz02/07/17, 03:27:32 PM
894.0934Javadoc generation fails with jdk1.8.0_121"When I set the jdk to jdk1.8.0_121 the build fails javadoc error. 

Full log including steps to reproduce:

```
~/mockito/src$ export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/
~/mockito/src$ ./gradlew javadoc -i


...

javadoc: error - Argument for -top contains JavaScript.
Use --allow-script-in-comments to allow use of JavaScript.
1 error
100 warnings
Problems generating Javadoc.

...

:javadoc FAILED
:javadoc (Thread[Task worker,5,main]) completed. Took 1.936 secs.

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':javadoc'.
> Javadoc generation failed. Generated Javadoc options file (useful for troubleshooting): '/Users/sfaber/mockito/src/build/tmp/javadoc/javadoc.options'

* Try:
Run with --stacktrace option to get the stack trace. Run with --debug option to get more log output.

BUILD FAILED
```""I tried to add in previous Open JDK 8 (102) but the option is not recognized

```
option.addStringOption('--allow-script-in-comments')
option.addStringOption('-allow-script-in-comments')
option.addStringOption('allow-script-in-comments')
```

I'll try later with the same JDK (121) =||= Could it be related to #787 ? =||= I will also take another look at the service-worker thing, as it does not appear to work with javadoc.io. If I can't fix it (after exams :wink: ) then I will simply revert it. =||= ;)

Contiuous improvements =||= From the release notes: http://www.oracle.com/technetwork/java/javase/8u121-relnotes-3315208.html

> The javadoc tool will now reject any occurrences of JavaScript code in the javadoc documentation comments and command-line options, unless the command-line option, --allow-script-in-comments is specified.
> 
> With the --allow-script-in-comments option, the javadoc tool will preserve JavaScript code in documentation comments and command-line options. An error will be given by the javadoc tool if JavaScript code is found and the command-line option is not set.
> JDK-8138725 (not public) =||= "Fix JavaDoc generation on recent JDK 8 builds"Syntax was a bit tricky, but this appears to generate the correct javadoc.options file for me.

Fixes #894"Tim van der LippeTimvdLippe02/08/17, 10:10:43 AM
680.0942Allow spying on interfaces so that it is convenient to work with Java 8 default methods"## Problem

While Mockito supports and stubs by default the _default methods_ in interfaces, the stubbing code can be a bit non intuitive, e.g.

``` java
interface DM {
    int contract();
    default int default_contract() { return contract() + 1; }
}

DM dm = mock(DM.class);
given(dm.contract()).willReturn(2);

// necessary otherwise default method is stubbed
given(dm.default_contract()).willCallRealMethod();

assertThat(dm.default_contract()).isEqualTo(3);
```

This behavior is unintuitive to users who expect the default methods to trigger real implementation (callRealMethod() by default). See also user report at #940.

## Suggested plan

:1st_place_medal: Contributions are welcome!

- [x] relax validation and allow interfaces to be spied. This way users can invoke spy(SomeInterface) or use @Spy with interfaces. This way, we don't need to mark default methods with ""callRealMethod"".
- [x] ensure test coverage for mocking
  - interfaces with and without default methods
  - concrete classes that extend interface with default methods (perhaps already covered)
- [x] document this use case. On main Mockito javadoc the use can search for ""default"" and find information about default methods behavior. Suggested by user at #940.
- [ ] create a separate ticket for Mockito 3 (""2.* incompatible"" label) to discuss whether we should change the default behavior for defender/default methods. Perhaps they should automatically call real method regardless if someone uses spy() or mock() with the interface. Also we should consider mocking/spying on concrete classes that extend from interface with default methods.

## Discontinued ~~original plan~~

Below idea was discontinued:

Replace `DM` by `Map`, `default_contract()` by `getOrDefault()`, `contract()` by `get()` or `containsKey()` and you have a problem with designs that are used in the JDK itself.

I think mockito can improve on this by configuring the mock to invoke concrete default methods rather than stubbing them. This could be done the following way (_api naming in progress_) : 
- `mock(DM.class, USE_DEFAULT_METHODS)`
  
  The issue with that approach is that a default answer is mutually exclusive with other answers. e.g. if one wants to use `RETURNS_SMART_NULLS` and default methods this cannot work with the current design.
- `mock(DM.class, withSettings().useDefaultMethods())`
  
  This approach is interesting as it allows to configure the behaviour with possibly any answer. However this may require some changes with our internal answers, not a deal breaker though.""> mock(DM.class, withSettings().useDefaultMethods())

I like that. 'spyDefaultMethods'?

BTW. What's better/more intuitive default for default methods? real method invocation or empty/unstubbed value?
 =||= I think that depends on the mocked type. I'd say :
- interface => use default methods by default
- concrete => I'm not sure I'd rather not make those default

`spyDefaultMethod` is wrong because the primary objective is not to spy them.
 =||= So potentially this is Mockito 3 backwards incompatible change (when changing defaults). Thanks for bringing this up!
 =||= For this thing only this could be potntially backward incompatible. Yet for this thing only I'm not yet sure we should change the default between 2.x and 3.x whatever the introduction or not of `useDefaultMethods` in `2.x`. 

I'm a bit undecided at that moment. I may have a better opinion when the code is actually done. 

Right now the code base of mockito 2.x runs Java6 so we don't have Java 8 tests, Mockito 3 (master) is Java 8 and we'll introduce Java 8 specific tests.
 =||= Makes perfect sense.

We already have code in 2.x that detects java 8. Up to you how to push that further ;)
 =||= If starting from scratch, I couldn't think of a use case that'd benefit from stubbing the default methods by default.

But maybe that use case does exist, or at least for backward compatibility it's too late to change?

Either way, I propose we do not need to add a default Answer or anything to mock(). 

Default methods in interfaces are much like concrete methods in abstract classes. `spy(AnAbstractClass.class)` today already _by default_ invokes concrete methods unless they are explicitly stubbed. It seems natural to me that we just relax the restriction on `spy(SomeInterface.class)` to accept interface as a parameter instead of throwing illegal usage exception as it does today.
 =||= @fluentfuture Can you elaborate on that : 

> It seems natural to me that we just relax the restriction on `spy(SomeInterface.class)` to accept interface as a parameter instead of throwing illegal usage exception as it does today.

Yes backward compatiblity is a primary concern. Yet if the change makes sense and doesn't impact users in a bad way it can be discussed.
Also maybe we could backport behavior and API from master to release/2x. =||= Sure.

Today, if java.util.Consumer were an abstract class defined as:

```java
public abstract class Consumer<T> {
  public Consumer<T> andThen(Consumer<? super T> that) {
    return v -> {accept(v); that.accept(v);};
  }

  public abstract void accept(T value);
}
```

I can `@Spy` it to have `andThen()` called by default:
```java
@Spy private final Consumer<String> consumer1;
@Spy private final Consumer<String> consumer2;

@Test public void testCompose() {
  consumer1.andThen(consumer2).accept(""hi"");
  verify(consumer1).accept(""hi"");
  verify(consumer2).accept(""hi"");
}
```

It doesn't work with Consumer being interface with `andThen()` being an equivalent default method:

```java
public interface Consumer<T> {
  default Consumer<T> andThen(Consumer<? super T> that) {
    return v -> {accept(v); that.accept(v);};
  }

  void accept(T value);
}
```

But that is just because we are having a validation that rejects spy(Consumer.class). That validation can be removed because it doesn't hurt even if you spy(AnInterface.class) and even if that interface has no default method, because it will just work the same way as mock(AnInterface.class).

Here's a [commit](https://github.com/fluentfuture/mockito/commit/afdd5ebc32de38d098c517bda32c83e194371574) in my fork that removes the validation and the above test passes.


By the way, I retract my suggestion to make `mock(AnInterface.class)` to call default methods, because then it would break the symmetry with `mock(AnEquivalentAbstractClass.class)`, which can be surprising. =||= Ah I see.

Imho spying an interface `spy(Interface.class)` is wrong, even when there's default methods, it doesn't feel like a a spy. As spy have more meaning to spy concrete code.

Instead mocking an interface `mock(Interface.class)` to call default methods only seems ok. And maybe backward compatible. Although I would like opt-in/out mechanism.
But mocking an abstract class `mock(AnEquivalentAbstractClass.class)` should never call concrete code. =||= I agree that the spy() name is kinda misleading for the behavior of ""mock only abstract methods"".

I originally proposed fake() or other names but spy() was chosen none-the-less.

I don't defend the spy() name but it's what we have, so there may be some value to consistency.

 =||= `spy` is a specialized mock that seems to _speak_ for everyone, maybe `fake` can be another compelling specilization.

At this moment not sure if we will, but maybe in the future. =||= Here's how I found peace with the spy() name:

Yes it calls the non-abstract methods, which isn't spying (more like fake). But it also allows you to explicitly stub them with `when()` or to `verify()` them, so in that sense, it can still be called a spy. =||= Regarding ""interface"" vs. ""abstract class"", I personally think we should try not to be picky about the difference.

Some project scoped or company scoped APIs out there aren't designed to be implemented/subclassed directly by users. For these APIs, going from an abstract class to interface or vice versa is reserved as an implementation detail change.

The worst that should happen with changing abstract class to interface is that a handful of direct subclasses break compilation and need to be fixed to use the ""implements"" keyword.

It'd be a much bigger burden if all the sudden a lot of tests that used to spy() on the abstract class fail just because of the abstract -> interface change.

Specifically, now with Java 8, I'd expect some abstract classes to become interfaces with default methods because the only reason they were abstract classes in the first place was to be able to have some default methods (for fluent chaining and stuff). =||= Interesting feedback. I still have mixed feeling about relaxing spy to allow an interface.
I'll sleep on it, and think about it as your migration use case is legitimate.

And anyway this address only a part of the original issue. =||= @bric3 Can you explain which part isn't addressed in the original issue, assuming we put aside the mock() vs. spy() naming difference? =||= @fluentfuture I meant regarding configurability of stubbing default method for a mock, not a spy.

Yet the use cases discussed above are defintely additional scenario to account for when we will implement the stuff. =||= @bric3 Are you okay with allowing @Spy on interfaces? If so, I'll send a PR. =||= @fluentfuture yes. I have worked on it in #906. But I won't have a computer near me for a week still. =||= Great discussion. 

+1 to allow spying on interfaces
-1 to adding new public API method like 'fake' - it would make the api more complicated just for the sake of a single use case
+ 0.5 to changing the default behavior of Mockito 3 to 'spy' interface defender methods by default. This way it is the most intuitive behavior users expect. See https://github.com/mockito/mockito/issues/940 =||= I attempted to update the ticket description to reflect the outcome of the discussion. Feel free to change if needed. =||= If I were going to add another method I would call it `stub` based on [Martin Fowler's article describing the 3]( https://martinfowler.com/articles/mocksArentStubs.html).

Seems like `@Incubating Mockito.spy( Class<?> clazz )` more or less does what I expect. Ultimately finding that behavior though required quite a bit of research.

Whether or not adding `Mockito.stub( Class<?> clazz )` method would be worth it I can't say because I don't feel like I'm familiar enough with the underlying implementation/behavior to know how different `mock` and `spy` are. If those are just configuration differences then it's probably worth it, if there's more to it, maybe not. If `stub` could `CALL_REAL_METHODS`, but only work for `abstract` and `interface` and not be able to do `verify` that would make it different from a `spy`, imo.

Either way, more docs seem necessary. I might try to put those together for #940  =||= I somehow missed this ticket. 

Mockito should imho follow the idea of defender methods and allow API-evolution without  breaking client code/test. I other words if a class under test evolves and calls defender methods on a mocked interface the tests should not fail or should not be rewritten by replacing `@Mock` with `@Spy` or setting up special mocking settings like `withSettings().useDefaultMethods()`.

I think it is possibe to rewrite the `mock(..)` implementation to generate stubbed calls to default methods  without special mock settings.  

```java
public <T> T mock(Class<T> type){
    T mock=MOCKITO_CORE.mock(type);
    if (!typeToMock.isInterface())
            return mock;

    for (Method method : typeToMock.getDeclaredMethods()) {
        if (method.isDefault()) {
            doCallRealMethod().when(mock);
            callWithAnyMatchers(mock, method);
        }
    }
    return mock;
}

private static void callWithAnyMatchers(Object mock, Method method) {
    Class<?>[] parameterTypes = method.getParameterTypes();
    List<Object> defaultValues = new ArrayList<Object>();
    for (Class<?> type : parameterTypes) {
            defaultValues.add(Mockito.any(type));
    }
    
    try {
        method.invoke(mock, defaultValues.toArray());
    } catch (Exception e) {
        throw new MockitoException(e.getMessage(), e);
    }
}


```
This way clients can redefine the defender stubbings like overriding it in an implementation. 

@bric3 
@szczepiq 
@fluentfuture 
What do you think?


 =||= Is it any different from API-evolution of abstract classes?

In template-method pattern, if the SUT calls an abstract method, and then later evolves to call a default method that indirectly calls the abstract method, the exact same problem can happen, no?

This kind of evolution has always been possible. And it's not clear to me that the user always means to only stub/verify the abstract method. Sometimes the user may just want to stub/verify the method directly called, abstract or not.

It seems to me not the mocking framework's responsibility to guess the user's intention. Instead, if the user wants to stub/verify the direct method invocation, use `@Mock;` while if the user wants to stub/verify abstract methods, use `@Spy`.

 =||= > Is it any different from API-evolution of abstract classes?
>
>In template-method pattern, if the SUT calls an abstract method, and then later evolves to call a default method that indirectly calls the abstract method, the exact same problem can happen, no?

I agree if you see it like that they are pretty equal.

I want to avoid that `@Spy` is misused to stub in the first place. The word ""spying"" implies that there is something to spy on (the SUT), but for interfaces the ""spying"" make no sense we would spy on a mocked interface. 

>It seems to me not the mocking framework's responsibility to guess the user's intention. 

I agree here too! What about a littel helper that create stubbings that call the real default method:  `Mockito.delegateDefaultMethodsToReal(mockedInterface)`
 =||= I still suggest `stub` as the method name for that per previous reasons cited =||= Did a bit of archeology. #106 has a discussion both about the API and the naming.

In that thread I argued against `spy`: ""All the use cases I know of for partial mocking don't need spying"". 

At the time ""stub"" wasn't suggested but now I think about it, it seems to make sense.

Although, changing it may mean to introduce a new `@Stub` annotation, and deprecate `@Spy AbstractClass`, if we are willing to consider the ship not sailed yet. =||= Interesting discussion! Thank you for all suggestions.

>the tests should not fail or should not be rewritten by replacing @Mock with @Spy or setting up special mocking settings like withSettings().useDefaultMethods().

You are right. Ideally the tests only fail when a bug is introduced.

I have a feeling the discussion is getting broader and I am not sure if still discusses the issue reported :) My immediate reaction to new `@Stub` interface and potential deprecation of `@Spy` is -1 because I don't see clear value. However, please formulate a separate ticket with the use case, code samples, and the team will for sure review it!

Coming back to the original issue: relaxing spy annotation for interfaces is useful for spying on interfaces with default methods. The use case is reasonable and team is +1 to the change. Do we have new data / use cases that indicate that this change inappropriate? =||= "Allow spying on interfaces so that it is convenient to work with Java 8 default methods"Fixes #680 "Ben Yufluentfuture02/28/17, 05:34:09 AM
960.0966Add editor configuration to ease the process of adhering to Checkstyle"We recently added the enforcement of Checkstyle. @ChristianSchwarz requested in https://github.com/mockito/mockito/pull/908#issuecomment-281468837 to also include a default template or at least provide steps for developers to automatically adhere to the style guide. E.g. no manual labor required, the IDE fixes it for the contributor.

We can probably adopt [EditorConfig](http://editorconfig.org/) which is automatically supported by IntelliJ and there is a plugin available for Eclipse users. There is even [support by GitHub themselves](https://github.com/editorconfig/editorconfig.github.com/pull/48)."Add editor config to automatically adhere to code style guide"I have personally tested this by adding additional whitespace, hitting save and then verify that `git diff` does not show any changes.

Fixes #960"Tim van der LippeTimvdLippe02/28/17, 12:39:48 PM
974.0979MockitoJUnitRunner.StrictStubs does not detect 'Unnecessary Stubbing' when inline mock maker is enabled"- mockito-core 2.7.13
- OpenJDK 1.8.0_121
- Ubuntu 16.10
- Enable `mock-maker-inline` (or use `mockito-inline` artifact)

If running the following test, 'Unnecessary Stubbing' is not detected.

```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    ArrayList<String> mock;

    @Test
    public void should_pass() {
        when(mock.get(0)).thenReturn(""foo"");
        assertEquals(""foo"", mock.get(0));
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.get(1)).thenReturn(""foo"");
    }

}
```

In the above code, 'Unnecessary Stubbing' is detected by changing ArrayList to List.
```java

    @Mock
//    ArrayList<String> mock;
    List<String> mock;

```

This problem does not occur with default mock maker.""This is working as intended. You should not mock Data classes such as `List`. The new mock maker is stricter in this regard as we could not ship another breaking change for the original mock maker.

We could add an explicit exception when we encounter these classes, instead of silently continueing. WDYT @raphw ? =||= I am sorry that my test case was bad.

The following test **passes** using inline mock maker.
This test does not use data classes.
```java
@RunWith(MockitoJUnitRunner.StrictStubs.class)
public class MockitoTest {

    @Mock
    C mock;

    @Test
    public void should_pass() {
        when(mock.doIt()).thenReturn(""foo"");
        assertEquals(""foo"", mock.doIt());
    }

    @Test
    public void should_detect_unnecessary_stubbing() {
        when(mock.doIt()).thenReturn(""foo"");
    }

    public static class C {
        public String doIt() {
            throw new UnsupportedOperationException();
        }
    }

}
```

Using default mock maker, this test **fails**.
This is the result that I expect.
```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected in test class: MockitoTest
Clean & maintainable test code requires zero unnecessary code.
Following stubbings are unnecessary (click to navigate to relevant line of code):
  1. -> at com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)
Please remove unnecessary stubbings or use 'silent' option. More info: javadoc for UnnecessaryStubbingException class.

	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:49)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:161)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:262)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:84)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
```

Does **new mock maker** mean **inline mock maker**?
According to the results of this test, inline mock maker seems to be less strict than default mock maker.
Sorry if I have misunderstood.
 =||= Ah that is a better testcase. Definitely a bug! =||= Just tested this on master and the result is the same for both mock makers where neither test detects the unneccessary stubbung. I do not know this part of Mockito too well but I assume there is a bug in this component. =||= I wrote a new test for this issue.

```java
public class StrictStubsRunnerByMockingAbstractClassTest {

    private final JUnitCore jUnitCore = new JUnitCore();

    @Test
    public void test_for_abstract_method_should_detect_unnecessary_stubbings() {
        runTest(ForAbstractMethod.class);
    }

    @Test
    public void test_for_concrete_method_should_detect_unnecessary_stubbings() {
        runTest(ForConcreteMethod.class);
    }

    private void runTest(Class<?> testClass) {
        Result result = jUnitCore.run(testClass);
        List<Failure> failures = result.getFailures();
        assertThat(failures.size(), equalTo(1));
        Failure failure = failures.get(0);
        assertThat(failure.getException(), instanceOf(UnnecessaryStubbingException.class));
    }

    static abstract class TestTarget {

        abstract String abstractMethod();

        String concreteMethod() {
            throw new UnsupportedOperationException();
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForAbstractMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
            mock.abstractMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.abstractMethod()).thenReturn("""");
        }

    }

    @RunWith(MockitoJUnitRunner.StrictStubs.class)
    public static class ForConcreteMethod {

        @Mock
        TestTarget mock;

        @Test
        public void correct_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
            mock.concreteMethod();
        }

        @Test
        public void unused_stubbing() {
            when(mock.concreteMethod()).thenReturn("""");
        }

    }

}
```

To test this test on the master, I put this into the following directory.
1. src/test/java/org/mockitousage/junitrunner (using the default mock maker)
1. inline/src/test/java/org/mockitoinline (using the inline mock maker)

In the first case, this test passed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :test --tests ""org.mockitousage.junitrunner.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:createTestResources
:compileTestJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:removeTestResources
:processTestResources UP-TO-DATE
:testClasses
:test

BUILD SUCCESSFUL

Total time: 5.707 secs
```

However, in the second case it failed.
```
$ ./gradlew -Dorg.gradle.parallel=false clean :inline:test --tests ""org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest""
Version: 2.7.14
:clean
:android:clean UP-TO-DATE
:extTest:clean UP-TO-DATE
:inline:clean
:testng:clean UP-TO-DATE
:compileJava
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
:copyMockMethodDispatcher
:processResources UP-TO-DATE
:classes
:jar
:inline:compileJava UP-TO-DATE
:inline:processResources
:inline:classes
:inline:compileTestJava
:inline:processTestResources UP-TO-DATE
:inline:testClasses
:inline:test

org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest > test_for_concrete_method_should_detect_unnecessary_stubbings FAILED
    java.lang.AssertionError: 
    Expected: <1>
         but: was <0>
        at org.hamcrest.MatcherAssert.assertThat(MatcherAssert.java:20)
        at org.junit.Assert.assertThat(Assert.java:956)
        at org.junit.Assert.assertThat(Assert.java:923)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.runTest(StrictStubsRunnerByMockingAbstractClassTest.java:36)
        at org.mockitoinline.StrictStubsRunnerByMockingAbstractClassTest.test_for_concrete_method_should_detect_unnecessary_stubbings(StrictStubsRunnerByMockingAbstractClassTest.java:30)

2 tests completed, 1 failed
:inline:test FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':inline:test'.
> There were failing tests. See the report at: file:///home/tmura/IdeaProjects/mockito/subprojects/inline/build/reports/tests/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED

Total time: 3.505 secs

```

For the abstract method, 'Unnecessary Stubbing' was detected correctly, but it did not detected for the concrete method.
 =||= I thnk I have found the cause of this problem.
When using the inline mock maker, it seems that LocationImpl cannot get the stubbed location of the concrete method correctly.

`UnusedStubbingFinder` which detects 'Unnecessary stubbing' calls `LocationImpl#toString()` to get the stabbed location.

The code below is the implementation of `LocationImpl#toString()`.
```java
StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);
if (filtered.length == 0) {
    return ""-> at <<unknown line>>"";
}
return ""-> at "" + filtered[0].toString();
```

This method filters the stack trace elements of `stackTraceHolder` to get the location.
`stackTraceHolder` is a Throwable object that is created in the constructor of `LocationImpl`.

The stack trace elements of this object are as follows:

- Stubbing the concrete method with the default mock maker
```
0 = {StackTraceElement@1679} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1680} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1681} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1682} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1683} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptSuperCallable(MockMethodInterceptor.java:102)""
5 = {StackTraceElement@1684} ""com.example.MockitoTest$C$MockitoMock$648066763.doIt(Unknown Source)""
6 = {StackTraceElement@1685} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the abstract method with the inline mock maker
```
0 = {StackTraceElement@2201} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@2202} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@2203} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@2204} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@2205} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:120)""
5 = {StackTraceElement@2206} ""com.example.MockitoTest$C$MockitoMock$1683798279.doIt(Unknown Source)""
6 = {StackTraceElement@2207} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

- Stubbing the concrete method with the inline mock maker
```
0 = {StackTraceElement@1927} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:23)""
1 = {StackTraceElement@1928} ""org.mockito.internal.debugging.LocationImpl.<init>(LocationImpl.java:18)""
2 = {StackTraceElement@1929} ""org.mockito.internal.creation.bytebuddy.InterceptedInvocation.<init>(InterceptedInvocation.java:52)""
3 = {StackTraceElement@1930} ""org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:41)""
4 = {StackTraceElement@1931} ""org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handle(MockMethodAdvice.java:76)""
5 = {StackTraceElement@1932} ""com.example.MockitoTest$C.doIt(MockitoTest.java:30)""
6 = {StackTraceElement@1933} ""com.example.MockitoTest.should_detect_unnecessary_stubbing(MockitoTest.java:25)""
```

The resulting location should be `#6`, but in the last case it is `#5`.
Because `stackTraceFilter` does not exclude `#5`.
 =||= Yes, this is expected. The inline mock maker inlines the code and does therefore not add a stack frame. This is a bug in the `UnusedStubbingFinder` which should not rely on the stack shape.

@TimvdLippe Do you have time to look at this? =||= Thank you guys for really thorough debugging!

>This is a bug in the UnusedStubbingFinder which should not rely on the stack shape.

There is a reason why the finder relies on the String representation of line where the unused stub is declared. I documented it in the [Javadoc](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java#L46), hopefully it is more less clear :) I'm not saying we should keep the current implementation, I'm ok changing it, I just wanted to give more data points.

After reading this thread my gut feel tells me that the stack trace filter (different component than unused stubbing detection) may not be coping well with inline mocking. This could also have impact on stack trace filtering in general for inline mocking, the quality of exception messages, etc.

@tmurakami, you made fantastic debugging effort to nail down the problem. Can you investigate if stack trace filter needs adapting for inline mocking and potentially submit a PR? =||= With the stack trace filter, I actually did change the implementation to adjust this behavior such that it works. I was not aware that the stubbing finder replicated something similar. =||= @szczepiq, @raphw, I can submit the PR, but this problem seems to have already been fixed by @raphw.
Should I submit the PR?
 =||= Please submit, I only fixed the issue partially. =||= "Fixes #974: Fix to get correct stubbing location with inline mocking"- Fix StackTraceFilter to support inline mocking
- Add one test to StackTraceFilterTest
- Add StubbingLocationTest into inline subproject

This PR fixes #974."Tsuyoshi Murakamitmurakami03/19/17, 05:40:43 PM
982.0983Break cyclical compile time dependency on hideRecursiveCall"I am working on upgrading the version of mockito in AOSP to 2.7.13 using byte buddy and byte buddy android rather than dexmaker.

As part of that I need to exclude a number of classes which will not compile on Android because it does not support Java agents/instrumentation. The mockito code has always been very well organized and made that very simple to do but in the latest version I found a minor issue.

The files I need to exclude are:
- src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
- src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
- src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java

Unfortunately, when I do that I get a compile error because MockMethodAdvice is trying to use hideRecursiveCall from InlineByteBuddyMockMaker. I looked at the code and it seems as though InlineByteBuddyMockMaker depends on InlineBytecodeGenerator which depends on MockMethodAdvice which depends on hideRecursiveCall from InlineByteBuddyMockMaker.

The only places that actually use hideRecursiveCall are MockMethodAdvice and InlineByteBuddyMockMakerTest. That depends on InlineByteBuddyMockMaker which depends on InlineBytecodeGenerator which depends on MockMethodAdvice which depends on hideRecursiveCall from InlineByteBuddyMockMaker.

So, moving hideRecursiveCall from InlineByteBuddyMockMaker to MockMethodAdvice breaks a dependency cycle and allows the InlineByteBuddyMockMaker.java file to be excluded without problem. Also, MockMethodAdvice seems to be a better place for it.

If you are happy with this proposal or can suggest a better place for hideRecursiveCall then I am happy to submit a fix for this.""That seems like a reasonable issue. Looking forward to your pull request @paulduffin ! =||= Should I make the change in release/2.x?

On 8 March 2017 at 12:57, Tim van der Lippe <notifications@github.com>
wrote:

> That seems like a reasonable issue. Looking forward to your pull request
> @paulduffin <https://github.com/paulduffin> !
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/982#issuecomment-285033757>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AEtcQ-KnL90mWa9jxuLBhEsA8QmxpSJzks5rjqXXgaJpZM4MWrIj>
> .
>
 =||= Yes please :) =||= Done. =||= "Break cyclical compile time dependency on hideRecursiveCallFixes #982.paulduffin03/09/17, 11:56:44 AM
981.0985Update documentation about mockito-inline artifact"Mockito documentation currently does not explain ""mockito-inline"" artifact that is used for inline mocking (mocking finals). The main Mockito class still contains information on how to configure the inline mocking using a classpath resource."Fixes #981: Update Javadoc about the 'mockito-inline' artifact"This PR fixes #981.

In the Javadoc, I write that the first version of `mockito-inline` is `2.7.6`.
This artifact was actually offered in version `2.7.2`, but `2.7.5` or earlier it did not work due to the issue #929, so I write like that."Tsuyoshi Murakamitmurakami03/10/17, 11:52:38 AM
989.0995Misleading behavior of Mockito.verifyZeroInteractions()"## Problem

Mockito.verifyZeroInteractions() actually does not do what it advertises. The purpose of this ticket is to discuss whether to change the behavior of this method in Mockito 3.

## Details

Based on user feedback at #977, from @ffissore, ""verifyZeroInteractions"" API can be misleading. When you read that method in test code, you expect zero interactions with specified mocks. However, ""verifyZeroInteractions"" is only an alias to ""verifyNoMoreInteractions"" and in fact, it **does not** guarantee that there were zero interactions. Let's use examples to illustrate the problem

## Feedback needed

Please comment / vote / state your opinion about changing the behavior of ""verifyZeroInteractions"" so that it actually ensures that there were **zero** interactions with the mock (regardless if previously verified or not).

## Examples

Below examples illustrate current behavior of Mockito 2.x, in case you are puzzled what this ticket is about.

Example 1 - verifyNoMoreInteractions

```java
mock.foo();
verify(mock).foo();
verifyNoMoreInteractions(mock); //pretty clear I think
```

Example 2 - verifyZeroInteractions

```java
mock.foo();
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
//and we already have verified the only method invoked on the mock
```

Example 3 - verifyZeroInteractions with regular stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
```

Example 4 - verifyZeroInteractions with new strict stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());

verifyZeroInteractions(mock);
//above passes because with strict stubbing
//stubbed method are implicitly verified when they are ""used""
//this is one of key features of strict stubbing (DRY, don't repeat yourself)
```"This was fixed in #989 =||= verifyZeroInteractions guarantees zero interactions instead of just delegating to verifyNoMoreInteractions"Fixes #989

`verifyZeroInteractions` no longer delegates to `verifyNoMoreInteractions`
Instead, it fetches the number of invocations made to the mock and checks if
they are zero, failing otherwise

I'm not sure if the style of my code complies with mockito: please let me know what to change and where to look to make it more mockitoish"Federico Fissoreffissore05/10/17, 07:34:33 AM
991.01016Add BaseArgumentMatcher to ease migration from pre 2.x"Pre 2.x ArgumentMatcher was a class that provided a default
implementation of describeTo(Description). The new
BaseArgumentMatcher class provides an equivalent implementation
of toString() making it easier for pre 2.x code that did not
override the describeTo(Description) method to be migrated.""I am currently working on migrating Android code to use mockito 2.7.13. We have a lot of implementations of ArgumentMatcher that relied on the default implementation of describeTo(Description) provided by the 1.10.19 ArgumentMatcher class which is not provided by the 2.x ArgumentMatcher interface (no default methods yet). This new class will aid in that migration. =||= # [Codecov](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=h1) Report
> Merging [#991](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=desc) into [release/2.x](https://codecov.io/gh/mockito/mockito/commit/9b98d71fa2444b0ebc35265d79458e5432cb5396?src=pr&el=desc) will **not change** coverage.
> The diff coverage is `n/a`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/991/graphs/tree.svg?height=150&width=650&token=MX80sLdeR0&src=pr)](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=tree)

```diff
@@              Coverage Diff               @@
##             release/2.x     #991   +/-   ##
==============================================
  Coverage          86.86%   86.86%           
  Complexity          2290     2290           
==============================================
  Files                287      287           
  Lines               5801     5801           
  Branches             684      684           
==============================================
  Hits                5039     5039           
  Misses               571      571           
  Partials             191      191
```



------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=footer). Last update [9b98d71...5ebb567](https://codecov.io/gh/mockito/mockito/pull/991?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments). =||= I am all for ease of migration, glad you are using Mockito in your Android project! Is there a particular reason it was not possible to create this class in your project and extend from there? Or did you do so, but you would like to upstream it for other developers? =||= You misunderstand me, it is not an Android project, it is Android itself, i.e. AOSP.

We have a local patch to mockito that adds a compatibility class and we would rather not maintain a local class and it just seems like something that other people moving to 2.x might appreciate. =||= Ah oke, all makes sense! This would be fine by me :) =||= This is really nice improvement and I like the use case it solves. Thank you!

1. Before we merge it, I'd like us to discuss high level design
 - is this matcher implementation useful outside of the context of 2.x migration? I suspect it is. If that's the case, we need to surface this new implementation in Javadoc in other places
 - can we come up with a solution that does not require base class? Base classes are less convenient to work with and make the API slightly more complicated. They also need more documentation because users have 2 alternatives - use the interface of the base method. Can we detect if matcher has custom toString() in runtime? If so, we could use decamelized class name automatically if the instance does not have custom toString()
 - let's mark this API incubating in case we want to experiment with the idea I mentioned earlier

2. Feedback about the implementation
 - there are no tests
 - Javadoc needs to be updated in other places, too (some examples: ArgumentMatcher, argThat method, etc). Otherwise this class will be very hard to discover and users would not use it.
 - there is no @since tag
 - otherwise, nice & clean implementation. Thank you for neat javadocs and code comments!!! =||=    1. Ok
      - Yes it is useful outside of 2.x migration, at least as useful as
      the old ArgumentMatcher was.
      - I suppose that you could use reflection to detect whether the class
      has overridden the toString() method but that seems like quite a
      heavyweight solution. It would not work for any implementations that
      override and call super.toString(), e.g. to add additional information to
      the default implementation. If you targeted Java 8 I would say
that default
      method would be a better solution.
      - I am not quite sure what incubating means but that is fine with me.
      2. It was a quick proof of concept to illustrate what I was thinking
   not intended to be submitted as is.
      - Ok.
      - Can you give me a definitive list of the places to update and
      suggestions as to what to add to each? I find that otherwise we end up
      going backwards and forwards as I try and guess what you want.
      - Ok.
      - Thanks.


On 17 March 2017 at 17:25, Szczepan Faber <notifications@github.com> wrote:

> This is really nice improvement and I like the use case it solves. Thank
> you!
>
>    1. Before we merge it, I'd like us to discuss high level design
>
>
>    - is this matcher implementation useful outside of the context of 2.x
>    migration? I suspect it is. If that's the case, we need to surface this new
>    implementation in Javadoc in other places
>    - can we come up with a solution that does not require base class?
>    Base classes are less convenient to work with and make the API slightly
>    more complicated. They also need more documentation because users have 2
>    alternatives - use the interface of the base method. Can we detect if
>    matcher has custom toString() in runtime? If so, we could use decamelized
>    class name automatically if the instance does not have custom toString()
>    - let's mark this API incubating in case we want to experiment with
>    the idea I mentioned earlier
>
>
>    1. Feedback about the implementation
>
>
>    - there are no tests
>    - Javadoc needs to be updated in other places, too (some examples:
>    ArgumentMatcher, argThat method, etc). Otherwise this class will be very
>    hard to discover and users would not use it.
>    - there is no @since <https://github.com/since> tag
>    - otherwise, nice & clean implementation. Thank you for neat javadocs
>    and code comments!!!
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/pull/991#issuecomment-287418708>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AEtcQ3_gVd-VoUNKmMsJUErwhN5cl6LVks5rmsIDgaJpZM4MgxWG>
> .
>
 =||= You can denote this class as incubating by adding `@Incubating` to the declaration.

I would go for the following mentions:
- Let's mention this class in [this list](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/ArgumentMatcher.java#L16)
- Let's mention this class in [2.1.0 migration guide](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/ArgumentMatcher.java#L88)

That should be sufficient for now. This class is merely for ease of migration, I think we should discourage its usage if the user can afford to do so. =||= I think I have messed up this PR. I usually work in Gerrit and it is better there to do an amend and a force push. Let me know what you want me to do. I am happy to close this off and do a new PR. =||= @szczepiq you asked about whether the toString() method is needed and whether the default behavior could be provided separately. I just found out that it already is in org.mockito.internal.matchers.text.MatcherToString. It traverses the class hierarchy looking for a toString() method and if it cannot find one then it defaults to the decamelizer form.

As a result I have removed the toString() implementation in BaseArgumentMatcher. That means it provides little benefit for anything other than migration. Based on that I think it would be much better if these classes were in a separate package and maybe even in their own compat subproject. =||= I improved the testing of BaseArgumentMatcher and found a problem with my previous type safe matching mechanism, fixing it made it a lot more complicated so I junked it and refactored TypeSafeMatching class to allow me to reuse it with BaseArgumentMatcher in order to provide similar capabilities. =||= Oof this is getting out of hand pretty quickly :O We have to see if we can make this compatibility matcher easily, without modifying too much in core. =||= Wow, thank you for trying to close down this use case!

Given that it's getting complicated we can choose to document this use case on a wiki, with a code sample to drop to the code. This is an edge case for incremental migrations for some users, so perhaps it does not have to be part of the main code? If you all +1 to include it in the code I suggest to make it really explicit in the API for clarity (use 'org.mockito.migration' package, call the matcher: MockitoV1CompatibilityMatcher, perhaps make it deprecated so that it's clear that users should not use it forever ;).

I'm +1 to keep the API small, avoid adding the matcher and document the migration path on the wiki. We can link to that wiki from the javadoc. =||= @szczepiq, @TimvdLippe 

Ok, so change the name and package to make it clearer, to 'org.mockito.migration.MockitoV1CompatibilityMatcher'? Is that name acceptable to both of you?

Tim, would you prefer that I keep these changes completely isolated from the main code? That would involve duplicating a little bit of the code but I am happy to do that.

That raises the next question what about packaging? Should I add a subproject called migration into which I add this code? That would isolate it even more.

I was planning on adding the ErrorProne checks that will help automate migration to an errorProne subproject. =||= As a Mockito maintainer, my main goal is easy upgrades for our users. Your contribution helps greatly with that! However, it seems that integrating it is more difficult than anticipated. Therefore  little duplication sounds better to me, than the extra changes in core.

I think a separate package is very good for this, as it signals to our users that the implementation is for migration only. We can add this to the package-info for example.

So all in all, if we can find a solution that is minimal, yet greatly improves the usability of the library: yes please. I think we are close with this PR, but some minor tweaks are required to keep the codebase as nice as it is now ;) =||= Do you want me to put this in a subproject? e.g. subproject/migration? If so presumably it will have its own artifact as well. =||= If you can do that without spending too much time/resources, I would be :+1: to that! =||= I will need to backport this to a branch based off 1.10.19. Anyone upgrading from 1.10.19 would first get the 1.10.20 (or 1.10.19-migration) version which would contain a version of MockitoV1CompatibilityMatcher that they could extend instead of extending ArgumentMatcher directly. Could you create a new 1.10.x-migration branch that I could send some pull requests to?

FYI. I just found out that I have a load of code that depends on 1.9.5 so I will be looking at doing something similar to allow easy upgrading from 1.9.5 to 1.10.19. =||= Oh and to keep it simple, you can probably copy your (great!) commit message in the documentation. That should be sufficient to inform other users. =||= @paulduffin I think you can close this PR and we need to cherry-pick your release/1.x commit to release/2.x, right? =||= The cherry pick won't work I will still need 2.x specific patches. However, if you want me to cherry pick from 1.x and then add the necessary changes on top as a separate commit and then create a pull request I would be happy to do that. =||= @paulduffin so if I understand you correctly, this PR can be merged as-is and we need to publish the 1.x artifact from the current `release/1.x` branch? =||= It could yes. I still have some changes that I need to make, error prone checkers/fixers to add but if you want to publish then feel free. =||= It's been some time since we reviewed this PR :) What is the current status? @paulduffin, is the PR ready to go based on your understanding of the status? =||= I am currently working with the error prone team to get some changes into
Error Prone to make it work better with open source code. I am also working
on Error Prone checks for detecting common problems with Mockito as well as
to aid in migration. I have not forgotten about this work, there is still
quite a lot to be done.

On 20 May 2017 at 20:43, Szczepan Faber <notifications@github.com> wrote:

> It's been some time since we reviewed this PR :) What is the current
> status? @paulduffin <https://github.com/paulduffin>, is the PR ready to
> go based on your understanding of the status?
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/pull/991#issuecomment-302894482>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AEtcQ0ZSlKC-FxQfuIAOAS7JjqJq-3Xnks5r70JsgaJpZM4MgxWG>
> .
>
 =||= I am closing this right now as we are not going to land this for 2.x. We will provide a better migration path for future breaking changes. =||= "Fixes #991: Backport MockitoV1CompatibilityMatcher from 2.x to aid in…"Fixes #991: Backport MockitoV1CompatibilityMatcher from 2.x to aid in migration to 2.x

The 2.x version of ArgumentMatcher<T> differs quite
significantly from the current version:
1) It is an interface not a class and no longer extends
   org.hamcrest.Matcher.
2) Its main method is matches(T) not matches(Object).
3) It uses the toString() method to construct a description and
   not the describeTo(Description) method.

This class supports the following strategy for migrating
implementations of ArgumentMatcher from 1.10.19 to 2.x:
1) First migrate to a 1.x version that has
   MockitoV1CompatibilityMatcher change in it. That should be
   relatively simple.
2) Then modify all existing implementation of ArgumentMatcher
   to extend MockitoV1CompatibilityMatcher.
3) Switch to use a version of 2.x that contains this change.
   Everything should compile as usual.
4) Modify the classes that extend MockitoV1CompatibilityMatcher
   to implement ArgumentMatcher interface directly.

The above strategy is overkill when migrating a small project
that can be updated atomically but it has proven to be a good
approach when upgrading a large project spread across multiple
git repositories. This is added in part because of the
experience doing exactly that with the Android Open Source
Platform.

check list

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/2.x/.github/CONTRIBUTING.md)
 - [ x PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_"paulduffin04/04/17, 09:27:31 PM
1071.01076Mockito AdditionalAnswers.returnsFirstArg() doesn't work with generic first arg"_Issue concerning [this stackoverflow question](http://stackoverflow.com/questions/30670275/mockito-returnsfirstarg-doesnt-work-with-generic-first-arg).
I've checked it's not working both Mockito 1.x and 2.x._


-------------------



I'm trying to mock the typed method `getNameElement` of Interface `RoomGeneralService` to return the first arg, using Mockito `AdditionalAnswers.returnsFirstArg` functionality:

**Interface to mock**:

    interface PrimaryKeyElement<T> {
       public String getNameElement(T primaryKey);
    }

    interface RoomGeneralService extends PrimaryKeyElement<String> {
       // ...
    }

**My test** (note the imports)

    import static org.mockito.AdditionalAnswers.returnsFirstArg;
    import static org.mockito.Matchers.any;
    import static org.mockito.Matchers.anyString;
    import static org.mockito.Mockito.when;
    import org.mockito.runners.MockitoJUnitRunner;
    
    @RunWith(MockitoJUnitRunner.class)
    public class SampleTest {
    
       @Mock
       RoomGeneralService roomGeneralService;
    
       @Test
       public void testFoo() throws Exception {
          when(roomGeneralService.getNameElement(anyString())).thenAnswer(returnsFirstArg());
          //...
       }
    }

Also I've tried with other combinations, but without success so far:

    when(roomGeneralService.getNameElement(Matchers.<String>any())).thenAnswer(returnsFirstArg());
    doAnswer(returnsFirstArg()).when(roomGeneralService.getNameElement(anyString()));
    doReturn(returnsFirstArg()).when(roomGeneralService.getNameElement(anyString()));

**Error received**:

> The reason for this error can be :
> 1. The wanted argument position is incorrect.
> 2. The answer is used on the wrong interaction.
> 
> Position of the wanted argument is 0 and the possible argument indexes
> for this method are :
>     [0] Object

**Workaround**:

I know I can create my own answer, and in fact it's working fine if instead of use `returnFirstArg()` I do something like this:

    when(roomGeneralService.getNameElement(anyString())).thenAnswer(new Answer<String>() {
       @Override
       public String answer(InvocationOnMock invocation) throws Throwable {
          return (String) invocation.getArguments()[0];
       }
    });

But I would use `returnFirstArg()` as in the rest of my tests (tests look cleaner), as well as mocking is working fine if the method `getNameElement` would receive an `String` instead a `T` arg.

Thanks for the help.""@troig Mockito checks if the argument type is compatible with the return type to make a misuse ot the API as soon as posible visible.  In this case the argument-type Object is inferred from the generic type T, due to type erasure. Since Object is not a subtype of String Mockito throws the exception you see.

Solution: The issue can by fixed by inferring the argument-type of the actual argument-instance.
 In case the argument-type is a primitive or the arg is null Mockito must fallback and use the type provided by method signature. 

I have a solution ~~that currently doesn't work due to regressions introduced with #1032 (vararg-expansion is broken)~~.
 =||= Thanks @ChristianSchwarz for you quick answer! =||= "Fixed validation in returnArgumentAt(int) in case of type erasure on the parameter"Fixes #1071 

The parameter type inference takes now the type of the actual instance
into account to avoid type erasure issues in case the parameter is
generic.

see also: https://github.com/mockito/mockito/issues/1071#issuecomment-300091021"Christian SchwarzChristianSchwarz05/10/17, 06:03:03 PM
1107.01109No release build for 2.8.39 - possible bug in Travis CI"For some reason, Travis CI did not trigger the main build for version 2.8.39. In the travis dashboard for that build I can see only [3 child jobs](https://travis-ci.org/mockito/mockito/builds/237813636) whereas normally there are [4 child jobs](https://travis-ci.org/mockito/mockito/builds/237433149).

@szpak, have you seen something like that before? I'm restarting the build, let's see what happens :)""No, I haven't seen anything like that before. There were no changes in .travis.yml and I have no idea what one of the jobs is missing. Probably (I hope) it will be automatically fixed by the next commit. It may be good to report it to Travis. =||= Just merged another PR, will see how many child jobs Travis triggers this time :) =||= Another instance of this problem. I've contacted Travis CI support, put you guys on cc. =||= Commented on the ticket in Travis issue tracker (https://github.com/travis-ci/travis-ci/issues/4681#issuecomment-306102865). Here's the message from Travis CI support:

```
Thanks for reaching out and I'm sorry for this change in behavior.

This is the result of a change we released 3 days ago and it's detailed here: https://github.com/travis-ci/travis-ci/issues/4681. In brief, if you have no matrix expansion on the top level, and there is at least one job defined in `matrix.include`, the top level job is no longer included in the build matrix.

You should be able to get your old build configuration back by adding the following under `matrix.include`:


matrix:
  include:
  - jdk: oraclejdk7
  - jdk: oraclejdk7
    env: SKIP_RELEASE=true MOCK_MAKER=mock-maker-inline
  ⋮
```

I'm trying it now ;) =||= "Fixed Travis configuration for matrix build"Travis CI introduced a good change that unfortunately is slightly backwards incompatible.
This change to configuration file fixes our Travis configuration for updated Travis behavior wrt matrix builds.
More info, in the GitHub ticket

Fixes #1107"Szczepan Fabermockitoguy06/05/17, 07:55:36 AM
1127.01129Version not released to Maven Central"2 days ago I requested a [build](https://github.com/mockito/mockito/commit/04961ae3cc8093916f563d7edc223224d757a4a1) with Maven Central sync (having notable changes merged). Looking into release configuration I used `[ci maven-central-release]` and it seems to be [enabled](https://travis-ci.org/mockito/mockito/jobs/242215132#L842) in Travis.

However, that release is not [available](https://maven-badges.herokuapp.com/maven-central/org.mockito/mockito-core) in Maven Central (2.8.9 is the newest as time of raising this issue instead of 2.8.44).

@szczepiq Is there anything else (with the current release mechanism) that is needed to do to build a ""notable version""?""I think we need to set a property on our project, looking at the line above in the Travis build you linked: 
```
project property 'maven-central-release' exists: false
``` =||= Looking! Thank you for reporting! =||= Great bug report guys! It was very easy to nail down the issue! =||= Please review / merge: https://github.com/mockito/mockito/pull/1129 =||= Worked perfectly - https://repo1.maven.org/maven2/org/mockito/mockito-core/2.8.47/ =||= "Fixed issue with releases to Maven Central"After 1.0 release of Shipkit we need to figure out how to model this conditional release.
This bug leads me to believe that we need to eliminate this logic from Mockito.
This way it can be a part of Shipkit and be well tested & documented.

Fixes #1127

Tested by running command: ```./gradlew bintrayUpload -Pmaven-central-release -Pshipkit.dryRun```

The output was (note the ""Maven Central sync: true""):
```
:bintrayUpload - publishing to Bintray
  - dry run: true, version: 2.8.44, Maven Central sync: true
  - user/org: szczepiq/mockito, repository/package: maven/mockito
```

Thank you for reporting and the initial debugging that helped me resolve it quickly.

PS. I wished build.gradle was in Kotlin, this error would not be possible ;)"Szczepan Fabermockitoguy06/15/17, 03:41:29 PM
1180.01186Stubbing superclass' method using Mockito inline propagate to the real method call"Hi my java env is 
```
java version ""1.8.0_74""
Java(TM) SE Runtime Environment (build 1.8.0_74-b02)
Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)
```
OS Version
`MacOS Sierra 10.12.6`

Mockito version: 
`mockito-inline:2.9.0`

For this simple snippet:
```
    public class StringList extends ArrayList<String>{

    }
```
then stubbing the size() method
```
StringList stringList = mock(StringList.class);
doReturn(10).when(stringList).size();

```
stringList.size() will always return 0, and size() is acually called in ArrayList instread of the stub
the above code works perfectly with mockito-core, for a workaround, StringList can be written in 
```
    public class StringList extends ArrayList<String>{
        @Override
        public int size(){
            return 0;
        }
    }
```
then size() can be stubbed.
I only need mockito inline to mock a single final class in one test case, but mockito-inline took over my entire module's unit tesst, I'm wondering if there's a way to choose mockito-core or inline for each test?

and I'm not sure if this is related, if stub in this way
` when(stringList.size()).thenReturn(11);`
Mockito reports

> org.mockito.exceptions.misusing.MissingMethodInvocationException: 
> when() requires an argument which has to be 'a method call on a mock'.
> For example:
>     when(mock.getArticles()).thenReturn(articles);
> 
> Also, this error might show up because:
> 1. you stub either of: final/private/equals()/hashCode() methods.
>    Those methods *cannot* be stubbed/verified.
>    Mocking methods declared on non-public parent classes is not supported.
> 2. inside when() you don't call method on mock but on some other object.

""If I am not mistaken we explicitly disallow mocking of such Data classes.
If you need to stub a list, then just create a list with the value you
expect. For more information see
https://github.com/mockito/mockito/wiki/How-to-write-good-tests#dont-mock-value-objects

On Wed, 30 Aug 2017, 07:49 Hu Yao <notifications@github.com> wrote:

> Hi my java env is
>
> java version ""1.8.0_74""
> Java(TM) SE Runtime Environment (build 1.8.0_74-b02)
> Java HotSpot(TM) 64-Bit Server VM (build 25.74-b02, mixed mode)
>
> OS Version
> MacOS Sierra 10.12.6
>
> Mockito version:
> mockito-inline:2.9.0
>
> For this simple snippet:
>
>     public class StringList extends ArrayList<String>{
>
>     }
>
> then stubbing the size() method
>
> StringList stringList = mock(StringList.class);
> doReturn(10).when(stringList).size();
>
>
> stringList.size() will always return 0, and size() is acually called in
> ArrayList instread of the stub
> the above code works perfectly with mockito-core, for a workaround,
> StringList can be written in
>
>     public class StringList extends ArrayList<String>{
>         @Override
>         public int size(){
>             return 0;
>         }
>     }
>
> then size() can be stubbed.
> I only need mockito inline to mock a single final class in one test case,
> but mockito-inline took over my entire module's unit tesst, I'm wondering
> if there's a way to choose mockito-core or inline for each test?
>
> and I'm not sure if this is related, if stub in this way
> when(stringList.size()).thenReturn(11);
> Mockito reports
>
> org.mockito.exceptions.misusing.MissingMethodInvocationException:
> when() requires an argument which has to be 'a method call on a mock'.
> For example:
> when(mock.getArticles()).thenReturn(articles);
>
> Also, this error might show up because:
>
>    1. you stub either of: final/private/equals()/hashCode() methods.
>    Those methods *cannot* be stubbed/verified.
>    Mocking methods declared on non-public parent classes is not supported.
>    2. inside when() you don't call method on mock but on some other
>    object.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1180>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb0hKkSOylN62U_1YZ8p5KRQWf8-vks5sdXZagaJpZM4PHgWw>
> .
>
 =||= @TimvdLippe sorry I didn't intend to mock List, I happened to use the List as a simple example, this case happens when mocking superclass' method which is not overridden in child class. =||= This seems to be a regression in version 2.9.0 with `mock-maker-inline`. In our code base we hit the issue with some code that mocks Elasticsearch 2.3.5's [`DeleteRequestBuilder`](https://github.com/elastic/elasticsearch/blob/v2.3.5/core/src/main/java/org/elasticsearch/action/delete/DeleteRequestBuilder.java). Simplified example:
```java
DeleteRequestBuilder b = mock(DeleteRequestBuilder.class);
assertNull(b.get());
```
This passes with Mockito 2.8.47, but causes an NPE with Mockito 2.9.0, because the ""real"" method is invoked:
```
java.lang.NullPointerException
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:86)
	at org.elasticsearch.action.ActionRequestBuilder.execute(ActionRequestBuilder.java:56)
	at org.elasticsearch.action.ActionRequestBuilder.get(ActionRequestBuilder.java:64)
```

CC @raphw since the issue only happens when `mock-maker-inline` is enabled.  =||= I found the error which lies in the new bridge method sensitive override detection mechanism. I added a test case and hope everything works again in the new version. =||= I fixed this in #1179, please reopen the issue if it is not resolved. =||= Hi @raphw, I just built and installed 1c61f1a91a7d5d8367b3dbddb6270afdd96c8f6a using `./gradlew publishToMavenLocal`. The above issue still reproduces, unfortunately. =||= Darn, I reproduced the issue as a test case but I assume it was insufficient to capture the full problem.

Thanks for double-checking, I will hav another look.

PS: You did build the release 2.x branch? Alternatively, the build should be released by now. =||= Ah, I just double-checked and it seems like the actual fix got lost in git rebase. I will fix this tonight! =||= New try! =||= Thanks! Just built `v2.9.2` locally and I can confirm the issue is fixed. :white_check_mark: 

Dare I ask: since this release resolves a regression, do you plan to publish it on Maven Central? =||= Should be published automatically. @szczepiq? =||= Nah, by default they only go to Bintray. (I can configure our Nexus to proxy to Bintray, but I prefer to keep the number of non-Maven Central hosted dependencies as small as possible. Also, by publishing on Maven Central a larger audience will find the fix using the `versions-maven-plugin`.) =||= >Should be published automatically. @szczepiq?

We currently don't publish automatically to Maven Central based on the feedback from community that there are too many versions of Mockito around :) We might get back to publishing every version as we did before.

I plan to ship 2.10 soon for https://github.com/mockito/mockito/pull/1121 so it will land in Maven Central! =||= "Compare method of graph to defined form of method.Fixes #1180: Compare against non-generic method when deciding if a method should be stubbed.Rafael Winterhalterraphw09/05/17, 07:02:55 PM
977.01199Misleading documentation of verifyZeroInteractions"## Problem

The current behavior of verifyZeroInteractions can be misleading, see the #989.

In current version of Mockito (2.x), we can improve the javadoc for verifyZeroInteractions to clearly describe how it works (and mention the behavior of strict stubs, too).

Please contribute!

## Original report

Original issue reported by @ffissore:

According to the [docs](http://static.javadoc.io/org.mockito/mockito-core/2.7.13/org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)) `verifyZeroInteractions` is like `verify(mock, never()).method()` when the mock has only one method.

The tests below should both raise an exception. Instead, `testVerifyZeroInteractions` raises none and fails

```java
package test;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.exceptions.verification.NeverWantedButInvoked;
import org.mockito.exceptions.verification.NoInteractionsWanted;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
import org.mockito.quality.Strictness;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.*;

public class MockitoTest {

   private static class Collaborator {

      public String doStuff(int number) {
         throw new RuntimeException();
      }

   }

   private static class Container {

      private final Collaborator collaborator;

      public Container(Collaborator collaborator) {
         this.collaborator = collaborator;
      }

      public String doStuff(int number) {
         return collaborator.doStuff(number);
      }

   }


   @Rule
   public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

   @Mock
   private Collaborator collaborator;

   @Before
   public void setUp() throws Exception {
      MockitoAnnotations.initMocks(this);
   }

   // passes
   @Test(expected = NeverWantedButInvoked.class)
   public void testVerifyNever() throws Exception {
      Container container = new Container(collaborator);
      when(collaborator.doStuff(42)).thenReturn(""yeah"");

      String output = container.doStuff(42);
      assertEquals(""yeah"", output);

      verify(collaborator, never()).doStuff(42);
   }

   // fails
   @Test(expected = NoInteractionsWanted.class)
   public void testVerifyZeroInteractions() throws Exception {
      Container container = new Container(collaborator);
      when(collaborator.doStuff(42)).thenReturn(""yeah"");

      String output = container.doStuff(42);
      assertEquals(""yeah"", output);

      verifyZeroInteractions(collaborator);
   }
}
```""Forgot to say: I'm using version 2.7.13 =||= Looking into it... =||= Thank you for reporting and your patience waiting for the reply!!!

It's a really good report - I was able to reproduce the problem easily. Also, THANKS a lot for using strict stubbing - I'm really happy to see it in use!

At the moment, ""verifyZeroInteractions"" is an alias to ""verifyNoMoreInteractions"", intended to be used to improve readability of tests. Let me illustrate it on a couple of examples:

Example 1 - verifyNoMoreInteractions

```java
mock.foo();
verify(mock).foo();
verifyNoMoreInteractions(mock); //pretty clear I think
```

Example 2 - verifyZeroInteractions

```java
mock.foo();
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
//and we already have verified the only method invoked on the mock
```

Example 3 - verifyZeroInteractions with regular stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());
verify(mock).foo();

verifyZeroInteractions(mock);
//above passes because verifyZeroInteractions == verifyNoMoreInteractions
```

Example 4 - verifyZeroInteractions with new strict stubbing

```java
given(mock.foo()).willReturn(""x"");
assertEquals(""x"", mock.foo());

verifyZeroInteractions(mock);
//above passes because with strict stubbing
//stubbed method are implicitly verified when they are ""used""
//this is one of key features of strict stubbing (DRY, don't repeat yourself)
```

We're happy to listen to suggestions about above and the API. I think that better documentation is needed for ""verifyZeroInteractions"", too. =||= Thank you for the clarification. Then I guess the problem is with the [javadoc](https://static.javadoc.io/org.mockito/mockito-core/2.7.17/org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)) which states ""Verifies that no interactions happened on given mocks."". This made sense to me: a class X may have a number of mocked collaborators and I want to be sure that some of them have not taken part when I called X.method()

I ended up writing my version
```java
public static void verifyZeroInteractions(Object... objects) {
  for (int i = 0; i < objects.length; i++) {
    assertEquals(""Expected 0 interactions with object at index "" + i + "" ("" + objects[i].getClass() + "")"", 0, Mockito.mockingDetails(objects[i]).getInvocations().size());
  }
}
```

Also thanks for the hint about implicit verification when in strict mode: I didn't get it and it will allow me to delete some tens of lines of code =||= Interesting idea!

Let's keep this ticket to improve the documentation (want to help out? submit a PR :). I created ticket for discussing change of verifyZeroInteractions: #989 =||= "Fixes 977: Javadoc on verifyZeroInteractions"Make the javadoc of `Mockito#verifyZeroInteractions` to make it more
obvious that it does the same thing as `Mockito#verifyNoMoreInteractions`.

Fixes #977"Allon Murienikmureinik10/06/17, 07:07:54 PM
1198.01202"""Could not initialize inline Byte Buddy mock maker"" with Gradle 4.x""I tried to add Java 9 build for the Mockito 2.x branch which in turn requires Gradle upgrade to 4.x. Unfortunately with Gradle 4.x (tested with 4.0.1 and 4.2.1) 38 inline mock maker related tests are broken (without `MOCK_MAKER` env variable defined).

For example:
```
org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMakerTest > should_create_mock_from_interface FAILED
    org.mockito.exceptions.base.MockitoInitializationException: 
    Could not initialize inline Byte Buddy mock maker. (This mock maker is not supported on Android.)

    Java               : 1.8
    JVM vendor name    : Oracle Corporation
    JVM vendor version : 25.144-b01
    JVM name           : OpenJDK 64-Bit Server VM
    JVM version        : 1.8.0_144-b01
    JVM info           : mixed mode
    OS name            : Linux
    OS version         : xxx
        at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.<init>(InlineByteBuddyMockMaker.java:171)
        at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMakerTest.<init>(InlineByteBuddyMockMakerTest.java:35)

        Caused by:
        java.lang.IllegalStateException: 
        The MockMethodDispatcher class file is not locatable: org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw

        The class loader responsible for looking up the resource: sun.misc.Launcher$AppClassLoader@73d16e93
```

Travis build reproducing that issue with Oracle JDK (just Gradle upgrade in the `brokenWithGradle4` branch):
https://travis-ci.org/mockito/mockito/jobs/283893407#L793

I don't know why the Gradle upgrade can result in that behavior. Especially that ""The MockMethodDispatcher class file is not locatable: org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw"" sounds strange.

@raphw Under what circumstances that BB error can occur (even abstracting it from Gradle)?""Gradle is supposed to rename the `org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.class` file to `org/mockito/internal/creation/bytebuddy/MockMethodDispatcher.raw` during its build. This is necessary to prohibit the class from being loaded by any class loader as we explicily inject it into the bootstrap class loader using the instrumentation API. 

It seems like this does no longer work as the runtime cannot locate this name. I guess it was not renamed and is still available under `.class`. =||= It looks like this one is failing due to this (https://docs.gradle.org/4.0/release-notes.html#location-of-classes-in-the-build-directory) change in Gradle 4.0 and the fact that `inline-mock.gradle` is using the old hardcoded path. =||= Yup, that was a problem @raphw. Thanks @epeee for an implementation hint. =||= @szpak , @epeee , @raphw : Can you please help me understand what i should do to make it work in my android project? It has mockito-core and mockito-android v. 2.21.0 and also powermockito2 api and the project has both Java and kotlin classes. I would like to test the kotlin classes.  =||= @hearbeathorror This issue has been closed almost a year ago and it is rather loosely related to your problem. I propose you to ask a question using [Stack Overflow](https://stackoverflow.com/questions/tagged/mockito) or the [mailing list](https://groups.google.com/forum/#!forum/mockito). However, you mix many various elements which can cause some issues. =||= "[#1202] Java 9 CI build for Mockito 2.x"## Summary

Provide Java 9 Travis build to ensure Java 9 compatibility in at least tested use cases.

Support for Java 9 was improved in Gradle 4.x and that version is being used. Due to some issues with newer Gradle versions (#1198) some other configuration changes were required. As well as JaCoCo version has been bump (https://travis-ci.org/mockito/mockito/jobs/284996316#L799-L816).

Fixes #1198.

## Check list

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/2.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_"Marcin Zajączkowskiszpak10/08/17, 09:53:33 AM
1211.01214improve @deprecated JavaDoc of MockitoDebugger"The `@deprecated` JavaDoc of :
 * method: `Mockito.debug()` 
 * class: `MockitoDebugger` 
 * method `MockitoDebugger.printInvocations()`

... should point to `Mockito.mockingDetails(..).printInvocations()`. Currently its too hard to find the rigth entry point for the replacement."Fixes #1211: Improve @deprecated JavaDoc"This pull request fixes #1211 by improving the `@deprecated` JavaDoc of `Mockito.debug()`, `MockitoDebugger` and `MockitoDebugger.printInvocations(Object ... mocks)` by adding the additional information on how to retrieve an actual instance of the `MockitoDebugger` interface.
"Deleted userghost10/20/17, 12:06:58 PM
445.01221Introduce MockitoExtension for JUnit Jupiter (a.k.a. JUnit 5)"## New Features in JUnit 5

The JUnit Jupiter extension model in JUnit 5 introduces support for constructor and method parameter resolution (i.e., dependency injection).

Specifically, third parties can implement the `ParameterResolver` extension API to inject dependencies, mocks, etc. into constructors and methods. In addition, the `TestInstancePostProcessor` extension API can be implemented to post-process a test instance (e.g., to perform field injection).

## Status Quo

Mockito supports _field injection_ for mocks via the `@Mock` annotation. In addition, #438 allows `@Mock` to be declared on parameters for constructors and methods which makes `@Mock` support an ideal candidate for both the `TestInstancePostProcessor` and `ParameterResolver` extension APIs in JUnit Jupiter. In fact, the JUnit Team has already developed a proof of concept: see the `MockitoExtension` in the [junit5-mockito-extension](https://github.com/junit-team/junit5-samples/tree/master/junit5-mockito-extension) sample project.

## Deliverables

- [x] Introduce an official `MockitoExtension` for JUnit Jupiter to replace the proof of concept from the JUnit team.""I think this issue can be merged with #390. Our plan there was to introduce JUnit 5 compatibility in Mockito 3.0 (since 2.0 is on the verge on being released in a couple of weeks).
 =||= Sorry: I overlooked #390.

Feel free to _merge_ it as you see fit.

thanks!
 =||= Let's track the JUnitExtension in this issue and list the specifications of the `MockitoExtension` for JUnit 5. The first point is to improve Parameterized compatibility.
 =||= @sbrannen Any news on this ?
 =||= @bric3, the `MockitoExtension` from the JUnit Team is usable with Mockito 2.0 snapshots and current versions of JUnit Jupiter (JUnit 5).

So, it's really up to the Mockito Team to decide when they want to take it over.
 =||= @sbrannen this one -> [example/mockito/MockitoExtension](https://github.com/junit-team/junit5-samples/blob/master/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java) ?
 =||= Yep, that's the one.
 =||= Thanks @sbrannen.
I was wondering if any API change would happen on JUnit 5. We will take over in mockito 3 once we are ready to switch branches for mockito 2
 =||= > I was wondering if any API change would happen on JUnit 5.

Well... that's the million dollar question -- isn't it? 😉 

All kidding aside, we are currently working on JUnit Jupiter 5.0 M3, but we still have quite a way to go before a GA release. So, although I cannot promise that the `Extension` APIs won't change any before GA, it appears that the APIs currently implemented by the `MockitoExtension` should remain rather stable.
 =||= OK that's good to know. Anyway we have to release 2.1 before starting 3.0 anyway. And a some API design work on 2.1 too, that may delay JUnit5 integration in the 3.0 beta phase.
 =||= Shall we start with fleshing out the specifications of the extension? Would like to have a working prototype when JUnit 5 is released, ETA Q1 2017. =||= Yes go for it, I'll create a submodule junit 5 at this time since JUnit 5 is a near complete rewrite, with a lot of binary incompatibilities. =||= +1

Do we want to completely decouple mockito-core module from JUnit? =||= @szczepiq I am not sure, but supporting both `JUnit4` and `JUnit5` in `mockito-core` seems problematic. We have seen similar issues with `Spring` having to support both Mockito 1 and 2. Therefore I think it is better to refactor Mockito 3 such that we publish 2 new artifact: `mockito-junit4` and `mockito-junit5` which provide the integration layer between Mockito and Junit.

@sbrannen Are you aware of other framework users depending on JUnit which employ this approach or is there a different and better solution? =||= In the `spring-test` module for the Spring Framework, we provide support for TestNG, JUnit 4, and JUnit Jupiter (what you call JUnit 5) alongside each other, just in different packages. 

That's all within a single JAR, and there are no issues since each of those is an optional dependency (in terms of the Maven POM).

Thus, projects that consume `spring-test` can pick which testing framework they wish to use (or potentially use TestNG, JUnit 4, and JUnit Jupiter all simultaneously,  however unlikely that may be).

As long as it's clear what developers need to consume for a given testing framework, it shouldn't be a problem having a single artifact. For example, with Spring, JUnit 4 users use the `SpringRunner`; whereas, JUnit Jupiter users use the `SpringExtension`.

 =||= If you do opt for separate modules (i.e., Maven artifacts), I would recommend against `mockito-junit5`, since what you are really providing is an extension for JUnit Jupiter -- which is the new programming model in JUnit 5.

The problem with naming such an artifact `mockito-junit5` is that there may well be a JUnit 6 or 7 still based on the JUnit Jupiter programming and extension models, and then the artifact name containing a `5` would no longer make sense.

FYI: I have just changed the title of this issue to reflect this fact. =||= Okay that seems reasonable, so let's take the package approach! My experience with jar configurations is limited, so in terms of the configuration of users' `pom.xml` I do not 100% understand how that is going to work. But I think we can figure that one out. Thanks for the explanation @sbrannen ! =||= @sbrannen thank you for describing and suggesting an approach. I like the idea of separation at the Java package level in the same jar. We can go for separate jars only when we have to (e.g. when JUnit versions clash). Do you have integration tests that demonstrate correct behavior with different test frameworks / different versions of test frameworks?

 =||= > Do you have integration tests that demonstrate correct behavior with different test frameworks / different versions of test frameworks?

Is that a rhetorical question? 😉 

Yes, of course we have tests for the Spring Framework. I'd be ashamed to let `spring-test` ship without an automated test suite.

Regarding the package structure, if you look [here](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/main/java/org/springframework/test/context) you'll see the following:

- `org.springframework.test.context.junit4`
- `org.springframework.test.context.junit.jupiter`
- `org.springframework.test.context.testng`

So that's how we split up the functionality within the `spring-test` JAR.

We naturally have unit and integration tests for our JUnit 4, JUnit Jupiter, and TestNG support which you can find in various subpackages [here](https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/context).

Within the IDE, we execute TestNG tests with the TestNG plugin (e.g., for Eclipse); we execute JUnit 4 tests with the IDE's built-in support; and we execute JUnit Jupiter tests with the `JUnitPlatform` runner (at least within Eclipse for the time being). For the latter, see [SpringJUnitJupiterTestSuite](https://github.com/spring-projects/spring-framework/blob/master/spring-test/src/test/java/org/springframework/test/context/junit/SpringJUnitJupiterTestSuite.java).

Within the [Gradle build](https://github.com/spring-projects/spring-framework/blob/master/build.gradle#L1123-L1152), we execute TestNG, JUnit 4, and JUnit Jupiter tests via Gradle's standard `test` task. In other words, in order to keep Spring's build as simple as possible, we don't yet use the JUnit Platform Gradle Plugin to execute JUnit Jupiter tests natively. Instead, we let the Gradle `test` task pick up the `SpringJUnitJupiterTestSuite` as a JUnit 4 test (which in turn executes all of our JUnit Jupiter tests as a suite).

I'm not sure if I've now said too much or too little. So if you still have questions, just ask!

Regards,

Sam =||= This week I had an interesting discussion with 2 of my student colleagues who are currently analyzing and documenting the architecture of JUnit. In this discussion we talked about the architecture in general as well as the extensions and in particular the MockitoExtension.

In this discussion I expressed my concerns regarding the new approach with injecting Mocks based on parameters. My colleagues told me that JUnit5 focuses more on testing with interfaces, in which the tests are also interfaces. Since interfaces do not have fields, field injection of mocks is not possible. Therefore the JUnit team proposes/chose to inject mocks via parameters.

Maintaining mocks is one of the most precarious tasks when working on a test suite and we at Mockito regularly receive feedback where Mocks are misbehaving. This is the exact reason that we are shipping features such as `Strict Stubbing` which reduce the amount of confusion and mistakes developers can make. By limiting the developer in making mistakes, we can prevent tests to incorrectly pass while in fact they are relying on misconfigured mocks.

As a result, our general goal for Mockito 3 is to leverage the available tools even more to prevent developers from making mistakes. Most notably I am personally advocating for increasing type-safety of our various features such that developers can rely on the compiler to warn them. Since running tests is a costly task and sometimes takes over an hour before CI finished all tests, the earlier developers can receive feedback regarding misconfiguration, the better.

Having said that, let's go back to the parameter injection currently available with JUnit5. While the status quo is field injection, a compiler can warn developers when they have a typo in the usage of a Mock. E.g. when a user wants to use `mock1`, while the field is actually named `mock2`, the compiler errors to notify the developer he/she made a mistake. Parameter injection does not have this behavior, as it is relying merely on the parameter name (or the name supplied to `@Mock`) which is plain String comparison.

While we are striving to prevent developers of making mistakes by leveraging the compiler, adopting parameter injection feels like a step back to me.

For this reason I am not in favor of going for parameter injection, but given the need for writing tests as interfaces I am not sure what our options are.

Of course we have not started writing an extension, so I have not tried this out. But I do think we should resolve this issue before coming up with a good story for Mockito 3 + JUnit5.

CC @LiamClark @Tarovk =||= How is parameter injection different from field injection?

_Edit:_ To rephrase my question a bit: How is field injection safer than parameter injection? Is there some Mockito feature I'm not aware of? =||= @marcphilipp I think he was talking about this error case:
```java
public class Test {
	@Mock Dependency mock1;
	@Before public void setUp() {
		when(mock1.foo()).thenBar();
	}
	@Test public void test() {
		// mock2 is a compile error
		new SUT(mock2).target();
	}
}
```

```java
class Test {
	@BeforeEach void setUp(@Mock Dependency mock1) {
		when(mock1.foo()).thenBar();
	}
	@Test void test(@Mock Dependency mock2) { // or @Mock(name=""mock2"")
		// mock2 is a newly created a mock without .foo() stubbing
		new SUT(mock2).target();
	}
}
```
The extension can't know if you intentionally want a new mock in your test method or you made a typo, while javac knows that you're referencing a non-existent field.

Re edit: The current extension impl caches the mocks: https://github.com/junit-team/junit5-samples/blob/026a9d9abe06b6173398c1a2518793259cd190f2/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java#L57 =||= @marcphilipp it is possible I am misunderstanding the proposed solution. @TWiStErRob beat me to it with an example testcase which I was indeed referring to. =||= Thanks for the explanation and the example. That helped! 🙂

With strict stubbing, the example in the error case would throw a ""validation error"" in the end, right?

Since we cannot force people to compile with `-parameters`, I think there are at least these possible approaches:

1. Treat every mock parameter like a different mock unless it has an explicit name.
2. Treat mock parameters for the same type like they're the refer to the same mock unless they have different explicit names.
3. Don't support injecting mocks into methods besides test methods at all.

What I like about being able to use method parameters: The mock is local to one test method. You can use different or even no mocks in different test methods. =||= > With strict stubbing, the example in the error case would throw a ""validation error"" in the end, right?

Yes, but at run-time instead of at compile-time. Nonetheless better then nothing :stuck_out_tongue: 

> What I like about being able to use method parameters: The mock is local to one test method. You can use different or even no mocks in different test methods.

I do understand the reasoning, but if you need a Mock that is local to a test method, why not a simple `Mock mock = mock(Mock.class)` at the start of the method? This usually also nicely fits in a `given-when-then` structure of test methods.

Just to note: I would really like to take advantage of Parameter mocking, but thus far I am afraid of creating more problems and confusion than it actually solves. Maybe we can come up with a golden solution :smile:  =||= No worries, I hear you and understand your concerns. We should definitely try to find the best solution. 🙂 =||= +1 for locality and Treating every mock parameter like a different mock unless it has an explicit name.

It also discourages complex mocking in interface tests. =||= +1 agree with locality, common setup in `@Before` usually creates more problems than solves. =||= For locality developers can already call `mock()` themselves. However @LiamClark pointed out during a chat that `@Mock` on a parameter can safely handle generics. For example when mocking Streams. That seems like a valid usecase. If we can solve this issue without ambiguity between multiple mocks, that could work. =||= Also `@Mock` feels a bit more declarative then mock(ClassLiteral.class) =||= @LiamClark not to mention all parameters that annotation can have versus the equivalent `MockSettings` builder =||= JUnit5 has been released and as such we probably need to create an official extension. Hopefully I have time in the near future, but feel free to contribute a PR if you have time. =||= What are the requirements for a MVP? =||= On the top of my head runner-like functionality with:
1. Initialize `@Mock` and `@InjectMocks`
1. Check verificationstate after test ran
1. Clean up MockitoFramework listeners
1. Check for strict stubs =||= Okay I am looking into it...

* Should it target mockito 2? 
* Is a new subproject required? =||= Yes to both! =||= What should go into the junit5-subproject? The implementation, the junit5 tests or both ? 
 =||= The implementation of a Mockito extension for Junit5. It is probably coming down to a single or a couple of classes. =||= Any news on this issue? =||= @marcphilipp Development started in #1221. There we hit #1232 which is an internal issue. There are several implicit assumptions in our internal API that were true for JUnit4, but are no longer valid for JUnit5. If I understand the issue correctly, the current extension has to supported nested classes. With JUnit4 we did not support this, but with JUnit5 we have to do this.

Timeline-wise, I am not sure how much time one of the @mockito/core developers has to review #1221 and fix our internal API. Especially as `MockitoSession` is part of our public API, we have little wiggle room. I know that the Software Quality and Testing course in quarter 4 of our university wants to use Mockito and JUnit5, so I probably need to discuss with @LiamClark what the details of that is. I might be able to find some time in that regard to work on this issue.

All in all, while implementation seemed easy at first, we hit some unfortunate core issues in our public API that need to be addressed. Once we figured that out, it should be fairly straightforward to finish the extension. =||= Thanks for the update! Let me know if I can help in any way. 🙂  =||= Thank @marcphilipp for a friendly ping and @TimvdLippe for recapping the status.

I'm making progress on getting Strictness configurable: #792. This should remove a complexity from the JUnit5 extension PR that @ChristianSchwarz was working on. I hope that Christian can resume work. If not, we can review the design and someone will take a stab at it. How about you @marcphilipp? =||= I can resume to work on it . Actually I am short on time so a ""pre""-review of  #1221 would help. Maybe some one can start with #1232 in the mean time. =||= Regarding #1232: another option would be to not support nesting of test classes. I think we actively have to consider this option, given our public API was apparently coupled to the JUnit4 implementation and we can not ship breaking changes per our policy. =||= Well, it's `@Incubating` so you could still change it, right? 😉

Besides, I think neither of the two proposals would break compatibility, would they? But then again, we should discuss this over at #1232. 🙂  =||= Hm, looking at it again, it seems that the breaking change is actually in an internal API, namely [`TestFinishedEvent`](https://github.com/mockito/mockito/blob/release/2.x/src/main/java/org/mockito/internal/junit/TestFinishedEvent.java#L11), which is created in `MockitoSession`. As such, I think we should be okay actually. I will do a proper investigation this weekend (hopefully, else next week) and update #1221. I hope you are okay with that @ChristianSchwarz ? Once that is done, I can more definitively say the impact on our API and whether we are risking a breaking change. I have good hopes now we might actually dodge that. =||= `TestFinishedEvent.getTestClassInstance()` and `TestFinishedEvent.getTestMethodName()` are currently only used (twice) like this:
```java
String testName = event.getTestClassInstance().getClass().getSimpleName() 
                  + ""."" + event.getTestMethodName();
```

Currently, `DefaultMockitoSession` always uses `null` for `TestFinishedEvent.getTestMethodName()` which strikes me as odd. I think it would be better if `TestFinishedEvent` only had two methods: `getFailure()` and `getTestName()`. Then, `MockitoSessionBuilder` could get a `testName(String)` builder method and `DefaultMockitoSessionBuilder` could pass it to `DefaultMockitoSession` and so on.

Alternatively, `MockitoSessionBuilder` could get a `testMethodName()` builder method and pass that on.

Moreover, I think `MockitoSessionBuilder` should allow to configure a `MockitoLogger`. This way, frameworks like JUnit could pass in a custom implementation. For JUnit Jupiter, a `MockitoLogger` that publishes report entries instead of writing to stdout (which causes problems will parallel execution) comes to mind.

Thoughts? =||= @marcphilipp 
@TimvdLippe 
Good idea to continue the discussion about #1232 in that ticket, i copied your the relevant comments over there. =||= it would be nice if the MockitoExtension works together with `@TestFactory` based methods. When I use the extension created by the JUnit team, I need to manually reset mocks within the dynamic test method. 

@sbrannen you guys already thought about how to integrate that? =||= @paulmiddelkoop There's no lifecycle support for dynamic tests and we currently have no plans to add any, i.e. there's no hook to reset mocks after a dynamic test. You could use `MockitoSession` in your `@TestFactory` method directly. 🤔 =||= I agree with @marcphilipp: due to the lack of lifecycle support for dynamic tests (see the [Dynamic Test Lifecycle](https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests) _note_ in the User Guide), you'll have to reset mocks manually.

Note, however, that you'll likely want to reset them within each `Executable` (i.e., lambda expression or method reference) returned by your `@TestFactory` method.

 =||= Thanks @marcphilipp and @sbrannen for the explanation. Any reason why there is no lifecycle support for dynamic tests? 

For now I ended up with a utility function for this:
```kotlin
    fun dynamicMockitoTest(testInstance: Any, displayName: String, executable: () -> Unit): DynamicTest {
        val mockito = Mockito.mockitoSession()
            .initMocks(testInstance)
            .strictness(Strictness.STRICT_STUBS)
            .startMocking()
        try {
            return dynamicTest(displayName, executable)
        } finally {
            mockito.finishMocking()
        }
    }
```

However this will not work if I also have regular `@Test` methods and implement the MockitoExtension to also use the MockitoSession instead of `MockitoAnnotations.initMocks(testInstance)`. It will result in a ""Previous MockitoSession was not concluded with 'finishMocking()"" error which is logical. I could put the `ExtendWith(MockitoExtension::class)` on every `@Test` method instead of the class as a solution, I guess. 

I think a simpler integration is needed for a good adoption of dynamic tests. It's a regular use case to use mocking inside dynamic tests, right?
 =||= > Any reason why there is no lifecycle support for dynamic tests?

Dynamic tests are intended for simple use cases that do not need lifecycle callback support. If one needs lifecycle callback support, it is then recommended to use parameterized tests.

> However this will not work if I also have regular `@Test` methods...

Actually, that won't work at all, not even for dynamic tests.

Your current code example initializes and resets mocks around the _construction_ of the `DynamicTest` instance; whereas, it must do that at _execution_ time (i.e., when the `Executable` is actually invoked by JUnit Jupiter).

You would instead need to create your own _wrapper_ around the invocation of your `executable`, and that wrapper would need to implement the try-finally logic around the execution of the actual `executable`.

> I think a simpler integration is needed for a good adoption of dynamic tests. It's a regular use case to use mocking inside dynamic tests, right?

We don't know. The dynamic test support is an _experimental_ feature. So that remains to be seen. 😉  =||= @paulmiddelkoop if you create an extension method you don't need to pass in `this@FooTest` every time:
```kotlin
fun Any.dynamicMockitoTest(displayName: String, executable: () -> Unit): DynamicTest =
	dynamicTest(displayName) {
		val mockito = Mockito.mockitoSession()
				.initMocks(this@dynamicMockitoTest)
				.strictness(Strictness.STRICT_STUBS)
				.startMocking()
		try {
			executable()
		} finally {
			mockito.finishMocking()
		}
	}
```
and the usages of `dynamicTest` and `dynamicMockitoTest` should look the same. (This version also includes what @sbrannen said to delay the try-finally execution.)

> So that remains to be seen.

Well, now you have two votes for mocking in dynamic tests. =||= @paulmiddelkoop & @TWiStErRob, if you want support for lifecycle callbacks for dynamic tests in JUnit Jupiter, the best place to make your wishes heard is https://github.com/junit-team/junit5/issues/378. =||= What is the ETA for Mockito 3.x? I'd love to see this feature. =||= The intent now is to ship junit5 support in a separate artifact with mockito 2 =||= @TimvdLippe That is great news - maybe the milestone should be updated to reflect this?
For any others waiting for this https://github.com/JeffreyFalgout/junit5-extensions/tree/master/mockito-extension might be of help in the meantime.  =||= A little house-keeping:

The change in #438 was made to allow Mocks to be generated for the parameters to test and support methods. =||= @smoyer64 That is correct. I wanted to publish the extension as it was lingering for too long and thus did not want to wait on discussion about ""new features"" (compared to the 4 runner). Please open a new issue to discuss that change. =||= @TimvdLippe 

I haven't had a chance to try out the official ``MockitoExtension`` you published yesterday (I'm watching for it in Maven Central but rereading your post perhaps I should be watching Sonatype's OSS-SNAPSHOTS), so I wasn't aware that the version you published was missing this functionality.  I just thought it was important to lump these two requests together.

The ``MockitoExtension`` prototype that published as a sample by the JUnit 5 team has this feature so I guessed I assumed the official version did too?  In any case, I think it's a really useful feature for cases where not every test needs a specific ``Mock`` (and the injected ``Mock`` has different behaviors if used in more than one test) so I'd be happy to write up a feature request.

I have to admit I was pretty excited to see this released yesterday since it would provide an official way to use Mockito with JUnit 5.  Unfortunately we're already using the ``ParameterResolver`` from the prototype ``MockitoExtension`` so I guess we're in for a bit more of a wait.  Let me know if I can help. =||= @smoyer64 as I said I am open for adding that feature, but I would like to discuss it first in a separate issue. So please open one with your use-case so we can discuss 😄  =||= @TimvdLippe Sorry I wasn't clear in my last comment.  I do realize that this issue is closed and went off to write the feature request you asked for (and got side-tracked by an emergency with one of the non-profits I help run).  I also looked at all the JUnit 5 related issues that were already posted.  Would it be worth having a JUnit 5 label to help organize them?

In any case, I've now added #1348 ... please let me know if additional information is needed.

Thanks for all the hard work you've done to provide official JUnit 5 support in Mockito! =||= Since this is one of the top Google results for trying to get this working, and I'll likely Google it again, I'd like to add that this is in the mockito-junit-jupiter project. [Maven Central link mockito-junit-jupiter](https://mvnrepository.com/artifact/org.mockito/mockito-junit-jupiter) =||= "MockitoExtension for JUnit5 "Fixes #445

Discussion: https://groups.google.com/forum/#!topic/mockito/R1L1aG2RgBQ

First of all, thanks to the JUnit5-Team (@sbrannen) for that great API! The implementation was straight forward and the docu is top notch. Not comparable to a JUnitRule or Runner implementation. One can feel the hard work. 

----

The here provided `MockitoExtension` allows to mock/spy/validate like the well known Mockito-JUnitRule/Runner. This is still ""work in progress"", feel free to comment.

Usage:

```Java
@ExtendWith(MockitoExtension.class)
class JUnit5Test {
 
  @Mock
  private Dependency mock ;

  @Test
  void checkMockCreation(){
    when(mock.foo()).thenReturn(""Hello JUnit5"");
    mock.foo();
    verify(mock).foo();
  }
}
```"Christian SchwarzChristianSchwarz03/24/18, 03:42:21 PM
1130.01228Mockito should annotate when() methods with a custom annotation @CheckReturnValue"Static code checkers like error-Prone and FindBugs will help detecting invalid usage of Mockito in single-call situations if Mockito source code were annotated with @CheckReturnValue.

See:
* https://github.com/joel-costigliola/assertj-core/issues/157
* http://errorprone.info/bugpattern/CheckReturnValue
* https://github.com/joel-costigliola/assertj-core/pull/695
* https://github.com/joel-costigliola/assertj-core/blob/master/src/main/java/org/assertj/core/util/CheckReturnValue.java

Note like for AssertJ, any annotation with name should do, no need to depend on a specific library with  @CheckReturnValue."That seems fine to me. Please submit a pull request :smile:  =||= Add @CheckReturnValue to stubbing/verification methods"Introduce a new annotation `@CheckReturnValue` and add this to methods like `when` and `verify` such that static analysis can verify the value is actually used (http://errorprone.info/bugpattern/CheckReturnValue). This makes sure developers can get warnings on build-time instead of run-time (with our internal `validateState`)

Fixes #1130 "Tim van der LippeTimvdLippe10/31/17, 12:40:38 PM
1070.01229Fix coverage for subprojectsIn #1032, the new coverage was incorrectly tracked by jacoco. A quick search showed this TODO (https://github.com/mockito/mockito/blob/release/2.x/gradle/root/coverage.gradle#L3) that points out it is actually not generating coverage for subprojects. Would like to see this fixed!Enable jacoco coverage on subprojects"Inspired by http://csiebler.github.io/blog/2014/02/09/multi-project-code-coverage-using-gradle-and-jacoco/, Gradle is now configured to incorporate coverage of subprojects. This should increase our current coverage, as we now also incorporate the coverage generated from `kotlinTest`.

Fixes #1070"Tim van der LippeTimvdLippe11/02/17, 10:57:11 AM
1239.01242Enable Checkstyle rule for checking existence of license headers"Whenever we add new files to the repository, we usually forget to add our license headers. This results in PRs such as #1227 where retroactively we add the license headers.

CheckStyle has a rule called [`Header`](http://checkstyle.sourceforge.net/config_header.html) which can enforce that we add our license header. I would propose to start enabling this rule to make sure all our source files comply to our licensing.

@mockito/core yay/nay?"Think it makes sense to add a check since we have it. Without it, the project will just always be inconsistent. =||= Absolutely +1. Thank you! =||= Enable Checkstyle for checking license headers"Apparently we weren't shipping license headers on the Android subproject as well :cry: 

Fixes #1239 "Tim van der LippeTimvdLippe11/05/17, 10:50:39 AM
1233.01244Mockito build should not try to install anything to /usr/lib/node_modules by default"The build of the recent Mockito is trying to install some Node JS modules globally in the system on just `gw check`. Probably no-one sane runs the build from root, but it's a bad practice IMHO.

```
> Task :javadoc
...
Installing sw-precache globally
npm WARN checkPermissions Missing write access to /usr/lib/node_modules
npm ERR! path /usr/lib/node_modules
npm ERR! code EACCES
npm ERR! errno -13
npm ERR! syscall access
npm ERR! Error: EACCES: permission denied, access '/usr/lib/node_modules'
npm ERR!  { Error: EACCES: permission denied, access '/usr/lib/node_modules'
npm ERR!   stack: 'Error: EACCES: permission denied, access \'/usr/lib/node_modules\'',
npm ERR!   errno: -13,
npm ERR!   code: 'EACCES',
npm ERR!   syscall: 'access',
npm ERR!   path: '/usr/lib/node_modules' }
npm ERR! 
npm ERR! Please try running this command again as root/Administrator.

npm ERR! A complete log of this run can be found in:
npm ERR!     /home/foo/.npm/_logs/2017-10-29T23_39_39_312Z-debug.log
NPM is not installed. Aborting generating service-worker
```

I would prefer to even do not install npm modules locally (in the user home directory) in the default build. Only on Travis (or on demand) with the extra `-P` switch.""Yeah I have been getting more annoyed about this npm install. Sadly the
theory of the service-worker does not work in practice with javadoc.
Probably its best just to revert it all. Nice experiment, sadly didnt work
out as desired :(

On Mon, 30 Oct 2017, 00:48 Marcin Zajączkowski, <notifications@github.com>
wrote:

> The build of the recent Mockito is trying to install some Node JS modules
> globally in the system on just gw check. Probably no-one sane runs the
> build from root, but it's a bad practice IMHO.
>
> > Task :javadoc
> ...
> Installing sw-precache globally
> npm WARN checkPermissions Missing write access to /usr/lib/node_modules
> npm ERR! path /usr/lib/node_modules
> npm ERR! code EACCES
> npm ERR! errno -13
> npm ERR! syscall access
> npm ERR! Error: EACCES: permission denied, access '/usr/lib/node_modules'
> npm ERR!  { Error: EACCES: permission denied, access '/usr/lib/node_modules'
> npm ERR!   stack: 'Error: EACCES: permission denied, access \'/usr/lib/node_modules\'',
> npm ERR!   errno: -13,
> npm ERR!   code: 'EACCES',
> npm ERR!   syscall: 'access',
> npm ERR!   path: '/usr/lib/node_modules' }
> npm ERR!
> npm ERR! Please try running this command again as root/Administrator.
>
> npm ERR! A complete log of this run can be found in:
> npm ERR!     /home/foo/.npm/_logs/2017-10-29T23_39_39_312Z-debug.log
> NPM is not installed. Aborting generating service-worker
>
> I would prefer to even do not install npm modules locally (in the user
> home directory) in the default build. Only on Travis (or on demand) with
> the extra -P switch.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1233>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb94gDamGIwuYA1kWznAMgBmMgKCuks5sxQ63gaJpZM4QKiAB>
> .
>
 =||= Happy to see this fixed! =||= "Remove service-worker from Javadoc generation"Essentially reverts #602. It was a nice experiment, but sadly it didn't appear to work and my expectation is that it won't for a while.

Fixes #1233 "Tim van der LippeTimvdLippe11/03/17, 10:55:46 PM
904.01247Remove unnecessary classes"Looking at https://codecov.io/gh/mockito/mockito/list/e92b0be0c6362157e2c8ae349a2b9d1295065d2e/src and sorting it by coverage, it appears that there are some classes that are completely untested. Taking another closer look reveals some candidate classes that can be removed. For example `MockitoLimitations` is [only used in the Reporter](https://github.com/mockito/mockito/search?utf8=%E2%9C%93&q=MockitoLimitations), the field can therefore be placed in the Reporter directly.

There are also some debugging and util classes that seem unused. If we do decide to retain them, I think we should test them to actually make sure they are working properly."Remove several container classes and inline code"Remove several classes that were containers for code that is easier to be inlined. They were only referenced once, or never at all. This makes it easier to reason about the code, while also maintaining less code and classes.

Closes #904 "Tim van der LippeTimvdLippe11/28/17, 04:47:33 PM
1254.01257Wanted but not invoked on 2.12.0, but not on 2.11.0"After updating Mockito from 2.11.0 to 2.12.0 the following test fails with `Wanted but not invoked`.

The weird thing is this happens only when running tests using Gradle. Android Studio runs the same test as successful. Just like #1183.

```java
package package.redacted;

import org.junit.Test;
import org.mockito.Mockito;

public class ViewModelTest {

    class View {
        private Runnable actionCallback = null;

        void callAction(Runnable callback) {
            actionCallback = callback;
        }

        void simulateActionCalled() {
            if (actionCallback != null) {
                actionCallback.run();
            }
        }

        void showResult() {
        }
    }

    class ViewModel {

        public ViewModel(final View view) {
            view.callAction(new Runnable() {
                @Override
                public void run() {
                    view.showResult();
                }
            });
        }
    }

    @Test public void test() {
        View view = Mockito.spy(new View());
        ViewModel viewModel = new ViewModel(view);

        view.simulateActionCalled();

        Mockito.verify(view).showResult();
    }
}
```
```
Wanted but not invoked:
view.showResult();
-> at package.redacted.ViewModelTest$View.showResult(ViewModelTest.java:22)

However, there were exactly 2 interactions with this mock:
view.callAction(
    package.redacted.ViewModelTest$ViewModel$1@26645040
);
-> at package.redacted.ViewModelTest$ViewModel.<init>(ViewModelTest.java:28)

view.simulateActionCalled();
-> at package.redacted.ViewModelTest.test(ViewModelTest.java:41)


	at package.redacted.ViewModelTest$View.showResult(ViewModelTest.java:22)
	at package.redacted.ViewModelTest.test(ViewModelTest.java:43)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy1.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:108)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:146)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:128)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
	at java.lang.Thread.run(Thread.java:748)
```""I'm observing a similar issue. Only happens with `mockito-inline`. Don't have time right now to distill the affected tests into a minimal reproduction case. Maybe @raphw has a hunch. =||= Alright, decided to look for a minimal reproduction case after all. This is what I came up with:
```java
package com.example

import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.verify;

import org.testng.annotations.Test;

public final class MockitoIssue1254Test {
    @Test
    public void test() {
        Dummy d = spy(new Dummy());
        d.foo();
        verify(d).bar(eq(""baz""));
    }

    static class Dummy {
        public void foo() {
            bar(""baz"");
        }

        // Also fails if public.
        void bar(String s) {}
    }
}
```

Causes:
```
Wanted but not invoked:
dummy.bar(""baz"");
-> at com.example.MockitoIssue1254Test$Dummy.bar(MockitoIssue1254Test.java:23)

However, there was exactly 1 interaction with this mock:
dummy.foo();
-> at com.example.MockitoIssue1254Test.test(MockitoIssue1254Test.java:13)
```

This test does pass with Mockito 2.11.0. It also passes with Mockito 2.12.0, provided `mockito-inline` is disabled. =||= Probably another error in the logic for self-invocation detection. I will have a look! =||= Ok, this was just me forgetting how my implementation intially worked. I fixed it locally and will push a fix soon. =||= Same for mocked methods on Spy. On 2.12.0 real method is called. =||= When is this going to be on Maven Central? =||= We could trigger a new release, @TimvdLippe, would you find some time? =||= Yeah I can try it tomorrow :)

Op di 5 dec. 2017 om 20:55 schreef Rafael Winterhalter <
notifications@github.com>:

> We could trigger a new release, @TimvdLippe
> <https://github.com/timvdlippe>, would you find some time?
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1254#issuecomment-349422044>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb3sUMqw_c_exn9HiMDi5ls1QmDHdks5s9Z_LgaJpZM4QZVVK>
> .
>
 =||= Version 2.13.0 should be published and available soon in Maven Central!

P.S. @mockitoguy the `[ci maven-central-release]` was working flawlessly :tada:  =||= Danke! Bedankt! Many thanks! =||= Can confirm that finally our suite of 13+ K Kotlin tests work after fixing #1183 and this one ✨ Thanks! =||= >P.S. @mockitoguy the [ci maven-central-release] was working flawlessly 🎉

Awesome! Thank you for pushing out the version! =||= "Fixes #1254 and #1256: improved check for self-invocation."Better checks for recursive calls and guards internally used JDK types.

Fixes #1254 
Fixes #1256"Rafael Winterhalterraphw11/28/17, 09:54:53 PM
1256.01257Unbounded recursion when spying with `mockito-inline`"Consider the following code:
```java
@Test
public void test() {
    ConcurrentMap<String, String> map = spy(new ConcurrentHashMap<>());
    map.putIfAbsent(""a"", ""b"");
}
```

Running it causes a `StackOverflowError`:
```
Configuring TestNG with: TestNG60Configurator
Exception in thread ""TestNG-test=Surefire test-1"" java.lang.StackOverflowError
        at org.mockito.internal.creation.bytebuddy.MockMethodDispatcher.get(MockMethodDispatcher.java:20)
        at java.util.concurrent.ConcurrentHashMap.containsKey(ConcurrentHashMap.java:964)
        at org.mockito.internal.util.concurrent.WeakConcurrentMap.containsKey(WeakConcurrentMap.java:74)
        at org.mockito.internal.util.concurrent.WeakConcurrentMap$WithInlinedExpunction.containsKey(WeakConcurrentMap.java:261)
        at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.isMock(MockMethodAdvice.java:116)
        at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.isMocked(MockMethodAdvice.java:121)
        at java.util.concurrent.ConcurrentHashMap.containsKey(ConcurrentHashMap.java:964)
        at org.mockito.internal.util.concurrent.WeakConcurrentMap.containsKey(WeakConcurrentMap.java:74)
        at org.mockito.internal.util.concurrent.WeakConcurrentMap$WithInlinedExpunction.containsKey(WeakConcurrentMap.java:261)
        at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.isMock(MockMethodAdvice.java:116)
        at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.isMocked(MockMethodAdvice.java:121)
        at java.util.concurrent.ConcurrentHashMap.containsKey(ConcurrentHashMap.java:964)
        ...
```

Tested with Mockito 2.11.0 and 2.12.0. Do not happen if I disable `mockito-inline`. CC @raphw."I will have a look, thanks! =||= The problem is that we use a hash map internally to store mock dispatchers. We need to exclude this map from checking for being a mock explicitly as the check involves reading from the map what triggers the recursion. =||= Fixes #1254 and #1256: improved check for self-invocation."Better checks for recursive calls and guards internally used JDK types.

Fixes #1254 
Fixes #1256"Rafael Winterhalterraphw11/28/17, 09:54:53 PM
1067.01258Deadlock after upgrading to Mockito 2 and parallel tests execution"I updated Mockito and ScalaTest today from ScalaTest 2.x and Mockito 1.x and my tests suddenly froze in SBT (not in IntelliJ). After some playing around, I noticed every test class by itself passes and when I disabled running tests in parallel in SBT, the tests would work again.

I used jstack and came across this deadlock:
```
Found one Java-level deadlock:
=============================
""pool-9-thread-10-ScalaTest-running-ApiKeyVerificationFilterSpec"":
  waiting to lock monitor 0x00007fea6f039538 (object 0x00000007959e4a78, a sbt.classpath.ClasspathUtilities$$anon$1),
  which is held by ""pool-9-thread-2-ScalaTest-running-BRequestFilterSpec""
""pool-9-thread-2-ScalaTest-running-BRequestFilterSpec"":
  waiting to lock monitor 0x00007fea70e95548 (object 0x0000000795a868e8, a sbt.classpath.ClasspathFilter),
  which is held by ""pool-9-thread-10-ScalaTest-running-ApiKeyVerificationFilterSpec""

Java stack information for the threads listed above:
===================================================
""pool-9-thread-10-ScalaTest-running-ApiKeyVerificationFilterSpec"":
	at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
	- waiting to lock <0x00000007959e4a78> (a sbt.classpath.ClasspathUtilities$$anon$1)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
	- locked <0x0000000795a868e8> (a sbt.classpath.ClasspathFilter)
	at sbt.classpath.ClasspathFilter.loadClass(ClassLoaders.scala:59)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at net.bytebuddy.dynamic.loading.MultipleParentClassLoader.loadClass(MultipleParentClassLoader.java:68)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at sun.reflect.GeneratedSerializationConstructorAccessor35.newInstance(Unknown Source)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:422)
	at org.objenesis.instantiator.sun.SunReflectionFactoryInstantiator.newInstance(SunReflectionFactoryInstantiator.java:48)
	at org.objenesis.ObjenesisBase.newInstance(ObjenesisBase.java:73)
	at org.mockito.internal.creation.instance.ObjenesisInstantiator.newInstance(ObjenesisInstantiator.java:18)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:47)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
	at org.mockito.Mockito.mock(Mockito.java:1729)
	at org.mockito.Mockito.mock(Mockito.java:1642)
	at org.scalatest.mockito.MockitoSugar$class.mock(MockitoSugar.scala:73)
	at com.b.n.filter.ApiKeyVerificationFilterSpec.mock(ApiKeyVerificationFilterSpec.scala:25)
	at com.b.n.filter.ApiKeyVerificationFilterSpec$ApiKeyFetchSetup$class.$init$(ApiKeyVerificationFilterSpec.scala:77)
	at com.b.n.filter.ApiKeyVerificationFilterSpec$$anonfun$15$$anon$11.<init>(ApiKeyVerificationFilterSpec.scala:80)
	at com.b.n.filter.ApiKeyVerificationFilterSpec$$anonfun$15.apply(ApiKeyVerificationFilterSpec.scala:80)
	at com.b.n.filter.ApiKeyVerificationFilterSpec$$anonfun$15.apply(ApiKeyVerificationFilterSpec.scala:80)
	at org.scalatest.OutcomeOf$class.outcomeOf(OutcomeOf.scala:85)
	at org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
	at org.scalatest.Transformer.apply(Transformer.scala:22)
	at org.scalatest.Transformer.apply(Transformer.scala:20)
	at org.scalatest.FunSpecLike$$anon$1.apply(FunSpecLike.scala:454)
	at org.scalatest.TestSuite$class.withFixture(TestSuite.scala:196)
	at org.scalatest.FunSpec.withFixture(FunSpec.scala:1630)
	at org.scalatest.FunSpecLike$class.invokeWithFixture$1(FunSpecLike.scala:451)
	at org.scalatest.FunSpecLike$$anonfun$runTest$1.apply(FunSpecLike.scala:464)
	at org.scalatest.FunSpecLike$$anonfun$runTest$1.apply(FunSpecLike.scala:464)
	at org.scalatest.SuperEngine.runTestImpl(Engine.scala:289)
	at org.scalatest.FunSpecLike$class.runTest(FunSpecLike.scala:464)
	at com.b.n.filter.ApiKeyVerificationFilterSpec.org$scalatest$BeforeAndAfter$$super$runTest(ApiKeyVerificationFilterSpec.scala:25)
	at org.scalatest.BeforeAndAfter$class.runTest(BeforeAndAfter.scala:203)
	at com.b.n.filter.ApiKeyVerificationFilterSpec.runTest(ApiKeyVerificationFilterSpec.scala:25)
	at org.scalatest.FunSpecLike$$anonfun$runTests$1.apply(FunSpecLike.scala:497)
	at org.scalatest.FunSpecLike$$anonfun$runTests$1.apply(FunSpecLike.scala:497)
	at org.scalatest.SuperEngine$$anonfun$traverseSubNodes$1$1.apply(Engine.scala:396)
	at org.scalatest.SuperEngine$$anonfun$traverseSubNodes$1$1.apply(Engine.scala:384)
	at scala.collection.immutable.List.foreach(List.scala:381)
	at org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:384)
	at org.scalatest.SuperEngine.org$scalatest$SuperEngine$$runTestsInBranch(Engine.scala:379)
	at org.scalatest.SuperEngine.runTestsImpl(Engine.scala:461)
	at org.scalatest.FunSpecLike$class.runTests(FunSpecLike.scala:497)
	at org.scalatest.FunSpec.runTests(FunSpec.scala:1630)
	at org.scalatest.Suite$class.run(Suite.scala:1147)
	at org.scalatest.FunSpec.org$scalatest$FunSpecLike$$super$run(FunSpec.scala:1630)
	at org.scalatest.FunSpecLike$$anonfun$run$1.apply(FunSpecLike.scala:501)
	at org.scalatest.FunSpecLike$$anonfun$run$1.apply(FunSpecLike.scala:501)
	at org.scalatest.SuperEngine.runImpl(Engine.scala:521)
	at org.scalatest.FunSpecLike$class.run(FunSpecLike.scala:501)
	at com.b.n.filter.ApiKeyVerificationFilterSpec.org$scalatest$BeforeAndAfter$$super$run(ApiKeyVerificationFilterSpec.scala:25)
	at org.scalatest.BeforeAndAfter$class.run(BeforeAndAfter.scala:258)
	at com.b.n.filter.ApiKeyVerificationFilterSpec.run(ApiKeyVerificationFilterSpec.scala:25)
	at org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:314)
	at org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:480)
	at sbt.TestRunner.runTest$1(TestFramework.scala:76)
	at sbt.TestRunner.run(TestFramework.scala:85)
	at sbt.TestFramework$$anon$2$$anonfun$$init$$1$$anonfun$apply$8.apply(TestFramework.scala:202)
	at sbt.TestFramework$$anon$2$$anonfun$$init$$1$$anonfun$apply$8.apply(TestFramework.scala:202)
	at sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:185)
	at sbt.TestFramework$$anon$2$$anonfun$$init$$1.apply(TestFramework.scala:202)
	at sbt.TestFramework$$anon$2$$anonfun$$init$$1.apply(TestFramework.scala:202)
	at sbt.TestFunction.apply(TestFramework.scala:207)
	at sbt.Tests$$anonfun$9.apply(Tests.scala:216)
	at sbt.Tests$$anonfun$9.apply(Tests.scala:216)
	at sbt.std.Transform$$anon$3$$anonfun$apply$2.apply(System.scala:44)
	at sbt.std.Transform$$anon$3$$anonfun$apply$2.apply(System.scala:44)
	at sbt.std.Transform$$anon$4.work(System.scala:63)
	at sbt.Execute$$anonfun$submit$1$$anonfun$apply$1.apply(Execute.scala:228)
	at sbt.Execute$$anonfun$submit$1$$anonfun$apply$1.apply(Execute.scala:228)
	at sbt.ErrorHandling$.wideConvert(ErrorHandling.scala:17)
	at sbt.Execute.work(Execute.scala:237)
	at sbt.Execute$$anonfun$submit$1.apply(Execute.scala:228)
	at sbt.Execute$$anonfun$submit$1.apply(Execute.scala:228)
	at sbt.ConcurrentRestrictions$$anon$4$$anonfun$1.apply(ConcurrentRestrictions.scala:159)
	at sbt.CompletionService$$anon$2.call(CompletionService.scala:28)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
""pool-9-thread-2-ScalaTest-running-BRequestFilterSpec"":
	at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
	- waiting to lock <0x0000000795a868e8> (a sbt.classpath.ClasspathFilter)
	at sbt.classpath.ClasspathFilter.loadClass(ClassLoaders.scala:59)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at net.bytebuddy.dynamic.loading.MultipleParentClassLoader.loadClass(MultipleParentClassLoader.java:68)
	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
	at java.lang.ClassLoader.defineClass1(Native Method)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:760)
	at sun.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:497)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:408)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:185)
	- locked <0x0000000781ee0ff0> (a net.bytebuddy.dynamic.loading.MultipleParentClassLoader)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:187)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4376)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:94)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	- locked <0x00000007959e4a78> (a sbt.classpath.ClasspathUtilities$$anon$1)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
	at org.mockito.Mockito.mock(Mockito.java:1729)
	at org.mockito.Mockito.mock(Mockito.java:1642)
	at org.scalatest.mockito.MockitoSugar$class.mock(MockitoSugar.scala:73)
	at com.b.n.filter.BRequestFilterSpec.mock(BRequestFilterSpec.scala:18)
	at com.b.n.filter.BRequestFilterSpec$Base$class.$init$(BRequestFilterSpec.scala:31)
	at com.b.n.filter.BRequestFilterSpec$$anonfun$7$$anon$10.<init>(BRequestFilterSpec.scala:43)
	at com.b.n.filter.BRequestFilterSpec$$anonfun$7.apply(BRequestFilterSpec.scala:43)
	at com.b.n.filter.BRequestFilterSpec$$anonfun$7.apply(BRequestFilterSpec.scala:43)
	at org.scalatest.OutcomeOf$class.outcomeOf(OutcomeOf.scala:85)
	at org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)
	at org.scalatest.Transformer.apply(Transformer.scala:22)
	at org.scalatest.Transformer.apply(Transformer.scala:20)
	at org.scalatest.FunSpecLike$$anon$1.apply(FunSpecLike.scala:454)
	at org.scalatest.TestSuite$class.withFixture(TestSuite.scala:196)
	at org.scalatest.FunSpec.withFixture(FunSpec.scala:1630)
	at org.scalatest.FunSpecLike$class.invokeWithFixture$1(FunSpecLike.scala:451)
	at org.scalatest.FunSpecLike$$anonfun$runTest$1.apply(FunSpecLike.scala:464)
	at org.scalatest.FunSpecLike$$anonfun$runTest$1.apply(FunSpecLike.scala:464)
	at org.scalatest.SuperEngine.runTestImpl(Engine.scala:289)
	at org.scalatest.FunSpecLike$class.runTest(FunSpecLike.scala:464)
	at com.b.n.filter.BRequestFilterSpec.org$scalatest$BeforeAndAfter$$super$runTest(BRequestFilterSpec.scala:18)
	at org.scalatest.BeforeAndAfter$class.runTest(BeforeAndAfter.scala:203)
	at com.b.n.filter.BRequestFilterSpec.runTest(BRequestFilterSpec.scala:18)
	at org.scalatest.FunSpecLike$$anonfun$runTests$1.apply(FunSpecLike.scala:497)
	at org.scalatest.FunSpecLike$$anonfun$runTests$1.apply(FunSpecLike.scala:497)
	at org.scalatest.SuperEngine$$anonfun$traverseSubNodes$1$1.apply(Engine.scala:396)
	at org.scalatest.SuperEngine$$anonfun$traverseSubNodes$1$1.apply(Engine.scala:384)
	at scala.collection.immutable.List.foreach(List.scala:381)
	at org.scalatest.SuperEngine.traverseSubNodes$1(Engine.scala:384)
	at org.scalatest.SuperEngine.org$scalatest$SuperEngine$$runTestsInBranch(Engine.scala:379)
	at org.scalatest.SuperEngine.runTestsImpl(Engine.scala:461)
	at org.scalatest.FunSpecLike$class.runTests(FunSpecLike.scala:497)
	at org.scalatest.FunSpec.runTests(FunSpec.scala:1630)
	at org.scalatest.Suite$class.run(Suite.scala:1147)
	at org.scalatest.FunSpec.org$scalatest$FunSpecLike$$super$run(FunSpec.scala:1630)
	at org.scalatest.FunSpecLike$$anonfun$run$1.apply(FunSpecLike.scala:501)
	at org.scalatest.FunSpecLike$$anonfun$run$1.apply(FunSpecLike.scala:501)
	at org.scalatest.SuperEngine.runImpl(Engine.scala:521)
	at org.scalatest.FunSpecLike$class.run(FunSpecLike.scala:501)
	at com.b.n.filter.BRequestFilterSpec.org$scalatest$BeforeAndAfter$$super$run(BRequestFilterSpec.scala:18)
	at org.scalatest.BeforeAndAfter$class.run(BeforeAndAfter.scala:258)
	at com.b.n.filter.BRequestFilterSpec.run(BRequestFilterSpec.scala:18)
	at org.scalatest.tools.Framework.org$scalatest$tools$Framework$$runSuite(Framework.scala:314)
	at org.scalatest.tools.Framework$ScalaTestTask.execute(Framework.scala:480)
	at sbt.TestRunner.runTest$1(TestFramework.scala:76)
	at sbt.TestRunner.run(TestFramework.scala:85)
	at sbt.TestFramework$$anon$2$$anonfun$$init$$1$$anonfun$apply$8.apply(TestFramework.scala:202)
	at sbt.TestFramework$$anon$2$$anonfun$$init$$1$$anonfun$apply$8.apply(TestFramework.scala:202)
	at sbt.TestFramework$.sbt$TestFramework$$withContextLoader(TestFramework.scala:185)
	at sbt.TestFramework$$anon$2$$anonfun$$init$$1.apply(TestFramework.scala:202)
	at sbt.TestFramework$$anon$2$$anonfun$$init$$1.apply(TestFramework.scala:202)
	at sbt.TestFunction.apply(TestFramework.scala:207)
	at sbt.Tests$$anonfun$9.apply(Tests.scala:216)
	at sbt.Tests$$anonfun$9.apply(Tests.scala:216)
	at sbt.std.Transform$$anon$3$$anonfun$apply$2.apply(System.scala:44)
	at sbt.std.Transform$$anon$3$$anonfun$apply$2.apply(System.scala:44)
	at sbt.std.Transform$$anon$4.work(System.scala:63)
	at sbt.Execute$$anonfun$submit$1$$anonfun$apply$1.apply(Execute.scala:228)
	at sbt.Execute$$anonfun$submit$1$$anonfun$apply$1.apply(Execute.scala:228)
	at sbt.ErrorHandling$.wideConvert(ErrorHandling.scala:17)
	at sbt.Execute.work(Execute.scala:237)
	at sbt.Execute$$anonfun$submit$1.apply(Execute.scala:228)
	at sbt.Execute$$anonfun$submit$1.apply(Execute.scala:228)
	at sbt.ConcurrentRestrictions$$anon$4$$anonfun$1.apply(ConcurrentRestrictions.scala:159)
	at sbt.CompletionService$$anon$2.call(CompletionService.scala:28)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)

Found 1 deadlock.

```



ApiKeyVerificationFilter, line 77 is `val apikey = mock[ImmutableMap[String, ChildData]]` and BRequestFilterSpec line 31 is val pmap = mock[ParamMap].


sbt prompt looks like this:
```
$ sbt8             
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=256M; support was removed in 8.0
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=512M; support was removed in 8.0
[info] Loading global plugins from /Users/m/.sbt/0.13/plugins
[info] Loading project definition from  ...
[info] Set current project to newton-api (in build file:...)
> test
[info] NServiceModuleSpec:
[info] NServiceModule
[info] - should have a test !!! IGNORED !!!

-- hangs here --
```

Mac OS 10.11.6
java version ""1.8.0_45""
Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)
sbt 0.13.9
""org.scalatest""           %%   ""scalatest""        %   ""3.0.1""   %   ""test"",
""org.mockito""              %   ""mockito-core""   %   ""2.7.22""  %   ""test""


`parallelExecution in Test := true` in build.sbt  -  setting this to false circumvents the issue.""It seems to me as if you are defining circular class loading hierarchies. With Mockito 2, we are applying more fine grained locking to improve concurrency. The difference is displayed in the stack trace where `findOrInsert` aquires a lock for the class loader of the mock class before creating a mock. The previous solution always aquired a global lock what made it impossible to create to mock classes concurrently.

The relevant part:

```
at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
- waiting to lock <0x00000007959e4a78> (a sbt.classpath.ClasspathUtilities$$anon$1)
at java.lang.ClassLoader.loadClass(ClassLoader.java:411)
- locked <0x0000000795a868e8> (a sbt.classpath.ClasspathFilter)
	
at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
- waiting to lock <0x0000000795a868e8> (a sbt.classpath.ClasspathFilter)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
- locked <0x00000007959e4a78> (a sbt.classpath.ClasspathUtilities$$anon$1)
```

How can it be that `sbt.classpath.ClasspathFilter` delegates to `sbt.classpath.ClasspathUtilities$$anon$1` where the latter apparently also reqires locking the former? Class loaders should only be used in strict hierarchies. =||= So both Maps are abstract, I'll try mocking concrete implementations. That might have caused the classloaders to kick in. I try to rewrite some of the tests to use specific implementations instead of abstract classes, but for i.e. ImmutableMap that's gonna be difficult as far as I can see.

edit:
Switched to a concrete Map, just deadlocks somewhere else now, while mocking a Finagle Service[Request, Response] and a simple trait, same locks as before though.

```
Found one Java-level deadlock:
=============================
""Timer-0"":
  waiting to lock monitor 0x00007f4d08002a48 (object 0x00000000c2857fb8, a sbt.classpath.ClasspathUtilities$$anon$1),
  which is held by ""pool-9-thread-6-ScalaTest-running-BRequestFilterSpec""
""pool-9-thread-6-ScalaTest-running-BRequestFilterSpec"":
  waiting to lock monitor 0x00007f4d34003f08 (object 0x00000000c2857f60, a sbt.classpath.ClasspathFilter),
  which is held by ""pool-9-thread-7-ScalaTest-running-JFilterSpec""
""pool-9-thread-7-ScalaTest-running-JFilterSpec"":
  waiting to lock monitor 0x00007f4d08002a48 (object 0x00000000c2857fb8, a sbt.classpath.ClasspathUtilities$$anon$1),
  which is held by ""pool-9-thread-6-ScalaTest-running-BRequestFilterSpec""
``` =||= I've run into this same problem recently as well and my jstack was identical to the OP's. I've started playing around with the mockito versions and I'm not sure if this helps, but using mockito 2.6.6 in my tests didn't result in a deadlock, while using 2.6.7+ did result in deadlock. =||= Maybe we need to add a property that can be enabled to avoid the more fine-grained locking for the type cache. I would still like to know what is causing this as I even stress-tested the cache lock but I cannot reproduce the locking.

Is there any project that I can build that reliably reproduces this? =||= I'm not sure if it's the same problem but I got similar deadlock after specs2 update:
```
17:57:32 	at java.lang.ClassLoader.loadClass(ClassLoader.java:404)
17:57:32 	- waiting to lock <0x00000000d7fda228> (a java.lang.Object)
17:57:32 	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
17:57:32 	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
17:57:32 	at java.lang.Class.getDeclaredMethods0(Native Method)
17:57:32 	at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)
17:57:32 	at java.lang.Class.getDeclaredMethods(Class.java:1975)
17:57:32 	at net.bytebuddy.description.method.MethodList$ForLoadedMethods.<init>(MethodList.java:90)
17:57:32 	at net.bytebuddy.description.type.TypeDescription$ForLoadedType.getDeclaredMethods(TypeDescription.java:7232)
17:57:32 	at net.bytebuddy.description.type.TypeDescription$Generic$OfNonGenericType.getDeclaredMethods(TypeDescription.java:3349)
17:57:32 	at net.bytebuddy.dynamic.scaffold.MethodGraph$Compiler$Default.doAnalyze(MethodGraph.java:576)
17:57:32 	at net.bytebuddy.dynamic.scaffold.MethodGraph$Compiler$Default.analyze(MethodGraph.java:537)
17:57:32 	at net.bytebuddy.dynamic.scaffold.MethodGraph$Compiler$Default.doAnalyze(MethodGraph.java:573)
17:57:32 	at net.bytebuddy.dynamic.scaffold.MethodGraph$Compiler$Default.compile(MethodGraph.java:508)
17:57:32 	at net.bytebuddy.dynamic.scaffold.MethodGraph$Compiler$AbstractBase.compile(MethodGraph.java:408)
17:57:32 	at net.bytebuddy.dynamic.scaffold.MethodRegistry$Default.prepare(MethodRegistry.java:418)
17:57:32 	at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:162)
17:57:32 	at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:155)
17:57:32 	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2560)
17:57:32 	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase$Delegator.make(DynamicType.java:2662)
17:57:32 	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:94)
17:57:32 	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
17:57:32 	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
17:57:32 	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
17:57:32 	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
17:57:32 	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
17:57:32 	- locked <0x0000000080591100> (a sun.misc.Launcher$AppClassLoader)
17:57:32 	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
17:57:32 	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
17:57:32 	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
17:57:32 	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
17:57:32 	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
17:57:32 	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
17:57:32 	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
17:57:32 	at org.mockito.Mockito.mock(Mockito.java:1729)
17:57:32 	at org.mockito.Mockito.mock(Mockito.java:1642)
17:57:32 	at org.specs2.mock.MockitoMocker$class.mock(MockitoMocker.scala:21)
17:57:32 	at org.specs2.mock.mockito.TheMockitoMocker$$anon$1.mock(TheMockitoMocker.scala:8)
17:57:32 	at org.specs2.mock.mockito.MocksCreation$class.mock(MocksCreation.scala:18)
``` =||= @raphw 
> Is there any project that I can build that reliably reproduces this?

This seems to be happening for every travis build for https://github.com/lucidsoftware/xtract

However, it doesn't happen when I build locally.

I was able to reproduce by building it in the travisci/ci-garnet:packer-1512502276-986baf0 docker image. Which is how I was able to get a thread dump and figure out that this is a likely cause.

Now that I have identified what the problem probably is, I'll try to fix future builds, but a commit id that is broken is 1939ab6798c974e4238439d04ba54a71ece5c31c.

From the thread dump, I think the applicable code is:

```scala
  private class PureXmlReader[T](result: T) extends XmlReader[T] {
    def read(elem: scala.xml.NodeSeq): ParseResult[T] = ParseSuccess(result)
  }

  private class PartialSuccessXmlReader[T](result: T, errors: Seq[ParseError]) extends XmlReader[T] {
    def read(elem: scala.xml.NodeSeq): ParseResult[T] = PartialParseSuccess(result, errors)
  }

  def successXmlReader[T](result: T): XmlReader[T] =
    spy(new PureXmlReader(result))

  def partialSuccessXmlReader[T](result: T, errors: Seq[ParseError]): XmlReader[T] =
    spy(new PartialSuccessXmlReader[T](result, errors))
```

It seems successXmlReader and partialSuccessXmlReader are being called simultaneously, and creating the spies concurrently results in a deadlock. The fact that both PureXmlReader and PartialSuccessXmlReader extend XmlReader is suspicious.

I can give you the full thread dump if you want, but it is pretty similar to the original post. =||= In my case I had to fix it by adding `sequential` to the Specification to preven examples from being executed in parallel. =||= Hey guys, we're planning to merge the fix soon. Thank you for patience and reporting another use case here! =||= "Prevent class loading race condition"Allow singleton locking in context with class loading races.

Fixes #1067"Rafael Winterhalterraphw03/15/18, 03:38:03 PM
792.01272New lenient() strictness setting available at mock and at stubbing level"## Problems

Overview of strictness: #769

1. It is not possible to have any common stubbing when using Strictness.STRICT_STUBS. Strict stubs is very useful and it is most likely the future default for Mockito 3. Common stubbing typically is a part of ""before"" method or a test utility class that generates mocks.

```java
public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);

@Before public void before() {
  //a) common stubbing, needed for most test methods
  when(mock.foo()).thenReturn(""bar"");  
}
```

2. API caveats:

```java
@Test public void demo() {
  //b) not possible to stub the same method using 'when', with different args:
  when(mock.foo(1)).thenReturn(1);
  when(mock.foo(2)).thenReturn(2); // <- will throw PotentialStubbingProblem

  //c) code under test cannot use stubbed call with different argument (sometimes we need it)
  when(mock.foo(1)).thenReturn(1);
  mock.foo(2); // <- will throw PotentialStubbingProblem whether we need it or not
}
```

## Suggested solution

New public API overview:

```java
@Test public void demo() {
  //1. New method on MockSettings interface:
  Foo mock = Mockito.mock(Foo.class, withSettings().lenient());

  //2. New method on Mockito class:
  Mockito.lenient().when(mock.foo(1)).thenReturn(1);
  Mockito.lenient().doReturn(1).when(mock).foo(1);
}
```

Details:
 - Why 2 new public methods? Sometimes common stubbing has a form of one or few stubbings in ""before"" method - it's best to configure leniency per stubbing. Sometimes a mock object has many common stubbings (described in detail in the ticket thread below) - it's best to configure leniency per mock.

## Examples

1. Common stubbing

```java
public MockitoRule rule = MockitoJUnit.rule().strictness(Strictness.STRICT_STUBS);
@Mock(lenient = true) Foo mock;

@Before public void before() {
  //a) common stubbing, needed for most test methods
  when(mock.foo()).thenReturn(""bar"");  
}
```

2. API caveats:

```java
@Test public void demo() {
  //b) not possible to stub the same method using 'when', with different args:
  lenient().when(mock.foo(1)).thenReturn(1);
  when(mock.foo(2)).thenReturn(2); // <- works!

  //c) code under test cannot use stubbed call with different argument (sometimes we need it)
  lenient().when(mock.foo(1)).thenReturn(1);
  mock.foo(2); // <- works!
}
```

## Original report

The new UnnecessaryStubbingException logic is great. However, it is sometimes useful to disable this detection for specific methods. Could it be possible to add an annotation that says ""unnecessary stubs should not be detected in this method""?

This would also make it easier to migrate from Mockito 1.* to Mockito 2. This is the case in the project I am currently working at, where we have created some utility methods that creates a mock and configures it to fit most of our use cases. As we use this method at many places, where different configuration is needed, it will cause a lot of unnecessary stubbing. Thus, we would like to keep this method out of unneccessary stubbing-check, while doing this check on the rest of the code base.""Thank you very much for this feedback!

Do you use the silent JUnit Runner currently to avoid the exception in your scenario?

Your feedback and recent code review from @bric3 made me think about enabling/disabling stubbing strictness per method or per class using annotations. For example (brainstorming):

```java
@Mockito(strictStubs = true)
public class SomeTest {

  @Test
  @Mockito(strictStubs = false)
  public void someTestMethod() {

  }
}
``` =||= Thanks for following up on this!

Yes, we currently use the silent runner, which works fine, but of course lacks the stubbing checking that we would like to have on the rest of the methods.

Annotations for this sounds to me like a good solution to the problem. It would be really great if this annotation could also be used on helper methods, such as in our scenario:
```

@Mockito(strictStubs = true)
public class SomeTest {

@Test
public void someTestMethod() {
    Code code = createCode(""A"");
}

@Mockito(strictStubs=false)
 private Code createCode(String codetype) {
    Code code = mock(Code.class);
    doReturn(codetype).when(code).getCodetype(); // Not always, but in most cases, invoked
 }
}

```
 =||= Thanks for the suggestions! My feedback / questions:

1. Is there a reason why you use the runner and not Mockito JUnit rule?
2. The annotation API would not work on the helper methods, only on the test methods. It's because the rule only captures and provides the test method to the implementation. =||= Thanks for your feedback!

1. No, not really. We have not really looked at the difference nor taken a conscious choice on this.
2. Oh, I see. That means that it would be hard to use annotations to do this the way I was hoping was possible. Ideally, it would be great if we could enable unnecessary stubbing in general, but configure it so a developer could call the createCode method without having to mind the unnecessary stubbing here. Or perhaps by setting some properties on the JUnitRunner? So that createCode could be something like

    ```java
    private Code createCode(String codetype) {
       jUnitRunner.DISABLE_STUBBING_CHECK();
       Code code = mock(Code.class);
       doReturn(codetype).when(code).getCodetype(); // Not always, but in most cases, invoked
       jUnitRunner.ENABLE_STUBBING_CHECK();
    }
    ```

I am not that into the Mockito codebase, but I would guess that this could require quite some rewrite?

 (And it also indicates that our usage of helper methods are probably not a smart path to follow...) =||= My point on helper method or helper object for mocks is usually that the model shows mock anti pattern. Or that the granularity of the test is not narrow enough. Usually that means that a concrete object should be **built** instead, not a mock.

The idea may be intersting though, probably not in mockito 2. In mockito 3 (JDK8) maybe we could introduce apis like this :

```java
mockitoRule.inConfiguration()
                     .strictness(Strictness.LENIENT)
                     .stub(() -> { 
                           doReturn(codetype).when(code).getCodetype(); // possible stub
                           // ...
                     });
```

_The above snippet is mostly exploring idea for this kind of API as I don't have these kind of needs at this time, it may be just wrong in many aspects._ =||= See #840 - I created a proposal for solving this use case for JUnit rules =||= As an alternative solution, could you use the MockSettings? e.g. something like ..

```
Code code = mock(Code.class, withSettings().noUnnecssaryStubbing());
``` =||= I also found a use case:

I'm mocking ZK which uses a lot of map-like structures which are exposed via accessors (`getAttributes()`, `getAttribute(String)`, `getAttribute(String, boolean)`, `setAttribute()`, ...).

In my test setup, I create a map and I'm using `thenAnswer()` and `doAnswer()` to link the accessor methods to my test map. The code then looks like this:

```
    private Map<String, Object> desktopAttributes = new LinkedHashMap<>();
...
            desktopAttributes.put(ATTR_EVENT_QUEUES, desktopEventQueues);

            MockDesktop desktop = mock(MockDesktop.class);
            when(desktop.getAttributes()).thenReturn(desktopAttributes);
            when(desktop.getAttribute(ArgumentMatchers.anyString()))
            .thenAnswer(answer -> {
                String name = answer.getArgument(0);
                Object value = desktopAttributes.get(name);
                return value;
            });
            when(desktop.getAttribute(ArgumentMatchers.anyString(), Mockito.anyBoolean()))
            .thenAnswer(answer -> {
                String name = answer.getArgument(0);
                Object value = desktopAttributes.get(name);
                return value;
            });
            doAnswer(answer -> {
                String name = answer.getArgument(0);
                Object value = answer.getArgument(1);
                desktopAttributes.put(name, value);
                return null;
            }).when(desktop).setAttribute(Mockito.anyString(), Mockito.any());
            doAnswer(answer -> {
                String name = answer.getArgument(0);
                Object value = answer.getArgument(1);
                desktopAttributes.put(name, value);
                return null;
            }).when(desktop).setAttribute(Mockito.anyString(), Mockito.any(), Mockito.anyBoolean());
            when(desktop.hasAttribute(Mockito.anyString()))
            .thenAnswer(answer -> {
                String name = answer.getArgument(0);
                return desktopAttributes.containsKey(name);
            });
            when(desktop.hasAttribute(Mockito.anyString(), Mockito.anyBoolean()))
            .thenAnswer(answer -> {
                String name = answer.getArgument(0);
                return desktopAttributes.containsKey(name);
            });
```

I need this code block three times (desktop attribute map, session attributes, servlet context attributes). I prefer mocking over mock objects since the interfaces have hundreds of methods.

I have put this code into a shared JUnit rule. It's lazy but it's also generic: Since the rule doesn't know what parts of ZK the test will call, it can't tell which accessor methods will be needed. But I still need to know when a method is called which wasn't mocked.

Therefore, I need a way to tell Mockito ""there might be unused stubs in the following code block but that's ok since it's shared by many tests"". An annotation on the test won't work since the code is in a JUnit rule. I could pass the MockitoRule to my rule, so this approach would work:

    mockitoRule.lenientStubbing(() -> { ... }); =||= @digulla, thank you for reporting! Some feedback:

- The code looks really hard to read (many lines of mock interactions). I suggest to rethink testing strategy, refactor the code under test so that it is easier to test, or roll out hand mocks.
- Given above, we cannot consider it as a legit use case. We want to avoid implementing features / API for code that should be cleaned up / refactored for simplicity and testability.
- Given that #840 solves this use case ('strictness' method on the rule object), I'm closing this ticket.

Ah, it was interesting to refresh my memory about this ticket :) Hope that helps! =||= @mockitoguy  Sorry, that doesn't help at all.

With ~200K on StackOverflow, that was the most simple solution I could come up with. You're welcome to show me a better solution.

The testing strategy is sound. It doesn't break easily or unexpectedly and is easy to understand for new members of the team. I could copy only the necessary lines to new tests but that would mean I would be the only one who can write new tests. Also: Violates DRY.

Refactoring is not possible. ZK is a UI framework with a huge code base and many projects use it. Asking to change the API is like asking to ""fix"" the Java Collections API: Understandable, maybe even reasonable but unrealistic.

Hand mocks would mean I would have to write about a lot of useless code which violates your own rule to keep tests simple.

So I'm between a rock and a hard place: You're right for open source projects which no one uses or green field commercial projects. For existing commercial projects that I can't move, it's not helpful. They have ugly and unmodifiable APIs, so I have to move the only place where I have influence: That's the tests.

So for now, I have to disable a good feature of Mockito and can no longer make sure that my tests stay clean. That really sucks. =||= Thank you for describing your context! Let me think about this and I'll get back. =||= I guess my use case is ""I'm writing a mocking framework for some commercial API which helps other developers to write tests."" That means I'll always overmock. In my case, I have to mock several Map-like APIs which are exposed in several beans without a common interface (just like the attribute maps in J2EE ServletContext and ServletRequest and the headers in ServletResponse). =||= @digulla that pretty much matches my use case too. IMHO a good solution would be to be able to specify ‘Silent’ at mocked object level rather that the test class level.  =||= I like the idea of adding new public API for this use case.

@digulla, with my earlier reply, I did not intend to depreciate your efforts in getting clean tests for your entire team. It’s great that you’re pushing for this!

The use case you describe could be solved more cleanly with hand stubs. Sometimes simpler code is actually more code :) What do you think about this idea:
 - noop implementation of the 3rd party interface. Generated automatically with IDE, cheap to maintain regardless of amount of methods because they are all noop. Low to zero cognitive overhead for the team.
 - hand stub implementation, extends the noop implementation. Tailored for what exactly the tests need.

Coming back to Mockito for this use case. I bet that our users would disable strictness per entire test, rather than build hand stubs (even if hand stubs would be a better solution). Disabling strictness per entire test nullifies strictness benefits. To provide best dev experience, Mockito should honor this use case and offer a better API.

There are 2 main alternatives:

1) strictness per mock, as suggested

```java
mock(Foo.class, withSettings().strictness(Strictness.LENIENT));
mock(Foo.class, withSettings().lenient()); //alias
```

2) strictness per stubbing, for example:

```java
lenient().when(mock.foo()).thenReturn(“boo”);
lenient().doReturn(“boo”).when(mock).foo();
```

Any feedback?

Thank you guys for feedback and for pushing us to reconsider. We're trying to keep Mockito API slim and avoid solving use cases better solved by refactoring / cleanup the code. =||= I did wonder about something like ...

```
@Mock (strictness= Strictness.LENIENT) 
private Foo mockFoo;
```

as well, but I wonder if that syntax would over-encourage people to use the feature; IME I think the sort of test frameworks, fixtures etc. where I see this to be most useful probably use the mock(Foo.class) mechanism for instantiating mocks.  =||= @mockitoguy 

>There are 2 main alternatives:

I see a third one. As discussed in the JUnit 5 PR (#1221) and the [mockito google group](https://groups.google.com/forum/#!topic/mockito/R1L1aG2RgBQ) I would like to propose an annotation base approach that can be applied also at test-class and test-method level. This keeps the API consistent and slim (at least when JUnit5 is used).

```
@Mock
@Strictness(LENIENT)
Foo mock;
``` =||= @ChristianSchwarz, you're right! Sorry for discounting the annotation option. =||= I plan to tidy up this ticket in the next few days so that it documents the use case, the implementation options and the desired implementation.

@ChristianSchwarz, strictness per method is not an ideal solution for the use case described in this ticket:
 1. every time someone uses shared stub object, he needs to remember to use lenient strictness on the method level
 2. method level strictness turns off useful stubbing validation for all mocks in the method, rather than only for the mocks that really need it.
 3. it does not communicate the intent well. The reader of the test method does not know why lenient strictness is needed for method. This also can lead to cargo culting - developer copy paste-ing test methods along with strictness setting, without known why they need it.

I must admit that the @Strictness annotation does look handsome in the test :)

What do you think about option 1 and 2? Do we want to implement both? Perhaps we start with mock level annotation for now. It solves the use case very well and is not very controversial. =||= @mockitoguy 

> @ChristianSchwarz, strictness per method is not an ideal solution for the use case described in this ticket:

Thats why I proposed to use the `@Strictness` annotation at field level for this use-case too. 

The `@Strictness` annotation at field level would also fit into the annotation proposal for JUnit5.  This in return would lead to a clean single API, where strictness is defined at field, method and class level the same way using `@Strictness`.

> What do you think about option 1 and 2? 

I would prefer option 1 cause:
 * It feels consistent with other mock setting configurations
 * It allows to implement the annotation based proposal too
 * option 2 would add an other alias like API for stubbing, thats uncool

>Do we want to implement both? 

Option1 + `@Strictness` ? Yes!

>Perhaps we start with mock level annotation for now. It solves the use case very well and is not very controversial.

`@Mock` + `@Strictness(...)`  or `@Mock(strictness=...)` ? I would opt for `@Strictness(...)`  cause it allows more uses cases. =||= >That's why I proposed to use the @Strictness annotation at field level for this use-case too.

That's fair!

Let's discuss the 2 contention points:

1. It is awkward that some mock properties are configured as parameter of the existing @Mock annotation, while some other (Strictness) is a standalone annotation.
2. We need to support Strictness at mock level via imperative API, e.g. ""withSettings().lenient()"" method (or something like that). This is one of our principles of API development (which we should document :), annotations are ""syntax sugar"" - all Mockito features are available via imperative API. Given that we implement ""withSettings().lenient()"", why do we need @Strictness annotation at all? I'm pushing on this, because the only thing better than clean API is clean and simple API. The less methods, annotations, complexity - the better! =||= @mockitoguy  Re ""hand stubbed"": That doesn't work since Java doesn't allow multiple inheritance. I just pasted a small part of the actual test setup. My setup class can mock several aspects of the ZK API: Session and request attributes, event queues, view models, injection. What I end up with a mix of lenient and dedicated mocks.

With a hand stubbed approach, I would have to copy a lot of code from test to test. My goal is to have lenient mocks for unimportant parts like session attributes (code under test will complain when they are missing) but strict checking for things like events published (I really don't want to miss those).

The test can then say ""hey, wire up event publishing"" if they expect events. Without the setup, any code using events will just crash with NPE. With the setup, Mockito should complain when no events related code was executed to keep the tests clean (to avoid devs doing copy&paste of code they don't understand).

Re annotations: I don't think that the annotations are a good solution here. They are nice for code which needs to be migrated from old Mockito but for new code, they are too coarse for all my use cases.

On the other hand, I don't like the idea of having to add `withSettings().lenient()` in many places. It would be great if I could execute a bunch of stub calls in a single lenient code block. If that was possible, I'd opt for an annotation on the setup method which calls the `when()`/`doReturn()` but I don't think there is an easy way to implement this when the setup method is not inside the test class but in a JUnit `@Rule` implementation. =||= Thank you for reply! I'm still interested in your use case hence my further questions.

>With a hand stubbed approach, I would have to copy a lot of code from test to test. 

Why? Hand stub implementation should have all the common reusable code. In the test, you can just call ""mock.setupEventPublishing()"" or something like that.

>On the other hand, I don't like the idea of having to add withSettings().lenient() in many places. It would be great if I could execute a bunch of stub calls in a single lenient code block.

Provided that we add both: stubbing + mock level strictness setting, then you have 2 options:

1. Only add ""withSettings().lenient()"" at mock creation time, only for mocks that act as ""reusable business stubs"" (wasn't sure how to call them). When you write stubbings, you don't specify ""lenient()"".
2. For other cases, where you have a default stubbing reused in most of the test methods, you declare the default stubbing using ""lenient()"" method at the stubbing level.

Thoughts? =||= @mockitoguy Thanks. I feel that I don't have a completely clear picture, yet.

> Hand stub

So a base class with a lot of empty methods and then using spy() to overwrite them? That might work but I don't like spy() (had too many problems with that approach in the past).

It still feels like more effort than simply wire some map methods to API methods using `Answer`.

> 2 options

Option #1 is too coarse for me. With option #2, I would have to add 7 lines of code to the block in https://github.com/mockito/mockito/issues/792#issuecomment-344198135 and you were complaining that the code was already too complicated :-)

That's why I suggested to have an ""enable some options for a code"" block approach. In my case, I could then wrap the call to the `setupDesktopAttributes()` method with that. =||= >So a base class with a lot of empty methods and then using spy() to overwrite them?

Hand stub/mock is a class that is completely tailored for the business of your tests. Sometimes referred as ""test fixture code"", ""test utils"", ""test support classes"". Hand mocks don't use Mockito, not even spy(). Hand stub needs to be coded and maintained but it provides superior readability and usefulness because it is tailored to your domain.

>Option #1 is too coarse for me. With option #2, I would have to add 7 lines of code to the block

We could potentially provide a method like:

```java
Mockito.lenient(() -> { ... });
```

Not sure about this, though. It's a very different API than what we have so far. Per-mock + per-stubbing leniency feels like a happy medium: if repeated ""lenient()"" is a problem, you can configure it per the entire mock. Per-mock is coarse grained but on the other hand it is conventional and simple. Big ""lenient"" block might lead to weird test code, developers putting more code inside the block, the intent of the code getting obscured. =||= Updated the description with the problem statement and proposed API changes. Feedback before we start coding? =||= Update: work in progress in PR #1272.

Friendly ping for review of the design outlined in this ticket description! =||= I'm pondering the two API designs: `mock(..., withSettings().lenient())` and `lenient().when(...)`
I feel it would be better if the two were more similar.

Why not `when(..., withSettings().lenient())`? That way, the API would be more symmetric. When adding more settings, they would naturally flow into the existing code. But it would be hard to add options only for `mock()` (= problems can only be discovered at runtime).

What about  `mock(...).lenient()`? Or `lenient().mock(...)`? That would be the opposite approach to make the two APIs similar. Here, the chaining pattern can make sure that you can't use options that are illegal.

Also, this is shorter. I feel `withSettings()` adds a lot of visual bloat.

 =||= > I'm pondering the two API designs: mock(..., withSettings().lenient()) and lenient().when(...)
I feel it would be better if the two were more similar.

Yeah, possibly. We also want to have those new API methods consistent / similar with the existing API:
 - currently the way to configure mocks is: withSettings() or annotation
 - stubbing is inconsistent (when vs. doReturn, when vs. given) due to the API evolution and Java limitations. There is no concept of configuring a ""stubbing"" in Mockito API currently (assuming that declaring what happens when stubbed method is called is part of the stubbing, and not an operation of ""configuring stubbing"").

> Why not ```when(..., withSettings().lenient())?```

How would this play with doReturn syntax?

> What about ```mock(...).lenient()?``` Or ```lenient().mock(...)?```

The former is not possible because ```mock()``` returns the type we're mocking. The latter is interesting, problem is that it is inconsistent with how currently mocks are configured (withSettings()).



Thank you for thoughtful feedback! =||= How about a fluent API to mock several methods of a mock at once? That way, I could specify the lenient once at the top? =||= >How about a fluent API to mock several methods of a mock at once? That way, I could specify the lenient once at the top?

Can you write a comment with an example how it would look? This would help us make a decision. Sorry for late answer. Xmas break :) I made progress on the ticket, though! =||= I'm finalizing the implementation in #1272, it will be released within days. =||= "Strictness configurable per mock / stubbing"Fixes #792

### Problem

Today we have strict stubs feature, a key enabler for cleaner tests and improved debuggability. Strict stubs don't work well with ""common stubbing"" pattern. They also don't like when we call stubbed methods with unexpected arguments - even though sometimes it is legit. For more, see #792 

### Solution

```java
@Test public void demo() {
  //1. ""lenient()"" method on MockSettings interface:
  Foo mock = Mockito.mock(Foo.class, withSettings().lenient());

  //2. ""lenient()"" method on Mockito class:
  Mockito.lenient().when(mock.foo(1)).thenReturn(1);
  Mockito.lenient().doReturn(1).when(mock).foo(1);
}
```

For more, see #792

### Public API changes

- New methods:
   - Mockito#lenient()
   - MockSettings#lenient()
   - MockCreationSettings#isLenient()
   - Stubbing#getStrictness()  
- New interfaces:
   - BaseStubber - extracted out from existing ""Stubber"" interface, so that we can reuse API with ""LenientStubber""
   - LenientStubber - instance returned by ""Mockito.lenient()""
- Other changes:
   - Made @org.mockito.NotExtensible annotation public so that we can use it in subpackages"Szczepan Fabermockitoguy07/24/18, 04:14:17 AM
1086.01280Documentation update - MockitoJUnit.strictness(STRICT_STUBS) does not do verifyNoMoreInteractions"### Problem

Our documentation about ""strict stubs"" does not clearly indicate the difference between ""strict mocks"" (described at #1097). In short, ""strict stubs"" are not ""strict mocks"", e.g. we detect unused or incorrectly declared stubs but we don't force the user to verify all interactions.

### Suggested implementation

Suggest an update to the Javadoc that would make things clear? Perhaps on Strictness type or on Strictness.STRICT_STUBS enum value.

### Original report

I'd expect to let this test fail:

```
public class SomeTest {
  @Rule public final MockitoRule mockitoRule = MockitoJUnit.rule().strictness(STRICT_STUBS);

  @Mock Something something;

  @Test public void something() {
    Single.just(1)
        .doOnSuccess(something::add)
        .test()
        .assertResult(1);
  }

  interface Something {
    void add(int i);
  }
}
```

when using `strictness(STRICT_STUBS)`, since I'm not verifying that `something.add(1)` was called.

Adding:

```
  @After public void tearDown() {
    verifyNoMoreInteractions(something);
  }
```

yields the desire red unit test:

```
org.mockito.exceptions.verification.NoInteractionsWanted: 
No interactions wanted here:
-> at tearDown(SomeTest.java:27)
But found this interaction on mock 'something':
-> at io.reactivex.internal.operators.single.SingleDoOnSuccess$DoOnSuccess.onSuccess(SingleDoOnSuccess.java:53)
```

Is this by design?

Junit Version: 4.12
Mockito Version: 2.8.9""Yes, it is by design.

""Strict stubs"" are not ""strict mocks"", e.g. we detect unused or incorrectly declared stubs but we don't force the user to verify all interactions.

If above is not clear in the documentation, can you suggest and update to the Javadoc that would make this clear? Perhaps on Strictness type or on Strictness.STRICT_STUBS enum value. =||= Are there any plans for `Strict mocks` where the above would be detected? =||= >Are there any plans for Strict mocks where the above would be detected?

Yes, we should start supporting strict mocks. I gave a talk at Devoxx conference in San Jose in March and I collected even more feedback for offering strict mocks as an alternative. We have a ticket open at #649 on this but so far we didn't accumulate enough energy to get started on this.

You motivated me to start working on this. I'll commit to produce a design spec for #649 so that it is ready to work on by an eager contributor. How does it sound? :) =||= > I gave a talk at Devoxx conference in San Jose in March and I collected even more feedback for offering strict mocks as an alternative.

That's also where I learned from the `MockitoRule` and the different options. Thanks for that!

> How does it sound? :)

Awesome.

I'd also very much prefer something along the lines of:
 `Mockito.enableStrictMode();`

Where you opt in for strict modes by default and then maybe can opt out for particular mocks.

Do you plan to integrate the above static method call into the MockitoRule so that you can maybe do something like:
`@Rule public final MockitoRule mockitoRule = MockitoJUnit.rule().strictness(STRICT_MOCKS);` that has the behavior of `STRICT_STUBS` and strict mocking?
 =||= The design spec is ready at #1097. Do you want to contribute? :) =||= I'm definitely interested. I might have some time. Would it also be okay to start with a POC and from there go and implement out all of the details?  =||= >Would it also be okay to start with a POC and from there go and implement out all of the details?

Absolutely! Feel free to submit PR with a POC for early review. =||= `release/2.x` is the correct branch to do so, right? =||= Yes please :)
Op ma 29 mei 2017 om 18:14 schreef Niklas Baudy <notifications@github.com>:

> release/2.x is the correct branch to do so, right?
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1086#issuecomment-304694849>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb9S1OMV6VFvnHQkIS66COktib-yMks5r-u7ngaJpZM4NcKVl>
> .
>
 =||= "Update STRICT_STUBS documentation for verifyNoMoreInteractionsFixes #1086Niklas Baudyvanniktech12/27/17, 04:14:11 PM
1232.01301[JUnit5] MockitoSession#initMocks should support multiple test instances  "In order to support nested tests in JUnit5 (see #1221)  MockitoSession#initMocks should allow to pass more than one test instance or allow multiple calls on initMocks with different test instances.

In other words/code:

```
 Mockito.mockitoSession()
            .initMocks(rootTestInstance)
            .initMock(nestedTestInstance)
```

or 

```
 Mockito.mockitoSession()
            .initMocks(rootTestInstance,nestedTestInstance)
```




            ""Related discussion from #1221 
----

@TimvdLippe https://github.com/mockito/mockito/issues/445#issuecomment-357918936
> Regarding #1232: another option would be to not support nesting of test classes. I think we actively have to consider this option, given our public API was apparently coupled to the JUnit4 implementation and we can not ship breaking changes per our policy.


----

@marcphilipp https://github.com/mockito/mockito/issues/445#issuecomment-358106441
> Well, it's @Incubating so you could still change it, right? 😉
> 
> Besides, I think neither of the two proposals would break compatibility, would they? But then again, we should discuss this over at #1232. 🙂

----

@TimvdLippe https://github.com/mockito/mockito/issues/445#issuecomment-358286590
> Hm, looking at it again, it seems that the breaking change is actually in an internal API, namely TestFinishedEvent, which is created in MockitoSession. As such, I think we should be okay actually. I will do a proper investigation this weekend (hopefully, else next week) and update #1221. I hope you are okay with that @ChristianSchwarz ? Once that is done, I can more definitively say the impact on our API and whether we are risking a breaking change. I have good hopes now we might actually dodge that.


----

@marcphilipp https://github.com/mockito/mockito/issues/445#issuecomment-358407562
> `TestFinishedEvent.getTestClassInstance()` and `TestFinishedEvent.getTestMethodName()` are currently only used (twice) like this:
> 
> ```
> String testName = event.getTestClassInstance().getClass().getSimpleName() 
>                   + ""."" + event.getTestMethodName();
> ```
>
> Currently, `DefaultMockitoSession `always uses null for `TestFinishedEvent.getTestMethodName() `which strikes me as odd. I think it would be better if TestFinishedEvent only had two methods: `getFailure()` and getTestName(). Then, MockitoSessionBuilder could get a testName(String) builder method and DefaultMockitoSessionBuilder could pass it to DefaultMockitoSession and so on.
> 
> Alternatively, `MockitoSessionBuilder `could get a `testMethodName()` builder method and pass that on.
> 
> Moreover, I think `MockitoSessionBuilder `should allow to configure a `MockitoLogger`. This way, frameworks like JUnit could pass in a custom implementation. For JUnit Jupiter, a `MockitoLogger `that publishes report entries instead of writing to stdout (which causes problems will parallel execution) comes to mind.
> 
> Thoughts? =||= @TimvdLippe 

> I will do a proper investigation this weekend (hopefully, else next week) and update #1221. I hope you are okay with that @ChristianSchwarz ?

Of course,go ahead!
 =||= @marcphilipp 
>Moreover, I think `MockitoSessionBuilder` should allow to configure a `MockitoLogger`.
>
>Thoughts?

Make sense, should be a new issue.
 =||= Hey guys! What's the next step for closing this issue getting us closer to supporting JUnit5?

@ChristianSchwarz - can you update the ticket and clarify the public API change? Do you suggest adding new ""initMock()"" method? Do you suggest vararg, or consecutive invocation, or both? I would suggest to go for the simplest compatible API change - keeping the existing method, just making it vararg. Will you be able to work on this?

@marcphilipp - thank you for suggestions! For internal refactorings, we are pretty open - do what you think is good for the codebase. For public API changes/additions, we push back by default and we make sure that the use case is very compelling.

Thanks!!! =||= I would say we can change it to a vararg. This ticket basically addresses https://github.com/mockito/mockito/pull/1221/files#diff-6d0d68d3f3e6a783328fbe723a822668R36 which is unfortunate to do right now. If we change it to vararg, we can transform the `testClassInstances` List to an array and make it work :tada:  =||= "Extend MockitoSession(Builder) API to enable usage by testing frameworks"The first commit in this PR fixes #1232. In the additional commits, I've taken the liberty to implement my proposals from https://github.com/mockito/mockito/issues/445#issuecomment-358407562:

- Add `MockitoSessionBuilder.name(String)` to pass a name from the testing framework to the `MockitoSession`
- Add `MockitoSessionBuilder.logger(MockitoSessionLogger)` to customize the logger used for hints/warnings produced when finishing mocking (useful for testing and to connect reporting capabilities provided by testing frameworks such as JUnit Jupiter)
- Add `MockitoSession.finishMocking(Throwable)` to avoid potentially confusing warnings for failing tests
- Add `MockitoSession.setStrictness(Strictness)` to change the strictness of the current session (there were two test cases requiring that)

Each of these changes is in a separate commit. Thus, it should be relatively easy to take only those changes that you think good, or just the first one to fix #1232.

To showcase that this new API is sufficient to implement an extension of a testing framework, I've changed the `JUnitRule` implementation to use it."Marc Philippmarcphilipp02/10/18, 03:48:33 PM
1306.01307InvocationFactory.createInvocation's realmethod cannot throw a Throwable"InvocationFactory.createInvocation takes a Callable that is used to call the real method of the Invocation. If the Invocation throws an Exception the Exception is forwarded from the Callable. Unfortunately Callable can only throw an Exception, not a Throwable.

Hence if the real method throws a Throwable that is neither an Error, RuntimeException or Exception it cannot be forwarded.

I recommend for InvocationFactory.createInvocation to take realMethod argument that can throw a full Throwable.

This is required for fixing: linkedin/dexmaker#64"Update public API of InvocationFactory needed for Android static mocking"Fixes #1306

A real method might throw a Throwable, but the invocations produced by
InvocationFactory call the real method via a Callable that can only
throw a Exception.

Hence add a new method to InvocationFactory that allows to create
invocations with a RealMethodBehavior == a Callable that throws a
Throwable."Philip P. Moltmannmoltmann02/09/18, 01:55:23 PM
1313.01321InlineByteBuddyMockMaker does not clean up stale mocks"**Repro:**

1. Mockito 2.15.2 using mockito-inline
2. With -Xmx64m run
```
@RunWith(JUnit4.class)
public class Stress {
    private static final int NUM_RUNS = 20000;

    public static class TestClass {
        public String returnA() {
            return ""A"";
        }
    }

    /**
     * Test that mocks that are not referenced anymore are properly cleaned up.
     */
    @Test
    public void callALotOfMocks() {
        for (int i = 0; i < NUM_RUNS; i++) {
            TestClass mock = mock(TestClass.class);
            when(mock.returnA()).thenReturn(""B"");

            assertEquals(""B"", mock.returnA());

            if (i % 1024 == 0) {
                System.out.println(""Mocked "" + i + ""/"" + NUM_RUNS);
            }
        }
    }
}
```

**Expected:**

The test eventually finishes

**Observed:**

> Mocked 0/20000
> Mocked 1024/20000
> Mocked 2048/20000
> Mocked 3072/20000
> Mocked 4096/20000
> Mocked 5120/20000
> Mocked 6144/20000
> Mocked 7168/20000
> Mocked 8192/20000
> Mocked 9216/20000
> Mocked 10240/20000
> Mocked 11264/20000
> Exception in thread ""main"" java.lang.OutOfMemoryError: GC overhead limit exceeded
> 	at java.lang.StringCoding$StringDecoder.decode(StringCoding.java:149)
> 	at java.lang.StringCoding.decode(StringCoding.java:193)
> 	at java.lang.String.<init>(String.java:426)
> 	at java.util.jar.Attributes.read(Attributes.java:418)
> 	at java.util.jar.Manifest.read(Manifest.java:199)
> 
> Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread ""main""
> 
> Process finished with exit code 1

**Analysis:**

The `InlineByteBuddyMockMaker` uses a Map<WeakRef\<Mock\>, Handler> in the `mocks` field to store the mocks and their handlers. It relies that the mocks get garbage collected to remove the entry in the map. Unfortunately if there is an invocation on the mock, the handlers keep strong references to the mock in `InterceptedInvocation.mock`, `RealMethodCall.instance`, and `SerializableRealMethodCall.instance`. These are (strong) references by the handler. Hence the mock never gets cleaned up and the map grows indefinitely.

This is not a problem if the mocks get `Mockito.reset` properly or if using a mock maker that does not store the handlers.""Fantastic analysis, thank you! Do you want to take a stab at fixing it?

(ping @raphw, original author of the this mock maker). =||= I will have a look. Great analysis indeed. We will have to weakly reference any mock instance stored in Mockito. This is a straight forwars fi, I hope. =||= I will do it once I have time. (The kid, you k ow.) =||= I saw two problems we need to keep in mind:
- How to weak references interact with serializability
- We have to be vigilant to prevent premature cleaning up of the mock. Is there any possible case where we can gain access to the the invocations / handler without a reference to the mock? =||= I uploaded a fix proposal as fb37a2e even though
- I don't like that we use different kind of invocations for some tests
- The tests pass and I think I serialize properly, but I am not 100% sure as I never dealt with serialization before =||= Hey guys! I was reviewing @moltmann's PR and I'm wondering what are the alternative options to solve the problem. Can we attach a state to the mock object so that MockMakers can do their magic without keeping weak maps of all mocks? @raphw, thoughts? =||= Unfortunately, I do not think that there is an alternative to weak references.

The Java instrumentation API allows the retransformation of Java byte code, it does not allow changing the shape of a class, e.g. adding fields. Naturally, the dispatcher would be placed in such a field such that the life time of a dispatcher would be implicitly bound to the mock instance. But since we cannot add this field, we have to place the instance outside of it such that we have to use weak references to reach the same effect.

Therefore, I fear that this is the only way to go.  =||= Thank you for explanation!

One alternative/supplemental option is to make the lifecycle of mocks more formal. For example, JUnit rule / runner / mockito session can inform the mock maker that ""we're done with mock x"". =||= @mockitoguy If you can make this work, great. I see my mockmaker to be used to a legacy test suites though as they want to just mock one final method and not create a new test suite. Some older suites might not use junit or any other fancy feature.

Hence I would like to find a solution that does not require any changes outside of mockito. =||= @mockitoguy Is there any further change you want to c0ad83a? =||= "Prevent memory leaks with inline MockMakers by using weak refs to mocks"Fixes #1313

This is needed for mock makers that store a map<weakref<mock>, invocation>. If the invocation holds a strong reference to the mock, the key never gets gc-ed and the map keeps on growing.

As weak references cannot be serialized, temporarily create a strong reference during serialization.

As the tests use invocations without keeping references to the mock we need to keep strong references in these cases."Philip P. Moltmannmoltmann03/13/18, 04:00:19 AM
1348.01350Support @Mock injection in JUnit 5 method parameters"JUnit 5 has the ability to ""inject"" parameters into test methods via an extensible ``ParameterResolver`` interface.  The JUnit 5 users guide provides an example that shows how such a ``ParameterResolver`` can supply mock objects as test parameters as follows (shamelessly copied from https://junit.org/junit5/docs/current/user-guide/#writing-tests-dependency-injection):

```
@ExtendWith(MockitoExtension.class)
class MyMockitoTest {

    @BeforeEach
    void init(@Mock Person person) {
        when(person.getName()).thenReturn(""Dilbert"");
    }

    @Test
    void simpleTestWithInjectedMock(@Mock Person person) {
        assertEquals(""Dilbert"", person.getName());
    }

}
```

The prototype ``MockitoExtension`` provided in the JUnit 5 samples project shows a simple implementation of the required ``supportsParameter()`` and ``resolveParameter()`` methods. (See: https://github.com/junit-team/junit5-samples/blob/r5.1.0/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java)

[ ]   Add the ability to inject mock objects into test method parameters to the official ``MockitoExtension``.  References #445""I am 👍 for this feature with the following use case:

Initialization of local variable mocks. Previously this would be `Mock<Generic> mock = mock(Mock.class)`. However, this loses the type-signature of `Generic`. With parameter mocks, we can do `@Mock Mock<Generic> mock` and still maintain the generic type signature. =||= I should also note that I haven't personally used parameter resolution the way it's shown above.  Our team generally either injects the mock object at the class level and configures it in ``@BeforeEach`` **OR** we inject the mock object in the test method and configure it at the top of the test method's block. =||= Yes agreed. Rather than some ""magic"" shared by methods, I think a generics-type-safe replacement for local mock initialization is a lot better. =||= I just edited the description of this issue to include a link to the sample ``MockitoExtension`` (I had intended to provide that reference originally).  I don't know if I'd refer to the the methods sharing the parameter instance as ""magic"" but without looking at the code it certainly isn't clear that the parameters are the shared if the types and names match.  I definitely think that there are use-cases for this technique and the use of ``ExtensionContext.Store`` is a great way to provide references to objects from different methods.  My main concern is that when there is a name collision and the types match, you might end up with behavior that's really hard to understand (without knowing how the underlying extension works).

I'm not sure I'm a fan of the syntax you described above as it seems more redundant than ``@Mock MyWeirdThing myWeirdMock`` - I'm guessing I'm misunderstanding your intention (I get the erasure part). =||= In Junit 4, local mock initialization would be 

```java
class Test {
  @Test
  public void test() {
    Mock<String> mock = Mockito.mock(Mock.class);
  }
  class Mock<T> {}
}
```
This would issue a warning saying that the generic type of `String` is not correctly created by `Mockito.mock`. (Even though we know that our mocks will work)

With this feature, in JUnit 5, we can have:

```java
class Test {
  @Test
  public void test(@Mock Mock<String> mock) {
  }
  class Mock<T> {}
}
```
And the compiler will not warn any longer. =||= I don't remember ever seeing that warning - Perhaps because I've always used the Mockito runner or rule? =||= Correct. You do not get that warning when using the runner. But then you have mocks that are used in every single test. This targets the use case where you need 1 extra mock in only 1 testcase. =||= And if the ``MockitoExtension`` is the JUnit 5 replacement for the runner or rule, why wouldn't those warnings also be suppressed? =||= Because the point of Mock initialization is different. JUnit 4 only supported for attributes. We are now talking about method parameters. Hopefully when I implement this logic, it is more clear to you 😄  =||= I'm not trying to be argumentative ... but as a pretty heavy user of the prototype ``MockitoExtension`` in the https://github.com/junit-team/junit5-samples project we'd have a lot of tests to update with this syntax.  We'll also need to make sure the example in the users guide and (if they're kept) the code in the junit-samples project matches the official implementation.  At this point I should probably let junit-team (I wish I could use a mention here) coordinate that with you.

@sbrannen @marcphilipp @sormuras =||= Looking at the source of https://github.com/junit-team/junit5-samples/blob/7bf40178345d5ca837579c8ddb8c025401a98788/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java I think we should be fine. I will let you know when the PR is open so that you can test that out.

One note: the Mockito team was not involved with the development of the prototype, but I think we will approach very similar capabilities. =||= I was looking at https://github.com/junit-team/junit5-samples/blob/master/junit5-mockito-extension/src/test/java/com/example/mockito/MockitoExtensionWithNestedTests.java because it's got a bunch of use cases including test-local mocks and the ""magic"" you referred to above.  Thinking though the syntax change you're describing, I'll assume that the tests would still run but with the same warning?

I do realize that the Mockito team didn't produce the prototype and it would be unrealistic to think that you should be permanently limited by it architecturally.  I did however think that the syntax ""proposed"" by the prototype was consistent with the field injection that already existed in Mockito.  I'm going to assume that what is produced as the official extension will be well integrated and well maintained - and I never complain about stable tooling! =||= Opened #1350 with a proposal implementation. =||= Okay, to write down the reason I think mock sharing by parameter is not a good idea:

First of all, there is a lot of duplicate code. For every test method, you need to list the mocks, which results in duplicate. Rather, using fields for these mocks removes the duplication.

Secondly, by relying on fields, the compiler will complain when you make a typo (or change a type). With parameters, you rely on the name (String-based) and the type declared. Both are not compiler safe.

Lastly, because you can rely on fields, refactoring is a lot easier, as IDE's support renaming by field. This is not possible for parameters.

For these 3 reasons, I see field mock sharing superior to parameter mock sharing and am therefore against introducing this logic in the parameter resolution. =||= > For these 3 reasons, I see field mock sharing superior to parameter mock sharing and am therefore against introducing this logic in the parameter resolution.

I totally understand the rationale. 👍  =||= What about support for `@Spy` and `@Captor`? Should new issues be created, or can it be part of this one? =||= `@Spy` makes no sense, as it requires a concrete instance. `@Captor` could be done. Let's discuss that in a different issue :+1: as this issue has been resolved. =||= My memory was incorrect, as #1350 has NOT been merged yet. =||= >`@Spy` makes no sense

You are completely right 😄.

I've created #1382 for adding support for `@Captor` =||= There's `Mockito.spy(Class)` which would work for a method parameter. =||= @marcphilipp Ah, yes I see now. Not sure how useful that actually is, as I only learned today we expose that API 😂  =||= "Support local parameters in test methods with JUnit Jupiter"Note that this implementation differs from the prototype implementation of the JUnitTeam (https://github.com/junit-team/junit5-samples/blob/7bf40178345d5ca837579c8ddb8c025401a98788/junit5-mockito-extension/src/main/java/com/example/mockito/MockitoExtension.java#L41-L73). Instead, it will do not do any parameter resolution between test methods.

Fixes #1348 "Tim van der LippeTimvdLippe07/27/18, 05:32:52 AM
1367.01368Interface mock in a child class loader fails since Mockito 2.18.0"Mocking an interface in a child classloader fails if the interface was already mocked in a parent class loader after upgrading to 2.18.0.

I can't currently provide a reproducer as tests pass in isolation. The test failure can be observed only running the whole test suite. The issue occurs only with 2.18.0, 2.17.0 works.

Exception message:

```
Mockito cannot mock this class: interface org.eclipse.persistence.jpa.JpaEntityManager.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 1.8
JVM vendor name    : Oracle Corporation
JVM vendor version : 25.151-b12
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 1.8.0_151-b12
JVM info           : mixed mode
OS name            : Mac OS X
OS version         : 10.13.4


Underlying exception : java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#defineClass
	at org.springframework.data.jpa.provider.PersistenceProviderUnitTests.mockProviderSpecificEntityManagerInterface(PersistenceProviderUnitTests.java:88)
	at org.springframework.data.jpa.provider.PersistenceProviderUnitTests.detectsEclipseLinkPersistenceProvider(PersistenceProviderUnitTests.java:58)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:236)
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:134)
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:113)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)
	at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:103)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:74)
Caused by: java.lang.IllegalStateException: Error invoking java.lang.ClassLoader#defineClass
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:413)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:186)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:199)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4225)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:124)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:345)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:160)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:354)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1875)
	at org.mockito.Mockito.mock(Mockito.java:1784)
	... 32 more
Caused by: java.lang.SecurityException: class ""org.mockito.codegen.JpaEntityManager$MockitoMock$2038182397""'s signer information does not match signer information of other classes in the same package
	at java.lang.ClassLoader.checkCerts(ClassLoader.java:898)
	at java.lang.ClassLoader.preDefineClass(ClassLoader.java:668)
	at java.lang.ClassLoader.defineClass(ClassLoader.java:761)
	at sun.reflect.GeneratedMethodAccessor28.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Direct.defineClass(ClassInjector.java:409)
	... 51 more
```

Link to test code:
[PersistenceProviderUnitTests.java](https://github.com/spring-projects/spring-data-jpa/blob/70d1012ac3ae12f7c7ad4060318ac61a8059db19/src/test/java/org/springframework/data/jpa/provider/PersistenceProviderUnitTests.java#L83).""@raphw Probably yet another edge-case in ByteBuddy :cry:  =||= Ah, of course. We must not define a protection domain for the codegen package anymore since we have already defined a class in this package in order to resolve the method handle lookup in case of Java 11 where the class now has Mockito's protection domain.

That is a trivial fix. =||= "Resolve the correct protection domain for the codegen package when using reflection.Fixes #1367.Rafael Winterhalterraphw04/13/18, 09:07:13 PM
1364.01369Unable to mock interfaces in Android instrumentation tests"Consider the following Android instrumentation test:

```
@Test
public void testMockito() {
    final Collection mockCollection = Mockito.mock(Collection.class);

    Assert.assertTrue(true);
}
```

When run, I see the following output:

```
Testing started at 21:54 ...

04/08 21:54:01: Launching testMockito()
No apk changes detected since last installation, skipping installation of D:\Code\TestApp\app\build\outputs\apk\debug\app-debug.apk
$ adb push D:\Code\TestApp\app\build\outputs\apk\androidTest\debug\app-debug-androidTest.apk /data/local/tmp/com.example.zolbr.testapp.test
$ adb shell pm install -t -r ""/data/local/tmp/com.example.zolbr.testapp.test""
Success


Running tests

$ adb shell am instrument -w -r   -e debug false -e class 'com.example.zolbr.testapp.ExampleInstrumentedTest#testMockito' com.example.zolbr.testapp.test/android.support.test.runner.AndroidJUnitRunner
Client not ready yet..
Started running tests

org.mockito.exceptions.base.MockitoException:
Mockito cannot mock this class: interface java.util.Collection.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.



IMPORTANT INFORMATION FOR ANDROID USERS:

The regular Byte Buddy mock makers cannot generate code on an Android VM!
To resolve this, please use the 'mockito-android' dependency for your application:
http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22

Java               : 0.9
JVM vendor name    : The Android Project
JVM vendor version : 2.1.0
JVM name           : Dalvik
JVM version        : 0.9
JVM info           : null
OS name            : Linux
OS version         : 3.18.56+


Underlying exception : java.lang.IllegalArgumentException: Could not create type
at com.example.zolbr.testapp.ExampleInstrumentedTest.testMockito(ExampleInstrumentedTest.java:40)
at java.lang.reflect.Method.invoke(Native Method)
at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runners.Suite.runChild(Suite.java:128)
at org.junit.runners.Suite.runChild(Suite.java:27)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
at android.support.test.internal.runner.TestExecutor.execute(TestExecutor.java:58)
at android.support.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:375)
at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2074)
Caused by: java.lang.IllegalArgumentException: Could not create type
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:139)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:345)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:160)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:354)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
at org.mockito.android.internal.creation.AndroidByteBuddyMockMaker.createMock(AndroidByteBuddyMockMaker.java:39)
at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
at org.mockito.Mockito.mock(Mockito.java:1875)
at org.mockito.Mockito.mock(Mockito.java:1784)
... 28 more
Caused by: java.lang.IncompatibleClassChangeError: The method 'int java.lang.Object.hashCode()' was expected to be of type interface but instead was found to be of type virtual (declaration of 'net.bytebuddy.dynamic.scaffold.MethodRegistry$Handler$ForImplementation' appears in /data/app/com.example.zolbr.testapp.test-OVcvUgjejP8CYF6lGYt9Pg==/base.apk)
at net.bytebuddy.dynamic.scaffold.MethodRegistry$Handler$ForImplementation.hashCode(Unknown Source:2)
at java.util.HashMap.hash(HashMap.java:338)
at java.util.HashMap.put(HashMap.java:611)
at java.util.HashSet.add(HashSet.java:219)
at net.bytebuddy.dynamic.scaffold.MethodRegistry$Default.prepare(MethodRegistry.java:409)
at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:162)
at net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder.make(SubclassDynamicTypeBuilder.java:155)
at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2669)
at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:123)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
... 39 more
```

This only occurs when using mockito-android 2.18.0:

```
androidTestImplementation 'org.mockito:mockito-android:2.18.0'
```

Downgrading to 2.17.0 fixes this issue.

This occurs on a Windows 10 dev machine running Android Studio 3.1.""This appears to be regression introduced in ByteBuddy. @raphw would you mind investigating? =||= I have same question, can anyone help? =||= I identified the issue. It has to do how hashCode and equals are invoked on interface types. OpenJDK allows for a different convention then what Android accepts. I will fix that with the next release, stick to the old version until then. (It is already fixed on master for Byte Buddy but it is part of the build routine.) =||= Should be fixed in 2.18.2. =||= When will 2.18.2 be available? My project is unable to pick this version up:

```
Failed to resolve: org.mockito:mockito-core:2.18.1
Show in File
Show in Project Structure dialog
```

which makes sense since from the looks of it there is no `ci maven-central-release` commit for 2.18.2. =||= It is availble on bintray. You can add the bintray repository to your
pom.xml to find it.

On Wed, 18 Apr 2018, 04:05 Zach Olbrys, <notifications@github.com> wrote:

> When will 2.18.2 be available? My project is unable to pick this version
> up:
>
> Failed to resolve: org.mockito:mockito-core:2.18.1
> Show in File
> Show in Project Structure dialog
>
> which makes sense since from the looks of it there is no ci
> maven-central-release commit for 2.18.2.
>
> —
> You are receiving this because you commented.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/mockito/mockito/issues/1364#issuecomment-382222421>,
> or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AFrDb_wMgNVW_Sp-pgm391qwCz2L62Gtks5tpp9lgaJpZM4TL0h6>
> .
>
 =||= I've downloaded the jar from here: https://bintray.com/mockito/maven/mockito-development/2.18.2 and added it to my project, but the problem persists. =||= With the same exception message? =||= stacktrace:
```
org.mockito.exceptions.base.MockitoException:
Mockito cannot mock this class: interface com.example.IExample.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.



IMPORTANT INFORMATION FOR ANDROID USERS:

The regular Byte Buddy mock makers cannot generate code on an Android VM!
To resolve this, please use the 'mockito-android' dependency for your application:
http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22mockito-android%22%20g%3A%22org.mockito%22

Java               : 0.9
JVM vendor name    : The Android Project
JVM vendor version : 2.1.0
JVM name           : Dalvik
JVM version        : 0.9
JVM info           : null
OS name            : Linux
OS version         : 4.4.88-gda039c93611c


Underlying exception : java.lang.IllegalArgumentException: Could not create type
at com.example.ExampleTest.<init>(ExampleTest.kt:35)
at java.lang.reflect.Constructor.newInstance0(Native Method)
at java.lang.reflect.Constructor.newInstance(Constructor.java:334)
at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:217)
at org.junit.runners.BlockJUnit4ClassRunner$1.runReflectiveCall(BlockJUnit4ClassRunner.java:266)
at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:263)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runners.Suite.runChild(Suite.java:128)
at org.junit.runners.Suite.runChild(Suite.java:27)
at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
at android.support.test.internal.runner.TestExecutor.execute(TestExecutor.java:58)
at android.support.test.runner.AndroidJUnitRunner.onStart(AndroidJUnitRunner.java:375)
at android.app.Instrumentation$InstrumentationThread.run(Instrumentation.java:2075)
Caused by: java.lang.IllegalArgumentException: Could not create type
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:140)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
at org.mockito.android.internal.creation.AndroidByteBuddyMockMaker.createMock(AndroidByteBuddyMockMaker.java:39)
at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
at org.mockito.Mockito.mock(Mockito.java:1729)
at org.mockito.Mockito.mock(Mockito.java:1642)
... 28 more
Caused by: java.lang.AbstractMethodError: abstract method ""net.bytebuddy.dynamic.loading.ClassLoadingStrategy org.mockito.internal.creation.bytebuddy.SubclassLoader.getStrategy(java.lang.Class)""
at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:94)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
... 39 more
``` =||= It seems like you are using a new version of Mockito Core but an old version of Mockito Android. We had to change an internal API that both versions require to communicate to fix another bug. =||= "Performance improvementsUse less expensive method graph compiler for inline mock maker. Update Byte Buddy for general performance improvements and bug fixes. Fixes #1364. Also fixes javadoc warning.Rafael Winterhalterraphw04/15/18, 08:50:43 PM
1240.01378Mockito Inline can't mock Finatra Response Class"Seen a few of these lying around, but my stacktrace is also different.

I was trying to mock the Finatra `ResponseBuilder` class.

```
You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class com.twitter.finatra.http.response.ResponseBuilder, interface com.twitter.inject.Logging, interface com.twitter.util.logging.Logging]
	at <testclass.java>
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at org.junit.runners.BlockJUnit4ClassRunner.createTest(BlockJUnit4ClassRunner.java:217)
	at org.junit.runners.BlockJUnit4ClassRunner$1.runReflectiveCall(BlockJUnit4ClassRunner.java:266)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.BlockJUnit4ClassRunner.methodBlock(BlockJUnit4ClassRunner.java:263)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.runTestClass(JUnitTestClassExecuter.java:114)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecuter.execute(JUnitTestClassExecuter.java:57)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassProcessor.processTestClass(JUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:109)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:377)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:54)
	at org.gradle.internal.concurrent.StoppableExecutorImpl$1.run(StoppableExecutorImpl.java:40)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
	at java.lang.Thread.run(Thread.java:745)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class com.twitter.finatra.http.response.ResponseBuilder, interface com.twitter.inject.Logging, interface com.twitter.util.logging.Logging]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	... 43 more
Caused by: java.lang.UnsupportedOperationException: class redefinition failed: attempted to change the schema (add/remove fields)
	at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:201)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:182)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:63)
	at org.mockito.Mockito.mock(Mockito.java:1729)
	at org.mockito.Mockito.mock(Mockito.java:1642)
	... 43 more
```
""I'm also unable to mock a final class, I'm using JDK 9 and the project is using kotlin. I'm not sure if it's a related issue, I did try to do some debugging but to no avail. Interestingly, only the first mock fails.

```kotlin
try {
    mock<WorldContext>()
} catch (e: Throwable) {

}
// success
val a = mock<WorldContext>()
```

Complete stacktrace:

```
Mockito cannot mock this class: class io.polymorphicpanda.faux.ecs.WorldContext.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class io.polymorphicpanda.faux.ecs.WorldContext, interface io.polymorphicpanda.faux.ecs.Context]
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: class io.polymorphicpanda.faux.ecs.WorldContext.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class io.polymorphicpanda.faux.ecs.WorldContext, interface io.polymorphicpanda.faux.ecs.Context]
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$worldContext$2.invoke(WorldSpec.kt:91)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$worldContext$2.invoke(WorldSpec.kt:18)
	at org.jetbrains.spek.engine.lifecycle.LifecycleAwareAdapter.invoke(LifecycleAwareAdapter.kt:21)
	at org.jetbrains.spek.engine.lifecycle.LifecycleAwareAdapter.getValue(LifecycleAwareAdapter.kt:17)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$world$2.invoke(WorldSpec.kt:37)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$world$2.invoke(WorldSpec.kt:18)
	at org.jetbrains.spek.engine.lifecycle.LifecycleAwareAdapter.invoke(LifecycleAwareAdapter.kt:21)
	at org.jetbrains.spek.engine.lifecycle.LifecycleAwareAdapter.getValue(LifecycleAwareAdapter.kt:17)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$1.invoke(WorldSpec.kt:40)
	at io.polymorphicpanda.faux.ecs.WorldSpec$1$1.invoke(WorldSpec.kt:18)
	at org.jetbrains.spek.engine.SpekTestEngine$Collector$action$action$1.invoke(SpekTestEngine.kt:175)
	at org.jetbrains.spek.engine.SpekTestEngine$Collector$action$action$1.invoke(SpekTestEngine.kt:133)
	at org.jetbrains.spek.engine.Scope$Action.execute(Scope.kt:48)
	at org.jetbrains.spek.engine.Scope$Action.execute(Scope.kt:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:83)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:51)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
	at org.jetbrains.spek.tooling.runner.junit.JUnitPlatformSpekRunner.run(JUnitPlatformSpekRunner.kt:107)
	at org.jetbrains.spek.tooling.MainKt.main(Main.kt:58)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class java.lang.Object, class io.polymorphicpanda.faux.ecs.WorldContext, interface io.polymorphicpanda.faux.ecs.Context]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	... 52 more
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:120)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:200)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:181)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1821)
	... 52 more
Caused by: java.lang.ClassCircularityError: java/lang/WeakPairMap$Pair$Weak
	at java.base/java.lang.WeakPairMap$Pair.weak(WeakPairMap.java:201)
	at java.base/java.lang.WeakPairMap.putIfAbsent(WeakPairMap.java:123)
	at java.base/java.lang.Module.implAddReads(Module.java:396)
	at java.base/java.lang.Module.implAddReads(Module.java:357)
	at java.base/java.lang.System$2.addReads(System.java:2146)
	at java.base/jdk.internal.module.Modules.addReads(Modules.java:85)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.lambda$getDynamicModule$4(Proxy.java:884)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue$Memoizer.get(AbstractClassLoaderValue.java:327)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue.computeIfAbsent(AbstractClassLoaderValue.java:203)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.getDynamicModule(Proxy.java:875)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.mapToModule(Proxy.java:814)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.<init>(Proxy.java:631)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.<init>(Proxy.java:636)
	at java.base/java.lang.reflect.Proxy.lambda$getProxyConstructor$0(Proxy.java:415)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue$Memoizer.get(AbstractClassLoaderValue.java:327)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue.computeIfAbsent(AbstractClassLoaderValue.java:203)
	at java.base/java.lang.reflect.Proxy.getProxyConstructor(Proxy.java:413)
	at java.base/java.lang.reflect.Proxy.newProxyInstance(Proxy.java:999)
	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:305)
	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:303)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.reflect.annotation.AnnotationParser.annotationForMap(AnnotationParser.java:303)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:293)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72)
	at java.base/java.lang.reflect.Executable.declaredAnnotations(Executable.java:605)
	at java.base/java.lang.reflect.Executable.declaredAnnotations(Executable.java:603)
	at java.base/java.lang.reflect.Executable.getDeclaredAnnotations(Executable.java:591)
	at java.base/java.lang.reflect.Constructor.getDeclaredAnnotations(Constructor.java:579)
	at net.bytebuddy.description.method.MethodDescription$ForLoadedConstructor.getDeclaredAnnotations(MethodDescription.java:912)
	at net.bytebuddy.description.method.MethodDescription$AbstractBase.asToken(MethodDescription.java:695)
	at net.bytebuddy.description.method.MethodDescription$AbstractBase.asToken(MethodDescription.java:334)
	at net.bytebuddy.description.method.MethodList$AbstractBase.asTokenList(MethodList.java:53)
	at net.bytebuddy.dynamic.scaffold.InstrumentedType$Factory$Default$1.represent(InstrumentedType.java:223)
	at net.bytebuddy.ByteBuddy.redefine(ByteBuddy.java:698)
	at net.bytebuddy.ByteBuddy.redefine(ByteBuddy.java:676)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:167)
	at java.instrument/java.lang.instrument.ClassFileTransformer.transform(ClassFileTransformer.java:246)
	at java.instrument/sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at java.instrument/sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:550)
	at java.base/java.lang.WeakPairMap$Pair.weak(WeakPairMap.java:201)
	at java.base/java.lang.WeakPairMap.putIfAbsent(WeakPairMap.java:123)
	at java.base/java.lang.Module.implAddReads(Module.java:396)
	at java.base/java.lang.Module.implAddReads(Module.java:357)
	at java.base/java.lang.System$2.addReads(System.java:2146)
	at java.base/jdk.internal.module.Modules.addReads(Modules.java:85)
	at java.base/jdk.internal.module.Modules.transformedByAgent(Modules.java:166)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:157)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)
	... 65 more


``` =||= We are seeing the same issue using JDK 9 and Kotlin =||= Same issue for JDK10 and Kotlin (and Java) =||= @raphw, I’ve just tried `2.17.3` from `dl.bintray.com/mockito/maven` with `bytebuddy:1.8.1` and this kind of errors still happens. This happened for me after migrating from JDK 8 to JDK 9. A coworker of mine updated his Android Studio from 3.0 to 3.1 and observes the same thing in IDE (running tests via Gradle works fine though). This version of AS actually bundles JDK 8, but the updated revision (I guess). We’ve tried the `2.17.3` as well with no luck. =||= Seems like some JDK internals were switched out such that Byte Buddy tries to instrument classes that it needs itself to apply the instrumentation. This requiressome whitelisting on our side, I believe. =||= Also seeing this when running tests for Spek 2.x (spekframework/spek#318) on JDK9 https://travis-ci.org/patrickpilch/spek/jobs/346058522
I've tried forcing the Byte Buddy version to 1.8.3 but the problem remained.

<details>
<summary>Complete stacktrace</summary>
<p>

```
Mockito cannot mock this class: class org.spekframework.spek2.runtime.lifecycle.LifecycleManager.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class org.spekframework.spek2.runtime.lifecycle.LifecycleManager, class java.lang.Object]"" type=""org.mockito.exceptions.base.MockitoException""><![CDATA[org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: class org.spekframework.spek2.runtime.lifecycle.LifecycleManager.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [class org.spekframework.spek2.runtime.lifecycle.LifecycleManager, class java.lang.Object]
	at org.spekframework.spek2.junit.TestDescriptorAdapterFactoryTest.setup(TestDescriptorAdapterFactoryTest.kt:57)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:389)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.invokeMethodInExtensionContext(ClassTestDescriptor.java:289)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.lambda$synthesizeBeforeEachMethodAdapter$11(ClassTestDescriptor.java:277)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$null$2(TestMethodTestDescriptor.java:132)
	at org.junit.jupiter.engine.execution.ThrowableCollector.execute(ThrowableCollector.java:40)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeMethodsOrCallbacksUntilExceptionOccurs(TestMethodTestDescriptor.java:152)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeBeforeEachMethods(TestMethodTestDescriptor.java:131)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:106)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:83)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$null$2(HierarchicalTestExecutor.java:92)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184)
	at java.base/java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:177)
	at java.base/java.util.Iterator.forEachRemaining(Iterator.java:133)
	at java.base/java.util.Spliterators$IteratorSpliterator.forEachRemaining(Spliterators.java:1801)
	at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:484)
	at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474)
	at java.base/java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)
	at java.base/java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)
	at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)
	at java.base/java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:430)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.lambda$execute$3(HierarchicalTestExecutor.java:92)
	at org.junit.platform.engine.support.hierarchical.SingleTestExecutor.executeSafely(SingleTestExecutor.java:66)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:77)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:51)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
	at org.junit.platform.console.tasks.ConsoleTestExecutor.executeTests(ConsoleTestExecutor.java:65)
	at org.junit.platform.console.tasks.ConsoleTestExecutor.lambda$execute$0(ConsoleTestExecutor.java:57)
	at org.junit.platform.console.tasks.CustomContextClassLoaderExecutor.invoke(CustomContextClassLoaderExecutor.java:33)
	at org.junit.platform.console.tasks.ConsoleTestExecutor.execute(ConsoleTestExecutor.java:57)
	at org.junit.platform.console.ConsoleLauncher.executeTests(ConsoleLauncher.java:85)
	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:75)
	at org.junit.platform.console.ConsoleLauncher.execute(ConsoleLauncher.java:48)
	at org.junit.platform.console.ConsoleLauncher.main(ConsoleLauncher.java:40)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [class org.spekframework.spek2.runtime.lifecycle.LifecycleManager, class java.lang.Object]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:345)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:160)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:354)
	... 59 more
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:120)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:345)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:160)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:354)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:200)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:181)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1855)
	... 59 more
Caused by: java.lang.ClassCircularityError: java/lang/WeakPairMap$Pair$Weak
	at java.base/java.lang.WeakPairMap$Pair.weak(WeakPairMap.java:201)
	at java.base/java.lang.WeakPairMap.putIfAbsent(WeakPairMap.java:123)
	at java.base/java.lang.Module.implAddReads(Module.java:396)
	at java.base/java.lang.Module.implAddReads(Module.java:357)
	at java.base/java.lang.System$2.addReads(System.java:2146)
	at java.base/jdk.internal.module.Modules.addReads(Modules.java:85)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.lambda$getDynamicModule$4(Proxy.java:884)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue$Memoizer.get(AbstractClassLoaderValue.java:327)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue.computeIfAbsent(AbstractClassLoaderValue.java:203)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.getDynamicModule(Proxy.java:875)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.mapToModule(Proxy.java:814)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.<init>(Proxy.java:631)
	at java.base/java.lang.reflect.Proxy$ProxyBuilder.<init>(Proxy.java:636)
	at java.base/java.lang.reflect.Proxy.lambda$getProxyConstructor$0(Proxy.java:415)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue$Memoizer.get(AbstractClassLoaderValue.java:327)
	at java.base/jdk.internal.loader.AbstractClassLoaderValue.computeIfAbsent(AbstractClassLoaderValue.java:203)
	at java.base/java.lang.reflect.Proxy.getProxyConstructor(Proxy.java:413)
	at java.base/java.lang.reflect.Proxy.newProxyInstance(Proxy.java:999)
	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:305)
	at java.base/sun.reflect.annotation.AnnotationParser$1.run(AnnotationParser.java:303)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/sun.reflect.annotation.AnnotationParser.annotationForMap(AnnotationParser.java:303)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:293)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)
	at java.base/sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72)
	at java.base/java.lang.reflect.Executable.declaredAnnotations(Executable.java:605)
	at java.base/java.lang.reflect.Executable.declaredAnnotations(Executable.java:603)
	at java.base/java.lang.reflect.Executable.getDeclaredAnnotations(Executable.java:591)
	at java.base/java.lang.reflect.Constructor.getDeclaredAnnotations(Constructor.java:579)
	at net.bytebuddy.description.method.MethodDescription$ForLoadedConstructor.getDeclaredAnnotations(MethodDescription.java:917)
	at net.bytebuddy.description.method.MethodDescription$AbstractBase.asToken(MethodDescription.java:695)
	at net.bytebuddy.description.method.MethodDescription$AbstractBase.asToken(MethodDescription.java:334)
	at net.bytebuddy.description.method.MethodList$AbstractBase.asTokenList(MethodList.java:53)
	at net.bytebuddy.dynamic.scaffold.InstrumentedType$Factory$Default$1.represent(InstrumentedType.java:223)
	at net.bytebuddy.ByteBuddy.redefine(ByteBuddy.java:698)
	at net.bytebuddy.ByteBuddy.redefine(ByteBuddy.java:676)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:167)
	at java.instrument/java.lang.instrument.ClassFileTransformer.transform(ClassFileTransformer.java:246)
	at java.instrument/sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at java.instrument/sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:550)
	at java.base/java.lang.WeakPairMap$Pair.weak(WeakPairMap.java:201)
	at java.base/java.lang.WeakPairMap.putIfAbsent(WeakPairMap.java:123)
	at java.base/java.lang.Module.implAddReads(Module.java:396)
	at java.base/java.lang.Module.implAddReads(Module.java:357)
	at java.base/java.lang.System$2.addReads(System.java:2146)
	at java.base/jdk.internal.module.Modules.addReads(Modules.java:85)
	at java.base/jdk.internal.module.Modules.transformedByAgent(Modules.java:166)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:157)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)
	... 72 more
```
</p>
</details> =||= Could someone create a reproduction of this issue in a small isolated repository? It seems like I cannot reproduce the issue.

Also, I wonder what the remaining stack frames are, could someone post these? =||= @raphw I created a repo which reproduces the problem: https://github.com/guenhter/mockito-final-class-kotlin-problem =||= @mockitoguy 
The same issue was reproduced for mocking Aspose library classes (com.aspose). Lib was compiled via aspose-jdk1.6. `aspose-jdk1.6` can be added to observed classes list in exception info =||= "Avoid circularity: avoid endless loop during mock creation"If certain types a type for the first time during instrumentation while our mocking engine relies on the same types, this can cause a circularity as checking if an instance is a mock requires instances of the latter types what again returns to the latter mock checking routine what causes an endless loop. (Described in comment.) Fixes #1240.

It is a bit difficult to reproduce this issue in our tests. It mainly happens with classes generated by Kotlin or Scala and requires the inline mock maker and a JDK 9 or older. If we want to add such a test, we can copy the test from https://github.com/guenhter/mockito-final-class-kotlin-problem"Rafael Winterhalterraphw04/28/18, 09:39:57 AM
1390.01391MockitoExtension cannot be registered as a global junit5 extension."`MockitoExtension` doesn't expose its constructor so it can't be loaded by `ServiceLoader.`

When trying to register `MockitoExtension` for automatic use using a file named `META-INF\services\org.junit.jupiter.api.extension.Extension` and content `org.mockito.junit.jupiter.MockitoExtension`

the below error is thrown, using mockito-junit-jupiter 2.18.3

```
org.junit.jupiter.api.extension.Extension: org.mockito.junit.jupiter.MockitoExtension Unable to get public no-arg constructor
java.util.ServiceConfigurationError: org.junit.jupiter.api.extension.Extension: org.mockito.junit.jupiter.MockitoExtension Unable to get public no-arg constructor
	at java.base/java.util.ServiceLoader.fail(ServiceLoader.java:581)
	at java.base/java.util.ServiceLoader.getConstructor(ServiceLoader.java:672)
	at java.base/java.util.ServiceLoader.access$1000(ServiceLoader.java:390)
	at java.base/java.util.ServiceLoader$LazyClassPathLookupIterator.hasNextService(ServiceLoader.java:1232)
	at java.base/java.util.ServiceLoader$LazyClassPathLookupIterator.hasNext(ServiceLoader.java:1264)
	at java.base/java.util.ServiceLoader$2.hasNext(ServiceLoader.java:1299)
	at java.base/java.util.ServiceLoader$3.hasNext(ServiceLoader.java:1384)
	at java.base/java.lang.Iterable.forEach(Iterable.java:74)
	at org.junit.jupiter.engine.extension.ExtensionRegistry.registerAutoDetectedExtensions(ExtensionRegistry.java:102)
	at org.junit.jupiter.engine.extension.ExtensionRegistry.createRegistryWithDefaultExtensions(ExtensionRegistry.java:86)
	at org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor.prepare(JupiterEngineDescriptor.java:37)
	at org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor.prepare(JupiterEngineDescriptor.java:28)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.prepare(HierarchicalTestExecutor.java:89)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor$NodeExecutor.execute(HierarchicalTestExecutor.java:74)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:55)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:43)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:170)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:154)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:90)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.processAllTestClasses(JUnitPlatformTestClassProcessor.java:92)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor$CollectAllTestClassesExecutor.access$100(JUnitPlatformTestClassProcessor.java:77)
	at org.gradle.api.internal.tasks.testing.junitplatform.JUnitPlatformTestClassProcessor.stop(JUnitPlatformTestClassProcessor.java:73)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.stop(SuiteTestClassProcessor.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy1.stop(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.stop(TestWorker.java:123)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:155)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:137)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1135)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
	at java.base/java.lang.Thread.run(Thread.java:844)
Caused by: java.lang.NoSuchMethodException: org.mockito.junit.jupiter.MockitoExtension.<init>()
	at java.base/java.lang.Class.getConstructor0(Class.java:3302)
	at java.base/java.lang.Class.getConstructor(Class.java:2110)
	at java.base/java.util.ServiceLoader$1.run(ServiceLoader.java:659)
	at java.base/java.util.ServiceLoader$1.run(ServiceLoader.java:656)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/java.util.ServiceLoader.getConstructor(ServiceLoader.java:667)
	... 46 more
```

 - [X] The mockito message in the stacktrace have useful information, but it didn't help
 - [X] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [X] Provide versions (mockito / jdk / os / any other relevant information)
 - [X] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [X] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)"Make MockitoExtension constructor public"It is possible to register an extension for automatic use using Java's `ServiceLoader` mechanism.

https://junit.org/junit5/docs/current/user-guide/#extensions-registration-automatic

Some projects may want to provide their own `META-INF` file to avoid tediously adding `MockitoExtension` to tests since it is very common. However, `ServiceLoader` requires the class to have a no-args *public* constructor, so the current extension cannot be used with the `ServiceLoader` mechanism.

Fixes #1390

check list

 - [X] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/2.x/.github/CONTRIBUTING.md)
 - [X] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [X] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [X] Avoid other runtime dependencies
 - [X] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [X] The pull request follows coding style
 - [X] Mention `Fixes #<issue number>` in the description _if relevant_
 - [X] At least one commit should mention `Fixes #<issue number>` _if relevant_
"Anuraag Agrawalanuraaga05/17/18, 10:51:12 AM
91.01425Document Mockito.after() methodDocument Mockito.after() method. Add TODO that we should rename it in 2.0 into 'during'"I still like the `after` method, can't we just keep it as an alias ?
 =||= In this case, I'd rather have a single opinionated method (unless I'm convinced otherwise :).

How about this:

mock(foo, after(10).times(2)).bar()
VS
mock(foo, during(10).times(2)).bar()

It feels that 'after' has higher chance of producing ambiguous looking test code.
 =||= Also, 'after' can be interpreted as:
1. wait given amount of time
2. then validate invocations that happen _after_ the time period (e.g. excluding invocations that happened during the time).

AFAIR the implementation does not work this way. The impl expects the invocation(s) 'during' this time :)
 =||= ok I agree, I now remember what this call did. Never mind my original comment.

However, looking at your example, it would feel better if an alias could support `TimeUnit`.

``` java
mock(foo, during(10).times(2)).bar()
mock(foo, during(10, SECONDS).times(2)).bar()
```
 =||= Yeah, this kind of alias makes perfect sense.
 =||= "Updated documentation of timeout() and after()"While working on @ChristianSchwarz's PR, I found the current documentation confusing.

- made the documentation clear, especially about the differences between timeout() and after()
- removed mentions of internal API (new Timeout() constructor)

Fixes #91"Szczepan Fabermockitoguy07/16/18, 07:00:49 AM
1419.01426Provide Java 11 compatibility"I ran tests with JAva 11 and getting the follwing exception. may be asm 6.2 fixes this?


org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface de.espirit.firstspirit.access.Language.

If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : ""Oracle Corporation""
JVM vendor version : 11-ea+18
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 11-ea+18
JVM info           : mixed mode
OS name            : Linux
OS version         : 4.9.0-6-amd64


You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [interface java.lang.Comparable, interface de.espirit.firstspirit.access.Language]
	at de.espirit.firstspirit.generate.TestPluggableUrlCreator.setUp(TestPluggableUrlCreator.java:51)
	at jdk.internal.reflect.GeneratedMethodAccessor15.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [interface java.lang.Comparable, interface de.espirit.firstspirit.access.Language]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:344)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:159)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:353)
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:120)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:97)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:344)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:159)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:353)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:200)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:181)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1855)
	at org.mockito.Mockito.mock(Mockito.java:1787)
Caused by: java.lang.IllegalArgumentException: Unsupported class file major version 55
	at net.bytebuddy.jar.asm.ClassReader.<init>(ClassReader.java:166)
	at net.bytebuddy.jar.asm.ClassReader.<init>(ClassReader.java:148)
	at net.bytebuddy.jar.asm.ClassReader.<init>(ClassReader.java:136)
	at net.bytebuddy.utility.OpenedClassReader.of(OpenedClassReader.java:54)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2912)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1634)
	at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:171)
	at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:92)
	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2669)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:181)
	at java.instrument/java.lang.instrument.ClassFileTransformer.transform(ClassFileTransformer.java:246)
	at java.instrument/sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at java.instrument/sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:563)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at java.instrument/sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:167)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:117)




""asm 6.2 alone does not fix this, neither does upgrading to latest bytebuddy help here.
The combination of asm 6.2, latest bytebuddy, a minor code change in mockito and setting `-Dnet.bytebuddy.experimental=true` helps here. =||= mockito-core-2.21.0.jar 	
byte-buddy-1.8.15.jar

with org.mockito.plugins.MockMaker ""mock-maker-inline"" the fix is not working with java 1.8_172 and java  11-ea+24.

without ""mock-maker-inline"" it works

org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface de.espirit.or.schema.EntityType.

If you're not sure why you're getting this error, please report to the mailing list.


Java               : 1.8
JVM vendor name    : Oracle Corporation
JVM vendor version : 25.172-b11
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 1.8.0_172-b11
JVM info           : mixed mode
OS name            : Mac OS X
OS version         : 10.13.6


You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : org.mockito.exceptions.base.MockitoException: Could not modify all classes [interface de.espirit.or.schema.EntityType, interface java.io.Serializable]

	at de.espirit.firstspirit.access.editor.TestEntityAssociate.beforeEach(TestEntityAssociate.java:27)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
	at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
	at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
	at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
Caused by: org.mockito.exceptions.base.MockitoException: Could not modify all classes [interface de.espirit.or.schema.EntityType, interface java.io.Serializable]
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:344)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:159)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:353)
	... 23 more
Caused by: java.lang.IllegalStateException: 
Byte Buddy could not instrument all classes within the mock's type hierarchy

This problem should never occur for javac-compiled classes. This problem has been observed for classes that are:
 - Compiled by older versions of scalac
 - Classes that are part of the Android distribution
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:164)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:141)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:137)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:344)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:159)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:353)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:200)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:181)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:69)
	at org.mockito.Mockito.mock(Mockito.java:1895)
	at org.mockito.Mockito.mock(Mockito.java:1804)
	... 23 more
Caused by: java.lang.NoSuchFieldError: ASM_API
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator$ParameterWritingVisitorWrapper$ParameterAddingClassVisitor.<init>(InlineBytecodeGenerator.java:251)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator$ParameterWritingVisitorWrapper$ParameterAddingClassVisitor.<init>(InlineBytecodeGenerator.java:246)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator$ParameterWritingVisitorWrapper.wrap(InlineBytecodeGenerator.java:242)
	at net.bytebuddy.asm.AsmVisitorWrapper$Compound.wrap(AsmVisitorWrapper.java:645)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining$RedefinitionClassVisitor.visit(TypeWriter.java:3672)
	at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:492)
	at net.bytebuddy.jar.asm.ClassReader.accept(ClassReader.java:355)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default$ForInlining.create(TypeWriter.java:2915)
	at net.bytebuddy.dynamic.scaffold.TypeWriter$Default.make(TypeWriter.java:1634)
	at net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder.make(RedefinitionDynamicTypeBuilder.java:171)
	at net.bytebuddy.dynamic.scaffold.inline.AbstractInliningDynamicTypeBuilder.make(AbstractInliningDynamicTypeBuilder.java:92)
	at net.bytebuddy.dynamic.DynamicType$Builder$AbstractBase.make(DynamicType.java:2669)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.transform(InlineBytecodeGenerator.java:215)
	at sun.instrument.TransformerManager.transform(TransformerManager.java:188)
	at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:428)
	at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:161)
	... 37 more =||= We are experiencing the same error with Java 11 and inline mocks. =||= Having similar issue with mockito and Java 11. Unable to mock any class/interface, do we need implement any method for class loading,since defineclass method removed  in Java11 ? I even edited my java.policy for assertion exception.
https://dzone.com/articles/jdk-11-and-proxies-in-a-world-past-sunmiscunsafe
http://hg.openjdk.java.net/jdk9/hs/jdk/rev/0d2ab72ba600
mockito -2.21.0,
bytebuddy-1.8.15

Below is the exception:
org.mockito.exceptions.base.MockitoException: 

Mockito cannot mock this class: class com.xxx.xxx.toolkit.config.Configuration.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : Oracle Corporation
JVM vendor version : 11-ea+26
JVM name           : Java HotSpot(TM) 64-Bit Server VM
JVM version        : 11-ea+26
JVM info           : mixed mode
OS name            : Mac OS X
OS version         : 10.13.4


Underlying exception : java.lang.IllegalStateException: Error invoking java.lang.invoke.MethodHandles$Lookup#defineClass
Caused by: java.lang.IllegalStateException: Error invoking java.lang.invoke.MethodHandles$Lookup#defineClass
Caused by: java.security.AccessControlException: access denied (""java.lang.RuntimePermission"" ""defineClass"")
 =||= Same problem here... =||= Seeing a related error:
```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface cloud.cosmin.checklister.repo.ListRepo.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : AdoptOpenJDK
JVM vendor version : 11.0.1+13
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 11.0.1+13
JVM info           : mixed mode
OS name            : Linux
OS version         : 4.15.0-39-generic


Underlying exception : java.lang.UnsupportedOperationException: Cannot define class using reflection
	at cloud.cosmin.checklister.rest.ListControllerTest.setUp(ListControllerTest.java:37)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:24)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.runTestClass(JUnitTestClassExecutor.java:106)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:58)
	at org.gradle.api.internal.tasks.testing.junit.JUnitTestClassExecutor.execute(JUnitTestClassExecutor.java:38)
	at org.gradle.api.internal.tasks.testing.junit.AbstractJUnitTestClassProcessor.processTestClass(AbstractJUnitTestClassProcessor.java:66)
	at org.gradle.api.internal.tasks.testing.SuiteTestClassProcessor.processTestClass(SuiteTestClassProcessor.java:51)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.dispatch.ContextClassLoaderDispatch.dispatch(ContextClassLoaderDispatch.java:32)
	at org.gradle.internal.dispatch.ProxyDispatchAdapter$DispatchingInvocationHandler.invoke(ProxyDispatchAdapter.java:93)
	at com.sun.proxy.$Proxy2.processTestClass(Unknown Source)
	at org.gradle.api.internal.tasks.testing.worker.TestWorker.processTestClass(TestWorker.java:117)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:35)
	at org.gradle.internal.dispatch.ReflectionDispatch.dispatch(ReflectionDispatch.java:24)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:155)
	at org.gradle.internal.remote.internal.hub.MessageHubBackedObjectConnection$DispatchWrapper.dispatch(MessageHubBackedObjectConnection.java:137)
	at org.gradle.internal.remote.internal.hub.MessageHub$Handler.run(MessageHub.java:404)
	at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)
	at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.UnsupportedOperationException: Cannot define class using reflection
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Unavailable.defineClass(ClassInjector.java:821)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.inject(ClassInjector.java:185)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:187)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4457)
	at org.mockito.internal.creation.bytebuddy.SubclassBytecodeGenerator.mockClass(SubclassBytecodeGenerator.java:121)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:37)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:34)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:138)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:346)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:161)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:355)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:32)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMockType(SubclassByteBuddyMockMaker.java:71)
	at org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker.createMock(SubclassByteBuddyMockMaker.java:42)
	at org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker.createMock(ByteBuddyMockMaker.java:25)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:35)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:65)
	at org.mockito.Mockito.mock(Mockito.java:1855)
	at org.mockito.internal.configuration.MockAnnotationProcessor.process(MockAnnotationProcessor.java:36)
	at org.mockito.internal.configuration.MockAnnotationProcessor.process(MockAnnotationProcessor.java:16)
	at org.mockito.internal.configuration.IndependentAnnotationEngine.createMockFor(IndependentAnnotationEngine.java:38)
	at org.mockito.internal.configuration.IndependentAnnotationEngine.process(IndependentAnnotationEngine.java:62)
	at org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(InjectingAnnotationEngine.java:57)
	at org.mockito.internal.configuration.InjectingAnnotationEngine.process(InjectingAnnotationEngine.java:41)
	at org.mockito.MockitoAnnotations.initMocks(MockitoAnnotations.java:69)
	... 48 more
Caused by: java.lang.IllegalStateException: Could not find sun.misc.Unsafe
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe$Dispatcher$Disabled.initialize(ClassInjector.java:1366)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe.inject(ClassInjector.java:1202)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$ForUnsafeInjection.load(ClassLoadingStrategy.java:458)
	at net.bytebuddy.dynamic.TypeResolutionStrategy$Passive.initialize(TypeResolutionStrategy.java:79)
	at net.bytebuddy.dynamic.DynamicType$Default$Unloaded.load(DynamicType.java:4457)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$Indirect.make(ClassInjector.java:684)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$CreationAction.run(ClassInjector.java:302)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection$Dispatcher$CreationAction.run(ClassInjector.java:290)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingReflection.<clinit>(ClassInjector.java:70)
	at net.bytebuddy.dynamic.loading.ClassLoadingStrategy$Default$InjectionDispatcher.load(ClassLoadingStrategy.java:184)
	... 71 more
Caused by: java.lang.NoSuchMethodException: sun.misc.Unsafe.defineClass(java.lang.String, [B, int, int, java.lang.ClassLoader, java.security.ProtectionDomain)
	at java.base/java.lang.Class.getMethod(Class.java:2109)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe$Dispatcher$CreationAction.run(ClassInjector.java:1269)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe$Dispatcher$CreationAction.run(ClassInjector.java:1257)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at net.bytebuddy.dynamic.loading.ClassInjector$UsingUnsafe.<clinit>(ClassInjector.java:1136)
	... 80 more
``` =||= @cstroe Are you sure that you don't have some older byte-buddy version on the classpath?

(of course I assume that use you the latest version of Mockito and Byte Buddy provided by it). =||= @szpak Your intuition is correct.  I am using Spring Boot version `2.0.5.RELEASE`, and it is using an older version of the Mockito library.  In order to use the newest Mockito, I had to change my Gradle config:
```
    testCompile('org.springframework.boot:spring-boot-starter-test') {
        exclude group: ""org.mockito"", module: ""mockito-core""
    }
    testCompile(""org.mockito:mockito-core:2.23.4"")
```

That fixed my errors.  Thank you for the help. =||= Great to hear.

Btw, Spring Boot provides also an easier way to override dependency [versions](https://docs.spring.io/platform/docs/Cairo-BUILD-SNAPSHOT/reference/html/getting-started-overriding-versions.html). Here, overriding Mockito would be enough.

Btw, AFAIR only Spring Boot 2.1 declared Java 11 compatibility. Therefore, you may want to upgrade to prevent further surprises :). =||= > testCompile('org.springframework.boot:spring-boot-starter-test') {
>         exclude group: ""org.mockito"", module: ""mockito-core""
>     }
>     testCompile(""org.mockito:mockito-core:2.23.4"")

this works like a charm, Thank You! =||= > 
> 
> > testCompile('org.springframework.boot:spring-boot-starter-test') {
> > exclude group: ""org.mockito"", module: ""mockito-core""
> > }
> > testCompile(""org.mockito:mockito-core:2.23.4"")
> 
> this works like a charm, Thank You!

Anyone has an idea how to do this in pom.xml? =||= @JiDarwish It's basic maven dependency management ;)

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
  <scope>test</test>
  <exclusions>
    <exclusion>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
    </exclusion>
  </exclustions>
</dependency>
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-core</artifactId>
  <version>2.23.4</version>
  <scope>test</scope>
</dependency>
``` =||= @bric3 I did exactly the same, still didn't help :-(

> Java               : 11
> JVM vendor name    : Oracle Corporation
> JVM vendor version : 11.0.2+9
> JVM name           : OpenJDK 64-Bit Server VM
> JVM version        : 11.0.2+9
> JVM info           : mixed mode
> OS name            : Mac OS X
> OS version         : 10.14.4 =||= Ok, adding bytebuddy dep. on top of that helped! =||= > @JiDarwish It's basic maven dependency management ;)
> 
> ```
> <dependency>
>   <groupId>org.springframework.boot</groupId>
>   <artifactId>spring-boot-starter-test</artifactId>
>   <scope>test</test>
>   <exclusions>
>     <exclusion>
>       <groupId>org.mockito</groupId>
>       <artifactId>mockito-core</artifactId>
>     </exclusion>
>   </exclustions>
> </dependency>
> <dependency>
>   <groupId>org.mockito</groupId>
>   <artifactId>mockito-core</artifactId>
>   <version>2.23.4</version>
>   <scope>test</scope>
> </dependency>
> ```

If your project extend `spring-boot-starter-parent` you might just add : 
```
	<properties>
		<mockito.version>2.23.4</mockito.version>
	</properties>
```

In your Maven file.  =||= "mockito on Java 11-ea+21"Fixes #1419 

Requires `-Dnet.bytebuddy.experimental=true` system property to be set to let bytebuddy use asm API version `ASM7_EXPERMIENTAL` and use the same one in `InlineBytecodeGenerator`."Robert Stuppsnazy07/13/18, 10:20:28 PM
1444.01446Artifact ID changes"Since `2.20.0` Mockito Maven artifact IDs [have changed](http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.mockito%22).

* `mockito-android` → `android`
* `mockito-inline` → `inline`
* `mockito-junit-jupiter` → `junit-jupiter`

Not sure if it is an intended change or not, so decided to clarify things a bit. So... Is it an intended change? It isn’t mentioned in the changelog.""It's a bug. Thank you for reporting! =||= @epeee, can you take a look at this? =||= Upstream bug in Shipkit: https://github.com/mockito/shipkit/issues/741 =||= @mockitoguy sorry, I was busy yesterday. 
I can have a look at the upstream bug in shipkit tomorrow. =||= Not sure if it is related but the `2.20.1` is available in JCenter but not in Maven Central. =||= There is some delay. Bintray log shows that the sync was successful. Let's wait until the end of the day.

Thanks for checking! =||= OSS repo has the right artifacts so I think it's just a delay before it's searchable in central. Proof - [pom.xml](https://oss.sonatype.org/service/local/artifact/maven/redirect?r=releases&g=org.mockito&a=mockito-inline&v=2.20.1&e=pom) in the Sonatype OSS 'release' repo.

Let's keep the ticket open until we add tests for the artifacts. @ming13, do you want to contribute a test that would verify artifact IDs? This should be a form of a Gradle task. =||= The issue is fixed in 2.20.1. I've added tests to prevent the issue in the future.

Thanks again for reporting!!! =||= "Workaround for wrong artifact ids"Fixes #1444

We can remove workaround when upstream bug is fixed: https://github.com/mockito/shipkit/issues/741"Szczepan Fabermockitoguy07/26/18, 04:14:16 AM
1522.01539Correct usage of strict stubbings -> PotentialStubbingProblem: Strict stubbing argument mismatch"Hi guys,

This is following is almost a copy paste from the mockito google group/forum, which I was recommended to do:
https://groups.google.com/forum/#!topic/mockito/WDKfavtJkCg

**Relevant Versions:**
```
OS : Fedora Linux 4.18.14-200.fc28.x86_64
mockito : 2.23.0
junit : 5.3.1
JDK : Oracle 10.0.2 (happens under 8 and OpenJDK 11.0.1 too)
IntelliJ : 2018.3 EAP

    testCompile group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.3.1'
    testRuntime group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.3.1'
    testCompile group: 'org.mockito', name: 'mockito-junit-jupiter', version: '2.23.0'
```
**Actual Question:**

I had some questions regarding use cases of new ""Strict"" stubbing.

With Junit5 & `@ExtendWith(MockitoExtension.class)` I've noticed that it errors out when I think it shouldn't (when compared with Junit4 & `@RunWith(MockitoJUnitRunner.class)` )
I have a very simple test case, which I consider to be both good code, and good mocking. Which gets highlighted as incorrect stubbing usage under Strict (default) checking

```
package com.example;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class MockitoTest {

    @Mock
    private Map<String, Object> mockMap;
    @Mock
    private Object mockObject;

    @Test
    void shouldBeAbleToMock() {
        // When
        when(mockMap.get(""A"")).thenReturn(""Apple"");
        when(mockMap.get(""B"")).thenReturn(mockObject);

        // Then
        assertEquals(""Apple"", mockMap.get(""A""));
        assertEquals(mockObject, mockMap.get(""B""));
    }
}
```

The above gives the following stacktrace when run:
```
org.mockito.exceptions.misusing.PotentialStubbingProblem: 
Strict stubbing argument mismatch. Please check:
 - this invocation of 'get' method:
    mockMap.get(""B"");
    -> at com.example.MockitoTest.shouldBeAbleToMock(MockitoTest.java:25)
 - has following stubbing(s) with different arguments:
    1. mockMap.get(""A"");
      -> at com.example.MockitoTest.shouldBeAbleToMock(MockitoTest.java:24)
Typically, stubbing argument mismatch indicates user mistake when writing tests.
Mockito fails early so that you can debug potential problem easily.
However, there are legit scenarios when this exception generates false negative signal:
  - stubbing the same method multiple times using 'given().will()' or 'when().then()' API
    Please use 'will().given()' or 'doReturn().when()' API for stubbing.
  - stubbed method is intentionally invoked with different arguments by code under test
    Please use default or 'silent' JUnit Rule (equivalent of Strictness.LENIENT).
For more information see javadoc for PotentialStubbingProblem class.

    at com.example.MockitoTest.shouldBeAbleToMock(MockitoTest.java:25)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.base/java.lang.reflect.Method.invoke(Method.java:564)
    at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:515)
    at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:115)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:171)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:167)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:114)
    at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:59)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:105)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)
    at java.base/java.util.ArrayList.forEach(ArrayList.java:1378)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:110)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)
    at java.base/java.util.ArrayList.forEach(ArrayList.java:1378)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:110)
    at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)
    at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
    at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
    at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)
    at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)
    at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)
    at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)
    at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:74)
    at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47)
    at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)
    at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)
```

I've found 1 other reference to this issue online, which was here:
https://stackoverflow.com/questions/52139619/simulation-of-service-using-mockito-2-leads-to-stubbing-error

The above stated you could work around the issue by changing the code as follows:
```
// From this
when(mockMap.get(""A"")).thenReturn(""Apple"");
when(mockMap.get(""B"")).thenReturn(mockObject);

// To this
when(mockMap.get(anyString())).thenAnswer(invocation -> {
    Object arg = invocation.getArgument(0);
    if (""A"".equals(arg)) return ""Apple"";
    if (""B"".equals(arg)) return system;
});
```

Is this a bug, or is this intentional going forwards?

Thanks for your time!


check that

 - [✓] The mockito message in the stacktrace have useful information, but it didn't help
 - [✓] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [✓] Provide versions (mockito / jdk / os / any other relevant information)
 - [✓] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [✓] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)

""I'm not sure if I'm on the right track with this, or is this helps anyone else, but I had the same problem and solved it by using the `doReturn().when()` version of mockito instead of `when().thenReturn()` =||= @bwhiting2356  This works to resolve the issue, but it causes a new issue.  When I use `doReturn().when()` it turns off the `UnnecessaryStubbingException` that we rely on.  Any idea how to overload method stubbing while still being strict? =||= I think the `strict` and `lenient` thing has not been thought trough.  It's quite common to stub a method twice with different parameter values.  For example when code needs to fetch two (or more) values from a dependency you would stub for those two values.  Now this generates an `UnnecessaryStubbingException`, while it clearly **is** necessary for proper working of the test.

The solution using an `Answer` class is not a good one, in fact, I'm of the opinion you want to avoiding using `Answer` objects as much as possible. =||= Finding exactly the same issue as described above using `@RunWith(MockitoExtension.class)`

```
<dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.vintage</groupId>
      <artifactId>junit-vintage-engine</artifactId>
      <scope>test</scope>
    </dependency>
```
version 5.3.2 of the above dependencies and 

```
<dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-junit-jupiter</artifactId>
      <version>2.23.0</version>
      <scope>test</scope>
    </dependency>
```

@hjohn @bwhiting2356  @jmart1 be interested to hear how you resolved this... =||= Bump!
 =||= @jaygehlot I'm afraid I've just turned it off, as I do with all warnings that create too many false positives.  Keeping an eye on this issue still in case it gets fixed. =||= "Improved sensitivity of potential stubbing problem"This change improves the developer experience with strict stubbing. It is now possible to stub the same method with different argument multiple times in the test. Previously, we threw PotentialStubbingProblem exception in this scenario:

```java
when(mock.foo(1)).thenReturn(1);
when(mock.foo(2)).thenReturn(2); // <- no longer throws PotentialStubbingProblem (false negative)
```

This reduces the number of false negatives reported by strict stubbing.

Fixes #1522, #1496, partially #769, #720"Szczepan Fabermockitoguy11/25/18, 04:44:14 PM
1541.01544Mock object premature garbage collected when using 'One-liner stubs'"### Problem:
'One-liner stubs' may throw an exception because the actual mock object is already garbage collected when trying to return the mock.

### Reproduce:
1. Mockito 2.23.5 using mockito-inline
2. -Xmx256m

```
public class OneLinerStubStressTest {

    public class TestClass {
        public String getStuff() {
            return ""A"";
        }
    }

    private static String generateString() {
        final int length = 10000;
        final StringBuilder stringBuilder = new StringBuilder(length);
        for (int i = 0; i <= length; i++) {
            stringBuilder.append(""B"");
        }
        return stringBuilder.toString();
    }

    @Test
    public void call_a_lot_of_mocks() {
        final String returnValue = generateString();
        for (int i = 0; i < 40000; i++) {
            final TestClass mock = when(mock(TestClass.class).getStuff())
                                   .thenReturn(returnValue).getMock();
            assertEquals(returnValue, mock.getStuff());
        }
    }
}
```
#### Expected:
Test finishes successfully

#### Actual:
```
java.lang.IllegalStateException: The mock object was garbage collected. This should not happen in normal circumstances when using public API. Typically, the test class keeps strong reference to the mock object and it prevents getting the mock collected. Mockito internally needs to keep weak references to mock objects to avoid memory leaks for certain types of MockMaker implementations. If you see this exception using Mockito public API, please file a bug. For more information see issue #1313.
        at org.mockito.internal.invocation.mockref.MockWeakReference.get(MockWeakReference.java:32)
        at org.mockito.internal.invocation.InterceptedInvocation.getMock(InterceptedInvocation.java:103)
        at org.mockito.internal.stubbing.InvocationContainerImpl.invokedMock(InvocationContainerImpl.java:157)
        at org.mockito.internal.stubbing.ConsecutiveStubbing.getMock(ConsecutiveStubbing.java:28)
```

### Analysis:
As part of #1313 `DefaultInvocationFactory` and `InterceptedInvocation` were refactored to keep week reference to the mock. This was necessary in order to get rid of strong references by the handlers which caused memory leaks. On the other hand this requires to have a strong reference to the mock in the test class in order to prevent premature garbage collection. Unfortunately if using 'One-liner stubs' (https://static.javadoc.io/org.mockito/mockito-core/2.23.4/org/mockito/Mockito.html#one_liner_stub) the mock object may be premature cleaned up. This occurs because we gain access to the `InterceptedInvocation` when calling `getMock()` (which tries to get the mock from the invocation), without having any strong reference to the mock itself. At this point the mock may already be cleaned up."Great investigation! Do you have a suggestion on how to resolve this? =||= Tried different approaches. I believe I found one solution that works well. Created a PR. =||= Fixes #1541: Prevent premature garbage collection of mock objects"Fixes #1541.

If using 'One-liner stubs' (https://static.javadoc.io/org.mockito/mockito-core/2.23.4/org/mockito/Mockito.html#one_liner_stub) the mock object may be premature cleaned up and returning the mock fails with an exception. This occurs because there is no strong reference to the mock itself.

Therefore we need to maintain a strong reference to the mock until we've returned it, while making sure that the GC can still cleanup the mock correctly when needed.

Cause implementations of `BaseStubbing` are intended to be cleaned up after usage, we can store a strong ref to the mock there. `getMock` then uses the strong ref (instead of the weak ref provided by the invocation). After cleaning up the implementations of  `BaseStubbing` there is no strong ref to the mock itself anymore (except the one in the test class).

I tried some alternative solutions but I believe this is the only way it works.

----

Bind last mock creation to mockingProgress does not work because of this:
```
when(mock(TestClass2.class).getTestClass()).thenReturn(mock(TestClass.class)).getMock();
```

Bind mock of last invocation for stubbing to mockingProgress does not work because of this:
```
when(mock(TestClass.class).getStuff()).thenReturn(""X"").thenReturn(
    when(mock(TestClass.class).getStuff()).thenReturn(""XXX"").<TestClass>getMock().getStuff()
).getMock();
```"Max Grabenhorstmaxgrabenhorst11/26/18, 03:59:15 PM
1545.01546Enable Gradle Build cache for faster local builds"Let's enable Gradle build cache for faster local builds.

https://docs.gradle.org/current/userguide/build_cache.html"Enable gradle build cache"This pr fixes #1545.

I was not entirely sure about the settings to choose for the local build cache.
Let's discuss if we should go for a local folder and if keeping cache entries for 30 days is ok. 

check list

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/2.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [ ] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [ ] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [ ] At least one commit should mention `Fixes #<issue number>` _if relevant_
"Erhard Pointlepeee12/03/18, 04:55:29 PM
1514.01549Mockito remains in unfinished stubbing state if a stubbing fails"If one of `doThrow` instructions failed due to InstantiationError, Mockito remains in ""unfinished stubbing"" state and can no longer mock anything.

I had this issue in a single JUnit 4 test, but the fact that Mockito remained in ""unfinished stubbing"" state used to result in _all_ tests being marked as failed (I couldn't reproduce the last effect with the latest Mockito neither in JUnit 4 nor with JUnit 5 now, so the issue is applicable to a single test invocation only).

```java
import java.util.List;
import org.junit.jupiter.api.RepeatedTest;
import org.junit.jupiter.api.RepetitionInfo;
import org.mockito.Mockito;

class UninstantiableTest {

  @RepeatedTest(2)
  void tryThrow01(RepetitionInfo i) {
    if (i.getCurrentRepetition() == 1) {
      // Stub using uninstantiable exception.
      try {
        List mock = Mockito.mock(List.class);

        Mockito.doThrow(UninstantiableException.class).when(mock).clear();
      } catch (InstantiationError expected) {
        // Get a j.l.InstantiationError.
      }
    }

    // Try to stub another mock, this time using a valid exception type.
    {
      List mock = Mockito.mock(List.class);

      // The following operation results in ""UnfinishedStubbing""
      Mockito.doThrow(RuntimeException.class).when(mock).clear();
    }
  }

  abstract static class UninstantiableException extends RuntimeException {}
}
```

Mockito version 2.23.0


check that

 - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
 - [x] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/master/.github/CONTRIBUTING.md)

""A fix (if this **is** an issue) might be simple:

```
Index: src/main/java/org/mockito/internal/stubbing/StubberImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/java/org/mockito/internal/stubbing/StubberImpl.java	(revision 11e28796ecd89470ca50632e0fe9b2e4260e323a)
+++ src/main/java/org/mockito/internal/stubbing/StubberImpl.java	(date 1532965613000)
@@ -93,6 +93,9 @@
         } catch (RuntimeException instantiationError) {
             mockingProgress().reset();
             throw instantiationError;
+        } catch (InstantiationError instantiationError) {
+            mockingProgress().reset();
+            throw instantiationError;
         }
         return doThrow(e);
     }
``` =||= @dmitry-timofeev, do you want to take a stab at it? Please provide top level test that demonstrates the problem, too. It would be really helpful. Thank you! =||= Hi @mockitoguy , thank you for having a look. I'm a little busy at work, therefore I won't be able to in the coming weeks. =||= That's fair, we will try find time to work on this. Thank you for reporting! =||= "Fixed issue with leftover state when stubbing with bad throwablesFixed issue with leftover state when stubbing with bad throwables. Fixes #1514Szczepan Fabermockitoguy12/02/18, 03:55:09 AM
1595.01602Gradle javadoc plugin fails with latest JDK 11 release The javadoc plugin fails with a status code 1 on current JVM 11.0.2 releases.My machine is still on JVM 11.0.1. Going to have to go through Travis this time around to debug this issue... =||= Try to fix Javadoc generation on Java 11Fixes #1595 Tim van der LippeTimvdLippe01/28/19, 09:15:17 PM
357.01612ClassCastExceptions with JDK9 javac"JDK 9 fixes a javac bug ([JDK-8058199](https://bugs.openjdk.java.net/browse/JDK-8058199)) that was causing checkcast intructions to be skipped. Previously javac used the parameter types of a method symbol's erased type as targets when translating the arguments. In JDK 9, javac has been fixed to use the inferred types as targets. The fix causes additional checkcasts to be generated if the inferred types do not have the same erasure.

The fix breaks Mockito answer strategies that pick types based on the erased method signature's return type, and causes tests to fail with ClassCastExceptions when compiled with the JDK 9 javac.

---

Example 1

``` java
class Super<T> {
  T g() {
    return null;
  }
}

class Sub extends Super<Boolean> {}
```

``` java
@Mock Sub s;
when(s.g()).thenReturn(false);
```

compiled with javac 8

```
INVOKEVIRTUAL Sub.g ()Ljava/lang/Object;
INVOKESTATIC org/mockito/Mockito.when (Ljava/lang/Object;)Lorg/mockito/stubbing/OngoingStubbing;
```

compiled with javac 9

```
INVOKEVIRTUAL Sub.g ()Ljava/lang/Object;
CHECKCAST java/lang/Boolean
INVOKESTATIC org/mockito/Mockito.when (Ljava/lang/Object;)Lorg/mockito/stubbing/OngoingStubbing;
```

The erased return type of `Super.g` is `Object`, but the expected return type of `Sub.g` is `Boolean`. If the answer strategy returns `Object` the checkcast fails.

---

Example 2

``` java
class Foo {
  <T> T getFirst(Iterable<T> xs) { return xs.iterator().next(); }
}
```

``` java
@Mock Foo f;
Iterable<Boolean> it = Arrays.asList(false);
when(f.getFirst(it)).thenReturn(false)
```

compiled with javac 8

```
INVOKEVIRTUAL Foo.getFirst (Ljava/lang/Iterable;)Ljava/lang/Object;
INVOKESTATIC org/mockito/Mockito.when (Ljava/lang/Object;)Lorg/mockito/stubbing/OngoingStubbing;
```

compiled with javac 9

```
INVOKEVIRTUAL Foo.getFirst (Ljava/lang/Iterable;)Ljava/lang/Object;
CHECKCAST java/lang/Boolean
INVOKESTATIC org/mockito/Mockito.when (Ljava/lang/Object;)Lorg/mockito/stubbing/OngoingStubbing;
```

The erased return type of `Foo.getFirst` is `Object`, but the inferred return type of `getFirst(Iterable<Boolean>)` is `Boolean`. If the answer strategy returns `Object` the checkcast fails.

---

The first example could be fixed by using [`GenericMetadataSupport`](https://github.com/mockito/mockito/blob/9b838461abf93670d123109f7e3d8871f182767a/src/main/java/org/mockito/internal/util/reflection/GenericMetadataSupport.java) in all of the answer implementations instead of `invocation.getMethod().getReturnType()`.

It gets more difficult if the mock's type is an instantiation of a generic type (e.g. `@Mock Foo<Bar> x;`), since the field's type arguments get dropped. I think fixing that would require adding support for mocking types, not just classes.

For the second example, returning the right answer requires considering the generic signature of the invoked method, and performing type inference using the argument types. Unfortunately the runtime type of the argument is going to be a raw `Iterable` and the inference depends on knowing it's `Iterable<Boolean>`, so I'm not sure what to do there.""This problem is also the cause for https://github.com/mockito/mockito/issues/304
 =||= The test from #304 passes on current master https://github.com/mockito/mockito/commit/d6480148b28defa299b25230abe7f463f850350a so maybe this issue is also solved?
 =||= Closing this issue as it seems to be resolved.
 =||= I don't think this is fixed, both of the examples in the original report still fail with `v2.0.78-beta` and jdk `9-ea+116`.

Full repro: https://gist.github.com/cushon/b5c5e3995e9ad68ed3df8fd8626daf09

```
java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1914109206 (in module: Unnamed Module) cannot be cast to java.lang.Boolean (in module: java.base)
```

```
java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1914109206 (in module: Unnamed Module) cannot be cast to java.lang.Boolean (in module: java.base)
```
 =||= Thanks, I check this out prior to release.
 =||= Sorry - do you mean that you verified it's fixed at head, or that you will take another look before the next release? If it's the second one, do you mind re-opening the issue to make sure it doesn't get lost? I'm seeing the same behaviour at head. 
 =||= @cushon I think it's more that we'll look at it ;)

Typically using `GenericMetadataSupport` for `@Mock` fields has been on my mind for some time already. However note that using `mock()`style would not work unless we use some `TypeReference` trick.

> It gets more difficult if the mock's type is an instantiation of a generic type (e.g. @Mock Foo<Bar> x;), since the field's type arguments get dropped. I think fixing that would require adding support for mocking types, not just classes.

@raphw I think we should not delay 2.0 for that one, JDK9 is not yet out. We can still release fixes later.
 =||= @cushon I have just completed testing Mockito against Java 9 and everything works as expected. The examples that you provide work without any problems.

Thinking about how this would work, also makes sense. If not configured to return a different value, Mockito returns `null` during the configuration what passes the _checkcast_. Only if a user specifies an illegal value to the generic signature (heap pollution), a problem occurs but this is not really Mockito's responsibility.

Did you test a recent version?
 =||= > If not configured to return a different value, Mockito returns null during the configuration what passes the checkcast.

What about `RETURNS_SMART_NULLS` and `RETURNS_DEEP_STUBS`?
 =||= Ah, of course. Sorry for that, I did another mistake in my test. This problem is actually already reproduceable on recent versions of Java 8.
 =||= Ok, I have now finally looked into this in detail. There are three scenarios:
1. For generic return types, it suffices to resolve those return types properly by using `GenericMetadataSupport`. This can simply be added, I already tried this.
2. For locally inferred generic return types, there is not much we can do. For example, if we mocked some method `public <T> T foo() { ... }` there is no information preserved within the method that would allow us to know the expected type for `T`. We could only parse any method from where `foo` was called to contextually determine the return type. This would add a whole new layer of complexity to Mockito and I do not think we should support this case. We should probably add a warning to the docs.
3. For generic fields, we could find ways to preserve this information. We should probably refactor the `RETURN_SMART_NULLS` option to allow its binding to a generic base type rather than using the mock instance's (raw) type.
 =||= #639 builds on Java 9 which still has 3 test failures (but they seem to be related to `AssertJ` rather than our code). @cushon could you check out that branch and test if your usecases have been fixed with JDK9?
 =||= > could you check out that branch and test if your usecases have been fixed with JDK9?

@TimvdLippe it has not been fixed, I turned the repro into a unit test in #664.

Those tests fail in the jdk9 branch:

```
org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest > inferred_generic_type FAILED
    java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1081761404 (in module: Unnamed Module) cannot be cast to java.lang.Boolean (in module: java.base)
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest.inferred_generic_type(ReturnsSmartNullsTest.java:122)

org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest > generic_return_type_erasure FAILED
    java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1081761404 (in module: Unnamed Module) cannot be cast to java.lang.Boolean (in module: java.base)
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest.generic_return_type_erasure(ReturnsSmartNullsTest.java:105)
```
 =||= > For generic return types, it suffices to resolve those return types properly by using `GenericMetadataSupport`. This can simply be added, I already tried this.

That sounds good to me. I skipped the original `class Sub extends Super<Boolean> {}` example in #664 because it's no longer broken by the JDK9 javac change; it hasn't worked since 7fabd84fdfb2f80f8c135fe3865263c684c0d4e7. Is it worth splitting this into a separate bug?

``` java
    @Test
    public void generic_return_type_checkcast() throws Throwable {
        class Super<T> {
            T get() {
                return null;
            }
        }

        class Sub extends Super<Boolean> {}

        Sub sub = Mockito.mock(Sub.class, Answers.RETURNS_SMART_NULLS);
        Mockito.when(sub.get()).thenReturn(true);
        assertTrue(sub.get());
    }
```

```
generic_return_type_checkcast FAILED
    java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1200321394 cannot be cast to java.lang.Boolean
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest$1Sub$MockitoMock$412017289.get(Unknown Source)
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest$1Sub$MockitoMock$412017289.get(Unknown Source)
        at org.mockito.internal.stubbing.defaultanswers.ReturnsSmartNullsTest.generic_return_type_checkcast(ReturnsSmartNullsTest.java:94)
```
 =||= Careful as `GenericMetadataSupport` requires more CPU and memory.
 =||= We might be able to get around these issues with a solution like #643 
 =||= Note that this also fails with Eclipse's Java compiler (running under a Java 8 JRE) in Eclipse Neon (4.5), with the same ClassCastException. =||= @cushon @raphw @ePaul What is the status of this issue?
**Java 9 has been released today!**

I am getting the following error in all my tests that use Mockito:

```java
java.lang.ClassCastException: codegen.java.lang.Object$MockitoMock$1574589819 cannot be cast to org.hibernate.Session
``` =||= As said, there is not much we can do. The information of the required type lies outside of the class we instrument. We simply do not have this information available. I am afraid that this chained mocking is something we cannot fully support and you will have to mock your method chanes manually to supply this information.  =||= @raphw Thank you!

Well, does it mean that mockito will never work with Java 9? Omg, it's an epic disaster... :(  =||= Only when returning automatic mocks from mocks with generic return types, maybe we should add a warning for this to make the error more intuitive. =||= @raphw Yes, the warning would be very helpful. 
So, do I correctly understand that people will need to rewrite their tests in order to upgrade to Java 9? Probably a lot of tests?   =||= There's an Error Prone check that detects this problem at compile-time: http://errorprone.info/bugpattern/MockitoCast. It can also be run as a [refactoring](http://errorprone.info/docs/patching) to add work-arounds to affected code. =||= "Return null instead of causing a CCE"This solves a large number of edge-cases where `null` will actually
remove the runtime ClassCastException. This essentially negates the
whole MockitoCast ErrorProne check. We can still not support every use
case, but causing a NPE instead of a CCE does not seem to make this
worse.

I am still running internal tests within Google to see if there are any
regressions, but I already saw that some of the test failures we had
with ByteBuddy were resolved with this particular patch.

Note that this now fully closes #357. A previous PR resolved the same
issue with ReturnsSmartNulls: #1576.

Fixes #357"Tim van der LippeTimvdLippe02/12/19, 01:14:02 PM
1615.01617"Issue with mocking type in ""java.util.*"", Java 12""After upgrading Mockito from `2.23.4` to `2.24.0` we can't run JUnit 5's tests anymore. The error message reads:
```
    org.mockito.exceptions.base.MockitoException: 
    Mockito cannot mock this class: interface java.util.concurrent.locks.Lock.
    Mockito can only mock non-private & non-final classes.
    If you're not sure why you're getting this error, please report to the mailing list.
```
Find the complete stacktrace here: https://travis-ci.org/junit-team/junit5/jobs/488684907

Note, that using Mockito `2.24.0` using Java 11 (and 13 locally) did work out! See this build matrix: https://travis-ci.org/junit-team/junit5/builds/488684905

Workaround: revert to Mockito `2.23.4` for the time being via https://github.com/junit-team/junit5/commit/754f1eb0f106ab043d79de546d49769690a731b6
""Suspiciously, the type is again in the `java.util` package. That leads me to believe any type definitive in there can't be mocked. =||= > That leads me to believe any type definitive in there can't be mocked.

Using `2.24.0`. It works with the older version. =||= The package should not be an issue, but I'll check.  =||= There is a dot missing after the package name.... =||= Haha well spotted! Might be a simple String concatenation typo. =||= This is probably the mistake: https://github.com/mockito/mockito/blob/00cc06b387c3af8aaaed3a14fcb38df7d69db6c1/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L101

Should be:

```java
 typeName = InjectionBase.class.getPackage().getName() +""."" + features.mockedType.getSimpleName();
``` =||= Yes, very much.

Can it be that we don't have a test case for mocking a 'java.' type?

Are yoilu on your machine? I'll fix it next week otherwise.  =||= Sadly not. I can work on it tomorrow as well. Luckily we have a test suite now 🎉  =||= Or if @sormuras is available to make that PR, that would be amazing as well 😄 Our tests are specified in https://github.com/mockito/mockito/blob/f11705be91ee3545bc006908b34425f1fc359898/subprojects/module-test/src/test/java/org/mockito/moduletest/ModuleHandlingTest.java =||= Great, Tim!

Any plans to sync current release to Maven Central, soon? 2.24.0 is the latest one that was uploaded: http://central.maven.org/maven2/org/mockito/mockito-core/maven-metadata.xml =||= I wanted to do so, but I first wanted to get some other issues resolved with @raphw Hopefully we can get to that next week. (but seems like we hit a JDK bug 🎉 ) =||= Mockito 2.24.5 should be available on Maven central later today. =||= Looks good on 12: https://travis-ci.org/junit-team/junit5/jobs/495011557 =||= "Fix issue with mocking of java.util.* classes"Fixes #1615

I hope the test is correct. At least it failed before and succeeds now..."Tim van der LippeTimvdLippe02/11/19, 05:46:04 PM
1532.01619Nested spies cause memory leaks "Seems like nested spies can cause memory leaks since such objects are kept in memory without purging. Not sure if it can be resolved at all. Should it be avoided? Is there a mention about this in docs? Anyway, the code speaks better and fortunately I’ve been able to create a self-contained sample.

BTW I can provide a `.hprof` file if you are interested.

#### Versions

```
org.mockito:mockito-core:2.22.0
org.mockito:mockito-inline:2.22.0
```
```
java version ""1.8.0_181""
Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
```

#### Gradle

Heap is set to 64 MB.

```groovy
tasks.withType<Test> {
    maxHeapSize = ""64m""
    jvmArgs(""-XX:+HeapDumpOnOutOfMemoryError"")

    failFast = true
}
```
```
$ ./gradlew :module:cleanTestDebugUnitTest :module:testDebugUnitTest --tests ""com.github.sample.NestedSpiesMemoryLeakSpec""
```

#### Code

```kotlin
package com.github.sample

import com.jakewharton.rxrelay2.BehaviorRelay
import io.reactivex.functions.Consumer
import org.jetbrains.spek.api.Spek
import org.jetbrains.spek.api.dsl.it
import org.junit.platform.runner.JUnitPlatform
import org.junit.runner.RunWith
import org.mockito.Mockito

@RunWith(JUnitPlatform::class)
class NestedSpiesMemoryLeakSpec : Spek({

    repeat(10_000) { iteration ->

        it(""iteration [$iteration]"") {
            Mockito.spy(Service())
        }

    }

}) {

    class Service {
        // Remove Mockito.spy and OOM disappears.
        val value = Mockito.spy(Consumer<Int> {
            // This closure keeps a reference to Service.
            streams.size
        })

        // See at as a mass to fill the RAM.
        val streams = (0..1_000).map { BehaviorRelay.create<Int>() }
    }

}
```
```
> Task :module:testDebugUnitTest
java.lang.OutOfMemoryError: GC overhead limit exceeded
Dumping heap to java_pid23350.hprof ...
Heap dump file created [99857779 bytes in 0.356 secs]

com.github.sample.NestedSpiesMemoryLeakSpec > it iteration [187] STANDARD_ERROR
    java.lang.OutOfMemoryError: GC overhead limit exceeded
    	at com.jakewharton.rxrelay2.BehaviorRelay.<init>(BehaviorRelay.java:99)
    	at com.jakewharton.rxrelay2.BehaviorRelay.create(BehaviorRelay.java:77)
    	at com.github.sample.NestedSpiesMemoryLeakSpec$Service.<init>(NestedSpiesMemoryLeakSpec.kt:32)
    	at com.github.sample.NestedSpiesMemoryLeakSpec$1$1$1.invoke(NestedSpiesMemoryLeakSpec.kt:17)
    	at com.github.sample.NestedSpiesMemoryLeakSpec$1$1$1.invoke(NestedSpiesMemoryLeakSpec.kt:12)
    	at org.jetbrains.spek.engine.Scope$Test.execute(Scope.kt:102)
    	at org.jetbrains.spek.engine.Scope$Test.execute(Scope.kt:80)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:105)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask$$Lambda$82/547193480.execute(Unknown Source)
    	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:72)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:95)
    	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:71)

com.github.sample.NestedSpiesMemoryLeakSpec > it iteration [187] FAILED
    java.lang.OutOfMemoryError

> Task :module:testDebugUnitTest FAILED
```

#### Eclipse Memory Analyzer

<img width=""1238"" alt=""screen shot 2018-11-14 at 19 09 53"" src=""https://user-images.githubusercontent.com/200401/48495384-e574fb00-e840-11e8-886e-c9ae00dcf291.png"">
<img width=""1238"" alt=""screen shot 2018-11-14 at 19 08 59"" src=""https://user-images.githubusercontent.com/200401/48495395-ec9c0900-e840-11e8-9b02-cec1c8db43c0.png"">
<img width=""1238"" alt=""screen shot 2018-11-14 at 19 09 09"" src=""https://user-images.githubusercontent.com/200401/48495404-f291ea00-e840-11e8-8c5f-2680047c6947.png"">

---

Seems like this happens:

* `Service` is a spy.
* `Service` contains a `Consumer`, it is a `spy` as well.
* `Consumer` is a closure and has an implicit reference to `Service`.
* Mockito keeps both spies and cannot remove them from memory since there is a cross-reference (I guess).

""@mockitoguy, sorry for the ping, but the situation gets worse on our side. Is the issue with Mockito or we are just using it the wrong way? =||= CC @raphw  =||= You are right, due to the reference of one mock to another, the weak map is loosing its effect.

Technically, we would need to make the spy reference weak to break the cross reference but I sm not sure how this can be achieved without risking to have the references collected prematurely.  =||= @raphw, thanks for the explanation! If it is more or less intended — maybe let’s document it somewhere? Another option is throwing an exception or printing a warning in such cases. Since we weren’t aware of this and use Mockito quite a lot we got ourselves in a pretty bad OOM situation. Finding nested spies by hand is a tedeous task, not even sure I can automate it without library support. I’m afraid people will continue to do this not understanding the consequences.

Can I ask you to take a look at #1533 as well? I think it is pretty similar or even exactly the same in terms of the root issue. =||= It is surely not expected behavior and I consider it a bug. However, I do not know how to solve this and I even doubt that it is solvable without a data structure that is called an https://en.wikipedia.org/wiki/Ephemeron and which Java does not (currently) support.

But we should definitely document this. =||= Just checked Mockito 2.27.0. Using the new `Mockito.framework().clearInlineMocks()` call does the trick and helps to avoid OOM. Thanks! =||= "New API to clean up all inline mocks after test"In certain specific, rare scenarios (issue #1614) inline mocking causes memory leaks. There is no clean way to mitigate this problem completely. Hence, we introduced a new API to explicitly clear mock state (only make sense in inline mocking!):

```java
public class ExampleTest {

     @After
     public void clearMocks() {
         Mockito.framework().clearInlineMocks();
     }

     @Test
     public void someTest() {
         //...
     }
 }
```

Due to the introduction of map from weak reference from mock instance to
its invocation handler, Mockito became vulnerable to memory leaks as
there are multiple situations where Mockito could unintentionally hold
strong references to mock instances in the map record. The strong
references could be through spiedInstance for spies, and arguments used
to facilitate method stubbing.

Mockito could never know if the arguments passed in for method stubbing
are also strongly referenced somewhere else or not, so Mockito needs to
save a strong reference to these arguments to avoid premature GC.
Therefore to solve cyclic strong references through arguments Mockito
needs to explicitly know when mocks are out of their life, and clean
up all internal strong references associated with them.



Fixes #1532 and #1533."Xu Tanttanxu03/05/19, 04:10:18 PM
1621.01624"RETURNS_DEEP_STUBS causes ""Raw extraction not supported for : 'null'"" in some cases""When trying to mock the [Hadoop Mapper.Context](https://github.com/apache/hadoop/blob/release-2.6.0/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/Mapper.java#L105) class with Mockito 2.24.0, exception `org.mockito.exceptions.base.MockitoException: Raw extraction not supported for : 'null'` is thrown when calling one of the methods that returns a generic type.  

Actual mocking is taking place inside the [MRUnit library](https://mrunit.apache.org/), as seen in [MockMapContextWrapper](https://github.com/apache/attic-mrunit/blob/release-1.1.0/src/main/java/org/apache/hadoop/mrunit/internal/mapreduce/MockMapContextWrapper.java#L75): 

    final Mapper<KEYIN, VALUEIN, KEYOUT, VALUEOUT>.Context context = mock(org.apache.hadoop.mapreduce.Mapper.Context.class, Mockito.RETURNS_DEEP_STUBS);

Context is an abstract inner class of Mapper, and implements the [MapContext](https://github.com/apache/hadoop/blob/release-2.6.0/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/MapContext.java) interface, which extends the [TaskInputOutputContext](https://github.com/apache/hadoop/blob/release-2.6.0/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/TaskInputOutputContext.java) interface, which extends several other non-generic interfaces. 

Exception is thrown later when calling the [`context.getCurrentKey()`](https://github.com/apache/hadoop/blob/release-2.6.0/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-core/src/main/java/org/apache/hadoop/mapreduce/TaskInputOutputContext.java#L51) method on the mock, which returns generic type `KEYIN`.

This works fine with Mockito 1.

MRUnit project is abandoned, so it is not possible to change the mock.  It by default uses old Mockito 1.9.5, and works with 1.10.19.  I am attempting to exclude its dependencies on old Mockito and Powermock, and instead provide latest Mockito 2.24.0 and Powermock 2.0.0 so that my project using MRUnit and Mockito will not be permanently stuck on Mockito 1. 

The only time these problem methods appear to be [called within MRUnit is to set up stubbing](https://github.com/apache/attic-mrunit/blob/release-1.1.0/src/main/java/org/apache/hadoop/mrunit/internal/mapreduce/MockMapContextWrapper.java#L96), so it doesn't really matter what the return value is in this case.  Should this even work with Mockito, or was this just a bug in Mockito 1 that MRUnit exploited? 

----

Here is a minimal example that reproduces the issue:

```Java
package example;

import org.junit.Before;
import org.junit.Test;

import static org.mockito.Mockito.RETURNS_DEEP_STUBS;
import static org.mockito.Mockito.mock;

public class Example {

    public interface FirstInterface<T> {
        boolean normal();
        T generic();
    }

    public interface SecondInterface<T> extends FirstInterface<T> { }

    public class TestClass<T> {
        public abstract class AbstractInner implements SecondInterface<T> { }
    }

    private TestClass.AbstractInner testMock;

    @Before
    public void setup() {
        testMock = mock(TestClass.AbstractInner.class, RETURNS_DEEP_STUBS);
    }

    @Test
    public void works() {
        testMock.normal();
    }

    @Test
    public void fails() {
        testMock.generic();
    }
}
```

https://github.com/zman0900/mockito-example has this code with a gradle build.

Both tests pass with Mockito 1.10.19, but one fails with 2.24.0.  Changing TestClass.AbstractInner to implement FirstInterface instead of SecondInterface causes the same failure with both Mockito 1 and 2."@zman0900 Hi, nice bug report and reproducible example, it really helped. Indeed that's a bug or a current limitation in mockito's way to handle generics. I'm currently devising a way to improve such scenario. =||= Handle terminal type var with bounds"This PR aim to fix the issue described in #1621, the issue being that terminal type variable arguments were not looked up for their bounds.

Fixes #1621 "Brice Dutheilbric303/04/19, 03:20:44 PM
1609.01646Add back InvocationOnMock.getArgument<T>(int, Class<T>)"In https://github.com/mockito/mockito/issues/365 we replaced the existing `getArgumentAt<T>(int, Class<T>)` API with the current `getArgument(int)` API. However, when integrating this change within Google, we ran into numerous issues.

An example:

```java
invocation.getArgumentAt(0, Runnable.class).run()
```

gets rewritten to

```java
invocation.getArgument(0).run()
```

This does not compile, as the generic parameter is erasured to `Object` and thus does not have the `run` method.

Therefore, I would propose adding back an overload to `getArgument` that allows you to specify the `Class`. In general, users would not need this inside a variable assignment, but do need it in all other cases.""For more information see the error-prone bugpattern: https://errorprone.info/bugpattern/TypeParameterUnusedInFormals =||= @mockitoguy WDYT? I think it makes sense to have a simple API for local assignments or in return statements, but we would still need the Class to be explicit. =||= Looking... =||= Good idea! Few suggestions:
 - document clearly the use case in the new method (compact, readable tests / one-liner invocations).
 - add NotExtensible annotation to InvocationOnMock

Nice catch.
 =||= Awesome, thanks for the quick response! Will open a PR today :smile:  =||= Instead of using the reintroduced `getArgument<T>(int, Class<T>)`, IIUC the issue described above can also be solved as follows:
```java
invocation.<Runnable>getArgument(0).run()
```
That's admittedly less obvious, but does keep the API smaller. Has this been considered? =||= While that does work as well, I think consistency with the old API as well as the readability of the former vs the latter would still lead me to conclude that reintroducing is the appropriate solution. =||= "Add back getArgument(int, Class) to circumvent compilation issues"Also add `@NotExtensible` to several of our interfaces to document they
are not intended to be subclassed.

Fixes #1609"Tim van der LippeTimvdLippe03/15/19, 05:19:37 PM
1645.01647Release build is failing"After the latest Shipkit update, our Travis is failing: https://travis-ci.org/mockito/mockito/jobs/501397895#L1693 It fails with

```
[commit]  2 files changed, 11 insertions(+), 2 deletions(-)
[performRelease]   External process [commit] completed.
[performRelease] [tag] fatal: tag 'v2.24.8' already exists
```

@mstachniuk could you take a look?""@TimvdLippe it looks like we fixed this one in https://github.com/mockito/shipkit/pull/782.
I can do some local testing and provide a PR for this one soon (shipkit version update). =||= Thanks for that @epeee Looking forward to that PR. =||= Thank you guys! =||= "Update shipkit plugin (v2.1.6)"and increase the version since we already have a tag for 2.24.8.

fixes #1645 

shipkit v2.1.6 contains a fix for wrong task order (see https://github.com/mockito/shipkit/issues/781)
"Erhard Pointlepeee03/04/19, 05:54:49 PM
1664.01665Make invocation to drive its printing"Right now the `toString()` of an `Invocation` is ignored when it's being printed for a verification error, this prevents mockito-scala from providing a custom representation of the arguments via the implicit context.

With a simple change to drive the printing from within the `Invocation` the problem can be solved"New public API: invocation.getArgumentsAsMatchers()"- New public API: invocation.getArgumentsAsMatchers(), useful for advanced integrations, such as mockito-scala
- Some internal refactorings that provide temporary help with mockito-scala integration

Fixes #1664"Bruno Bonannobbonanno03/28/19, 02:32:40 PM
1663.01667Improve IDE UX comparison failure for JUnit5"When JUnit4 is used and the test is invoked from IDE (IDEA or Eclipse), and we are getting ""arguments are different"" MockitoVerificationError, the IDE gets nice ""click to see the difference"" link in the test failure, providing neat comparison pop-up.

We want to provide this feature for JUnit5, too. We do not want to add a new dependency on mockito (e.g. OpenTest4J). Rather, we can use reflection just like we do it now for JUnit4 or how AssertJ integrates with JUnit5.

Spin-off from #1656""Changing the exception type is an incompatible change in a strict sense. However, we need to be able to improve the framework by tweaking the exceptions if needed. We always strive to be compatible. There are no known legit use cases why our users would want to catch & handle specific Mockito exceptions. It's OK to change the type of ArgumentsAreDifferent exception. =||= I'm happy to take this on, per your request. The hardest part was the question of whether/how to handle backward compatibility. Should have a PR submitted by Monday. =||= > The hardest part was the question of whether/how to handle backward compatibility

We are OK with this incompatible change (see my other comment). Thanks for taking this on!!!

 =||= "Improved IDE experience for JUnit5 - visual comparison failure"When JUnit5+Mockito is used in modern IDE (IDEA, Eclipse) we now show ""visual"" comparison failure pop-up for certain Mockito exceptions (such as ArgumentsAreDifferent).

Fixes #1663."Fr Jeremy Kriegkriegfrj03/22/19, 03:46:12 AM
1668.01669Add subproject for errorprone Mockito plugins"We heavily rely on ErrorProne plugins to prohibit certain usage of Mockito. Examples include disallowing the usages of Mockito internals or extending interfaces annotated by `@NotExtensible`.

These plugins are beneficial to the Java community and we would like to open source them to the project. The extra subproject would contain several checkers (and tests) that implement several safeguards. Users can add the checkers to their project to their benefit.

For example for Gradle, the configuration would be as follows (using https://github.com/tbroyer/gradle-errorprone-plugin#custom-error-prone-checks):

```gradle
dependencies {
  errorprone(""org.mockito:mockito-errorprone:$mockitoVersion"")
}
```

This would allow us to make issues like #1616 and #1613 compiler errors rather than runtime failures."Add ErrorProne subproject"These checkers allow us to enforce API contracts that the Java compiler
otherwise would not enforce. As a first example, the added checker
enforces that users can not subclass interfaces that are annotated by
`@NotExtensible`.

Fixes #1668"Tim van der LippeTimvdLippe03/20/19, 08:47:27 PM
1692.01693The new Error Prone plugin isn't service-loadableThe `MockitoNotExtensible` plugin added in #1669 is pretty cool. However, when `mockito-errorprone` is added to the annotation processor classpath, Error Prone does not recognize/find the plugin. This is because `MockitoNotExtensible` is not declared in a `META-INF/services/com.google.errorprone.bugpatterns.BugChecker` file on the classpath.Make `MockitoNotExtensible` service-loadable"This way Error Prone can find the plugin when `mockito-errorprone` is added to the annotation processor classpath.

Fixes #1692."Stephan SchroeversStephan20204/30/19, 02:57:23 PM
1689.01699Coverage report is broken since Gradle 5"We upgraded to Gradle 5 in #1683 to fix our Java 11 build. However, this has now broken our coverage computation because of a breaking change in Gradle 4.10: https://github.com/gradle/gradle/pull/6419

There is no guidance from the Gradle team on how to migrate to a proper configuration. I have spend a couple of hours today to try to fix it, with no result. The TLDR is that Gradle now throws away the `test.exec` after executing the tests in a subproject. Thus, it will only have the coverage from the last subproject it ran.

I have looked online and there are other projects that do something similar (https://github.com/grpc/grpc-java/blob/master/all/build.gradle, https://github.com/groovy/groovy-core/blob/master/gradle/jacoco/jacoco.gradle) but none of the approaches worked for us.""Per https://github.com/gradle/gradle/pull/6419#issuecomment-484178277

> Why can't you use the JacocoMerge task and have one execution file per test task?

I suppose we can use this task, but I am not sure how to configure it properly. =||= So you wan't a coverage report which calculates the aggregated test-coverage over all subprojects? =||= That is correct. This was working as intended, but was broken in Gradle 5: https://github.com/gradle/gradle/pull/6419 The appropriate solution is `JacocoMerge`, but I was not able to make that work. =||= I'm looking into it. =||= JacocoMerge alone won't help. You'd also need an additional JacocoReport task.

I can write a grade plugin for this an provide a PR which uses this plugin to solve the problem. =||= > I'm looking into it.

Awesome thanks!

> You'd also need an additional JacocoReport task.

We currently already have a custom task in https://github.com/mockito/mockito/blob/0ad4efbeedac050f416c48f22c9a561e31f3cb05/gradle/root/coverage.gradle, so I don't think a plugin is strictly necessary. =||= You don't need nor merge, nor additional report, nor custom plugin:

https://github.com/gradle/gradle/pull/6419 states

> separate tasks now cannot use the same coverage file

which is about test tasks, however task `JacocoReport` can use data from multiple files.

Was about to open PR after seen https://twitter.com/TimvdLippe/status/1123244630491979776 , however @marcphilipp was faster 😆 :thumbsup: =||= "Fix JaCoCo code coverage report"Instead of collecting execution data of all test tasks of all
subprojects in a single file, each subproject's test task writes its own
execution data file. The `mockitoCoverage` task is configured to include
all execution data files into account that exists when it starts. This
is done to avoid exceptions for missing files for skipped test tasks for
the `android` and `errorprone` subprojects.

Fixes #1689.

---

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/2.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_
"Marc Philippmarcphilipp04/30/19, 07:32:20 PM
1542.01701when mock is called multiple times, and verify fails, the error message reports only the first invocation"AS A diligent dev,
I WANT TO verify that a mock will eventually get called with the specified parameters,
SO THAT I can properly test my builder class

SCENARIO
I have a builder class exposing a .with(String key, String value) method.
I created a test for testing that at a certain point the method gets called with 'foo', 'valueFoo'
I'd like to follow a test pattern where 1 test case has only 1 assertion

```
builderMock.with('bar','valueBar');
builderMock.with('foo','notValueFoo');
verify(builderMock).with('foo','valueFoo');
```

WHAT'S WRONG
Verify reports only the first invocation in the test failed logs.

```
Arguments are different! Wanted: 
builderMock.with('foo','valueFoo');
at ...
Actual invocation has different arguments:
builderMock.with('bar','valueBar');
at ...
``` 

IMO should be a list of invocation for that methods, something like:

```
// Actual invocations have different arguments:
// builderMock.with('bar','valueBar');
// at ...
// builderMock.with('foo','notValueFoo');
// at ...
```

NOTE
For anybody else having this problem, I'm rethrowing the exception raised with something like this:
```
    public static ArgumentsAreDifferent createExceptionWithEnhancedVerifyLogsFor(
            Object mockedObject,
            String invokedMethod,
            ArgumentsAreDifferent ex
    ) {
        String newline = System.getProperty(""line.separator"");
        String wanted = ex.getExpected();
        String actualTitle = MessageFormat.format(
                ""Interactions of {0}.{1}():"",
                mockedObject.getClass().getCanonicalName(), invokedMethod
        );
        String actual = mockingDetails(mockedObject).getInvocations().stream()
                .filter(invocation -> invocation.getMethod().getName().equals(invokedMethod))
                .map(Object::toString)
                .collect(Collectors.joining( newline ));
        String message = String.join(newline,
                ex.getClass().getCanonicalName(),
                ""Wanted: "" + wanted,
                actualTitle, actual
        );
        ArgumentsAreDifferent enhancedEx = new ArgumentsAreDifferent(message, wanted, actual);
        enhancedEx.setStackTrace(ex.getStackTrace());
        return enhancedEx;
    }
```""Nice report, thank you! Do you want to take a stub at fixing it? I suspect that we need to tweak the reporting, so that we print other interactions, too. We do something like that for regular verification failures (as opposed to verification failures due to mismatched arguments) =||= I can try and take a look at this. =||= hi @mockitoguy
sorry my email is bleeding with spam and I've been caught up with some deadlines
it would be an interesting piece of work that I'd like to take but I don't have the time right now for
it's going into my todo list, though =||= Just started working on this today. Doesn't seem like too bad of a change. I should have something to show later today or tomorrow. =||= "Show multiple invocations on argumentsAreDifferent"This is the reconciliation of #1556 with the tests fixed and implementation rebased on `release/2.x`.

Fixes #1542 "Tim van der LippeTimvdLippe05/02/19, 11:01:01 PM
1716.01723mockito-android 2.26+ tries to use missing opentest4j exceptions"It appears that Mockito `2.26+` on Android tries to use exceptions from OpenTest4j, even when OpenTest4j is not used, resulting in tests crashing due to exceptions classes not being found.

Steps to reproduce:

1. Open [MockitoAndroidDemo](https://github.com/mockito/mockito/files/3215946/MockitoAndroidDemo.zip) project in Android Studio
2. Run `ExampleInstrumentedTest.java` test on android device/emulator
3. Test will crash with `java.lang.NoClassDefFoundError: Failed resolution of: Lorg/opentest4j/AssertionFailedError`

Lowering version to `2.25.0` fixes the issue


""@kriegfrj do you mind taking a look at this? =||= I can't promise to look at it swiftly. I've never run an Android emulator before, it'll take me a while to get set up.

In the meantime, @matejdro , if you could post the stack trace of the error that would help. I might be able to get a clue without seeing up the whole environment. =||= Here you go:

[stacktrace.txt](https://github.com/mockito/mockito/files/3216729/stacktrace.txt)
 =||= Thanks.

Looks like you've got some funky ClassLoader in there doing something odd. I'll try and look more closely later, possibly later in the weekend. =||= I've had a quick look and I haven't been able to get the emulator running easily to reproduce it myself. However, having had a closer look at the stack trace, I suspect that it is some kind of feature in the test harness (perhaps in AndroidJUnitRunner) that is supposed to detect and warn when your code tries to load classes that it can't find on its classpath. Attempting to load the OpenTest4J class is perfectly normal behaviour for this version of Mockito though, and the attempt is surrounded by a <tt>catch()</tt> which ordinarily would catch any error thrown.

As a workaround, you could try putting OpenTest4J on your classpath. You might lose the visual diff in case of failure though. =||= Here is my guess on what happens:

Exceptions catching for missing classes only [surrounds factory creation, not the actual exception creation](https://github.com/mockito/mockito/blob/28012a49cb1b1aab1b957ac5e7507dd8b807a47e/src/main/java/org/mockito/internal/junit/ExceptionFactory.java#L23). It is possible that Desktop JVM verifies all methods on class creation, but Android's runtime does not. And thus no exception is thrown there. Instead Android's runtime throws missing class exception when `create()` method is executed for the first time, which does not have`try/catch` around it. =||= I thought about your suggestion, but I don't think it fits with the stack trace that you provided. In the stack trace, it's clear that the line it's complaining about is line 24, in the static initializer for `ExceptionFactory`, when the factory implementation is actually created:

at org.mockito.internal.junit.ExceptionFactory.<clinit>(ExceptionFactory.java:24)

I expect a `ClassNotFoundError` to get thrown here when OpenTest4J is not on the class path. What is not expected is that this isn't caught by the surrounding `catch(Throwable)` statement. Which is why I think the android test framework is doing something funky.

If what you're suggesting were true, I'd expect line 27 to appear at the top of the stack trace, but it doesn't appear at all. According to the stack trace, it is failing before `create()` is even called, This scenario would also be contrary to the JVM spec (which, from memory, specifies that all the class's linkages should be resolved when the class is loaded, and not when a method is executed).

One way to test this would be to package up a JUnit test and deploy it as an APK into the emulator and run it directly, rather than as part of an instrumentation test. If you want to give that a try and let me know how you go we can analyse the result. =||= Ok @matejdro , I still haven't been able to get the Android Studio stuff working, but based on the above educated guess I've made a change that might do the trick. You can find this change under branch `1716-opentest4j-under-android` in my fork of Mockito (https://github.com/kriegfrj/mockito). If you could download, build and install this and give it a try and let me know if it fixes your problem, that would be much appreciated.

If it does fix your problem, I'll create a PR from this branch so that @TimvdLippe  or @mockitoguy can merge it. If not, I guess I'll go back to the drawing board... =||= Sorry for the delay. Any tips on how to build `mockito-android`? Running `gradlew build` only procudes `mockito-core` and I cannot find a way to switch it to android.

P.S.: there appear to be checkstyle errors in the branch (I had to disable checkstyle to even get core to build) =||= Never mind, figured it out (android project is in the `subprojects` folder). 

It appears that using your branch fixes the issue. I no longer get the crash. =||= Thanks for verifying @matejdro. I have created a PR for this issue now (#1723).

Thank you so much for your help - I was dreading having to go through the process of getting the Android emulator working! I'm sure it would have been fun to try but (like most people) I'm a bit time poor... =||= I am also having this issue. I was running v3.0.0, but switching back to 2.25.0 fixed it.  =||= > I am also having this issue. I was running v3.0.0, but switching back to 2.25.0 fixed it.

Sorry @johnmahlon, the fix for this was supposed to get merged into 3.0 but I dropped the ball. Hopefully it will get merged soon.

In the meantime, as a workaround, if you need Mockito >2.25.0 then you should be able to run it with any version of Mockito if you just put `org.opentest4j` on your runtime classpath. =||= @kriegfrj no problem. Our app isn’t production yet, so using 2.25 is definitely fine for now.  =||= "Change implementation of ExceptionFactory to explicitly test for dependent classes"The original implementation of conditional OpenTest4J support (#1667) relied on some implicit behaviour of the Java classloader to generate and catch the exception at the right time. It seems that this behaviour is not always exactly replicated in all environments - for example, in #1716, where Mockito was being used in an instrumentation test that was being run on an Android emulator.

The new implementation is a bit more direct in how it tests for the dependent classes. The existing test cases still pass, and @matejdro confirmed that this fixed his problem.

Fixes #1716."Fr Jeremy Kriegkriegfrj07/19/19, 10:25:51 AM
1747.01760Typo in error message "https://github.com/mockito/mockito/blob/885e69420baa2a382f4394b85dc84cb6fe17fff6/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java#L219

""VM does not not support modification of given type""
should be 
""VM does not support modification of given type"""Feel free to open a PR with a fix. =||= Minor bug fixes"Fixes #1747: removed typo
Fixes #1513: Added missing tag to fix javadoc

Supersedes and closes #1748"Mateusz Mrozewskimateuszmrozewski08/16/19, 02:51:44 PM
1513.01760Mockito docs / javadocs - monospaced font all over the place after point 44"The brilliant Mockito javadocs are less brilliant than usual, because after
[44. Deprecated org.mockito.plugins.InstantiatorProvider as it was leaking internal API. it was replaced by org.mockito.plugins.InstantiatorProvider2 (Since 2.15.4)](https://static.javadoc.io/org.mockito/mockito-core/2.23.0/org/mockito/Mockito.html#mockito_instantiator_provider_deprecation)
almost everything is written with monospaced font which reduces readability. Apparently some closing tag is missing."This probably broke in #1439 with the dangling `<p>` on line 2540. Do you mind opening a PR to fix it? =||= Minor bug fixes"Fixes #1747: removed typo
Fixes #1513: Added missing tag to fix javadoc

Supersedes and closes #1748"Mateusz Mrozewskimateuszmrozewski08/16/19, 02:51:44 PM
1748.017601747 issue fix"Hey,
I have fixed the test case.
Please review it.
"Please rebase this PR to fix the Travis issue. =||= Minor bug fixes"Fixes #1747: removed typo
Fixes #1513: Added missing tag to fix javadoc

Supersedes and closes #1748"Mateusz Mrozewskimateuszmrozewski08/16/19, 02:51:44 PM
1769.01773Are strict stubs really the default in v3?"The Strictness.STRICT_STUBS javadoc reads: ""Planned as default for Mockito v3."".

I'm using ""org.mockito:mockito-core:3.0.0"" and strict stubs do not seem to be the default behaviour. Are they actually going to be the default in any release soon?""It is not. Mockito 3 only requires Java 8 as minimum. No other api changes were made. Could you submit a PR (similar to #1745) thats updates the doc? =||= What would be the easiest way of enabling it in Junit 5 given that I’m already using another Junit extension and lifecycle Per class?

`@ExtendWith(VertxExtension.class)`
`@TestInstance(TestInstance.Lifecycle.PER_CLASS)` =||= @TimvdLippe I just sent the PR. Any chance you could help me with the previous question? Also, is there an ETA for v4? Thanks very much. =||= The Junit 5 extension should already use strict stubs by default, does it not? =||= It does in fact seem to use strict stubs but I just double-checked and it does not throw UnnecessaryStubbingException when it should. PotentialStubbingProblem does work perfectly though. =||= "Fixes #1769: Clarify default strict stubbing behaviour in 3.0.0"Similar to https://github.com/mockito/mockito/pull/1745 as requested by @TimvdLippe in https://github.com/mockito/mockito/issues/1769

Closes #1769"Guillermo Pascualpasku09/04/19, 09:51:18 PM
1780.01781File-handle leak in InlineByteBuddyMockMaker"Using [file-leak-detector](https://file-leak-detector.kohsuke.org/) when running unit-tests using mockito-3.0.0 we see a file-handle-leak being reported in `InlineByteBuddyMockMaker.<clinit>` which can easily be fixed by closing the JarFile after usage properly.

I'll send a PR shortly.

```#2 ...\mockitoboot2606807734337514236.jar by thread:main on Tue Sep 17 15:55:43 CEST 2019
	at java.util.zip.ZipFile.<init>(ZipFile.java:156)
	at java.util.jar.JarFile.<init>(JarFile.java:166)
	at java.util.jar.JarFile.<init>(JarFile.java:130)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.<clinit>(InlineByteBuddyMockMaker.java:138)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)```"Fixes #1780: Close file handle to avoid a file-handle-leak"Fix a small file-handle-leak which pops up when running tests with [file-leak-detector](https://file-leak-detector.kohsuke.org/) 

Fixes #1780"Dominik Stadlercentic909/17/19, 03:06:53 PM
1655.01783Stubbing not stopped properly when running suite of tests"Hey,

I'm not sure the title describes the problem in the best way but I found the following.

Consider the two tests:
    
```java
public class MockitoMisusingUnitTest {

    @Test
    public void givenNotASpy_whenDoReturn_thenThrowNotAMock() {
        try {
            List<String> list = new ArrayList<String>();

            Mockito.doReturn(100, Mockito.withSettings().lenient())
                .when(list)
                .size();

            fail(""Should have thrown a NotAMockException because 'list' is not a mock!"");
        } catch (NotAMockException e) {
            assertThat(e.getMessage(), containsString(""Argument passed to when() is not a mock!""));
        }
    }
}
```

```java
@RunWith(MockitoJUnitRunner.class)
public class MockitoVoidMethodsUnitTest {

    @Test
    public void whenAddCalledValueCaptured() {
        ArrayList<String> mockVoid = mock(ArrayList.class);
        ArgumentCaptor<String> valueCapture = ArgumentCaptor.forClass(String.class);
        doNothing().when(mockVoid).add(any(Integer.class), valueCapture.capture());
        mockVoid.add(0, ""captured"");
        assertEquals(""captured"", valueCapture.getValue());
    }

}
```

When run independently pass. When run together from eclipse or mvn the second test `MockitoVoidMethodsUnitTest.whenAddCalledValueCaptured` fails but because of something detected in the other test:
```
org.mockito.exceptions.misusing.UnfinishedStubbingException: 
Unfinished stubbing detected here:
-> at org.baeldung.mockito.misusing.MockitoMisusingUnitTest.givenNotASpy_whenDoReturn_thenThrowNotAMock(MockitoMisusingUnitTest.java:28)

E.g. thenReturn() may be missing.
Examples of correct stubbing:
    when(mock.isOk()).thenReturn(true);
    when(mock.isOk()).thenThrow(exception);
    doThrow(exception).when(mock).someVoidMethod();
Hints:
 1. missing thenReturn()
 2. you are trying to stub a final method, which is not supported
 3: you are stubbing the behaviour of another mock inside before 'thenReturn' instruction if completed

-> at org.baeldung.mockito.MockitoVoidMethodsUnitTest.whenAddCalledValueCaptured(MockitoVoidMethodsUnitTest.java:30)
```

This is the call stack:
```
MockingProgressImpl.validateState() line: 109	
MockingProgressImpl.stubbingStarted() line: 98	
MockitoCore.stubber(Strictness) line: 179	
MockitoCore.stubber() line: 174	
Mockito.doNothing() line: 2421	
MockitoVoidMethodsUnitTest.whenAddCalledValueCaptured() line: 30	
```

And the method where it then fails inside `MockingProgress.java`:
```java
public void validateState() {
    validateMostStuff();

    //validate stubbing:
    if (stubbingInProgress != null) {
        Location temp = stubbingInProgress;
        stubbingInProgress = null;
        throw unfinishedStubbing(temp);
    }
}
```

I think this is a bug, tests should be independent and not cause side affects on each other. Maybe something is not cleaned up properly between test runs.

If I add this tear down to `MockitoMisusingUnitTest` then it works ok:
```java
    @After
    public void tearDown() {
        ThreadSafeMockingProgress.mockingProgress().reset();
    }	
```

I don't mind to have a go at fixing it, but I would need some help or hints. This was tested with the latest version 2.24.5.

Thanks"Any thoughts on this one? I'm just curious to know. =||= Cleaned up state after stubbing misuse exceptionFixes #1655Szczepan Fabermockitoguy09/25/19, 02:53:33 PM
1630.01789Mockito JUnit Jupiter extension does not correctly support parallel test execution"Sorry for not being able to provide the required information, but we just noticed that the MockitoExtension (mockito-junit-jupiter 2.24.5) leads to spurious test failures (e.g. due to calls to mocks not being recorded) when using ""junit.jupiter.execution.parallel.enabled=true"" with surefire. Prior we used our much simpler MockitoExtension which works fine in the same situation:

```java
public class MockitoExtension implements Extension, TestInstancePostProcessor, AfterEachCallback {
   @Override
   public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
      MockitoAnnotations.initMocks(testInstance);
   }

   @Override
   public void afterEach(ExtensionContext extensionContext) throws Exception {
      Mockito.validateMockitoUsage();
   }
}
```""Hey! Can you take a look at our FAQ wiki. We documented how Mockito supports parallel execution. =||= I took a look at the wiki, but found just a very short section about parallel testing in the FAQ section. I issued the bug, because the parallel execution of whole test cases with JUnit 5 seems to be broken. I do not have any complex tests which use mocks in combination with multithreading.

Anyway this seems to be a problem of the MockitoExtension, not Mockito itself. Because with our simple JUnit 5 extension for Mockito, parallel execution of test cases which use mocks with JUnit 5 works fine. =||= I got a similar issue. 
I have got a workaround, if only a few of your ""Mockito""-test-classes in you testsuite are failing when running JUnit jupiter in parallel. You can execute those problematic tests using ""SAME_THREAD"" for avoiding Mockito concurrency issues.

```
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
@Execution(ExecutionMode.SAME_THREAD) // <--- Workaround
class SomeTest {
``` =||= To be a bit more specific, WantedButNotInvoked exceptions are thrown by verification calls failing, because of not recorded invocations: ""Actually, there were zero interactions with this mock."". =||= The main difference between the current and the simple implementation above is, that the simple one inits the mocks in postProcessTestInstance() whereas the current one inits them in beforeEach(). Any ideas why that might be a problem? 

I tried the failing tests with a modified version of the current MockitoExtension which was just altered to init the mocks in postProcessTestInstance() and disabled the init in beforeEach() and the tests do no longer fail. So this seems to be the source of the problems. =||= Hey guys, can you provide us a test that reproduces the problem? Thanks! =||= @mockitoguy Here you go: https://github.com/SchulteMarkus/mockito.bug1630

I am not sure, if I reduced the example as much as possible, but, well, the project is not large. =||= Thank you! The sample project looks great!

I looked at the code but I haven't had time to debug it. How does the JUnit5 parallel execution work? Are we sharing the test instance (and thus, sharing mocks, SUTs?). =||= You are welcome :-) 
I don't know details about JUnit's parallelization. =||= > How does the JUnit5 parallel execution work? Are we sharing the test instance (and thus, sharing mocks, SUTs?).

By default not, and the user must be very explicit to enable sharing of the same test class instance with parallel execution enabled. I.e., even if parallel execution mode is enabled by default, and a test class is annotated with `Lifecycle.PER_CLASS`, its tests will still be executed sequentially _unless_ it is also annotated with `@Execution(CONCURRENT)`: https://junit.org/junit5/docs/current/user-guide/#writing-tests-parallel-execution

I also bumped into this issue in our codebase, with some tests using `MockitoExtension` failing in parallel mode, and some working fine. Could not spot anything particularly special about the failing ones.
 =||= I can confirm, that the problem exists. I also have tests using MockitoExtension and they fail in a non-deterministic way randomly only if Junit5 parralelization is used. =||= Scenario:

1. JUnit 5 creates a single `ClassExtensionContext `for a multithreaded test, but each thread becomes an instance of the test class
2. Each thread will come into `postProcessTestInstance `where they put their test instance in the same `ClassExtensionContext.getStore(MOCKITO)` map with the same key (`TEST_INSTANCE`)
3. Each thread then will get into `beforeEach`. They get a thread unique `MethodExtensionContext`, but each of them contain the same instance of `ClassExtensionContext`. Then they fetch the the last updated `TEST_INSTANCE `from the parent `ClassExtensionContext `inside the `collectParentTestInstances `method. Each thread gets quasi a random Test Instance depending on the fact which thread was before inside the `postProcessTestInstance `method. Then they prepare their broken Session inside the store of the current `MethodExtensionContext `with a random Test Instance included.

That is the explanation. I am thinking about how to solve this.

It is not 100% clear to me why the parent context test instance is included. I will check how this scenario looks like in a singlethreaded environment. =||= This is really painful to debug but I'm making progress. What I found out is that ""collectParentTestInstances()"" is non-deterministic:

```
Thread[16] collectParentTestInstances() - returns: [org.mockito.AnotherTest@2bf588f6]
Thread[13] collectParentTestInstances() - returns: [org.mockito.AnotherTest@240da1f5, org.mockito.AnotherTest@6646267a]
Thread[17] collectParentTestInstances() - returns: [org.mockito.AnotherTest@6646267a]
Thread[14] collectParentTestInstances() - returns: [org.mockito.AnotherTest@f9b9d48]
```

Notice that AnotherTest@6646267a is processed twice. Effectively, initMocks() is called twice for that test instance, clearing up the invocations.

Do you have an idea how to fix collectParentTestInstances()? =||= Perhaps we drop the collectParentTestInstances() complexity and just keep the test instances in static ThreadLocal object in the extension. postProcessTestInstance() feeds the thread local state, beforeEach() consumes it. I don't know enough about the ""context store"" API, though. =||= I have a plan how to fix it. First, we need to upgrade junit-jupiter (#1788) =||= @mockitoguy I am not sure why you have closed the issue. In the attached commit I cannot see the fix for the problem.

Context store API seems to be pretty simple to me, it is just a map in the context to store some information. The real question is what is this kind of context hierarchy used for in Junit 5 and how it behaves in case of nested tests or multithreaded tests, or even in multithreaded nested tests. I guess it could have some interesting beahaviour in case of parameterized (dynamic) tests. Probably it would be a good idea simply to ask the JUnit developers about this issue. Maybe they could provide some valuable feedback. =||= PR #1789 fixes the problem. This ticket got closed by accident. Thanks for looking into it! =||= Looking forward to the next release!
I would like to confirm the bug is gone, but I don't know how to do it in https://github.com/SchulteMarkus/mockito.bug1630.
Can someone add a PR to https://github.com/SchulteMarkus/mockito.bug1630 using Mockito 3.0.12 (at least)?  =||= Release have been already published. See https://bintray.com/mockito/maven/mockito-development =||= @mockitoguy when will this fix be released to maven central? =||= I will publish a release today =||= I updated https://github.com/SchulteMarkus/mockito.bug1630 - seems to work without problems using Mockito v.3.1.0, thanks a lot!
I will delete https://github.com/SchulteMarkus/mockito.bug1630 within a few weeks. =||= Publish to Maven Central failed yet again. I will need to contact sonatype again... =||= (Although https://repo1.maven.org/maven2/org/mockito/mockito-core/3.1.0/ does exist, so it might just work) =||= I can confirm, that the solution of 3.1.0 version works for all of the tests in my project. Still I don't understand how JUnit works, but it is fine now, since the tests work.

Thanks for your fast fix & release! =||= "Fixed JUnit Jupiter parallel issue"Fixes #1630

This fix improves Mockito JUnit Jupiter extension. However, it does not completely resolve all kinds of parallel issues when nested test classes are used. I'll open a separate ticket for it."Szczepan Fabermockitoguy09/30/19, 04:51:00 PM
1791.01798"Typo in Mockito.java Javadoc: ""verification"" in wiki link""https://github.com/mockito/mockito/blob/f8581c6e875dc3fb587fe31e85d025ef4d110a3f/src/main/java/org/mockito/Mockito.java#L2579

There's a missing ""i"" in the wiki link:

```
https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verfication-InOrder
https://github.com/mockito/mockito/wiki/Greedy-algorithm-of-verification-InOrder
```"Feel free to send a PR! =||= Fix typo in the wiki link"Fixes #1791

check list

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_
"Kemal Özcanyekeoe10/05/19, 10:08:12 AM
1587.01810InjectingAnnotationEngine does an unnecessary loop."processInjectMocks method of InjectingAnnotationEngine does unnecessary work. It might call injectMocks several times while it is sufficient to call injectMocks once.

    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {
        Class<?> classContext = clazz;
        while (classContext != Object.class) {
            injectMocks(testInstance);
            classContext = classContext.getSuperclass();
        }
    }

Inside, injectMocks loops classes by himself.

    public void injectMocks(final Object testClassInstance) {
        Class<?> clazz = testClassInstance.getClass();
        Set<Field> mockDependentFields = new HashSet<Field>();
        Set<Object> mocks = newMockSafeHashSet();

        while (clazz != Object.class) {
            new InjectMocksScanner(clazz).addTo(mockDependentFields);
            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);
            onInjection(testClassInstance, clazz, mockDependentFields, mocks);
            clazz = clazz.getSuperclass();
        }

        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);
    }

Why not delete the unnecessary loop?""Revert ""Fixes #1587 : Remove unnecessary loop from InjectingAnnotationEngine""""Reverts mockito/mockito#1588
Related to #1631 

Here's a pseudo code to describe the issues around this issue.

# Before 2.23.15:	

```
while (clazz != Object.clazz) {
	val mocks = aggregateSpyOrMockFields(clazz.getMockFields());
  val fields = aggregateInjectMocksFields(clazz);
	val ret = tryConstructorInjection(clazz, fields, mock);
  if (! ret.fieldWasInitializedUsingConstructorInjection()) {
    trySetterOrPropertyInjection(clazz, fields, mock);
  }
	clazz = clazz.getSuperclass();
}
```
# After 2.23.15:
```
	val mocks = aggregateSpyOrMockFields(clazz.getMockFields());
  val fields = aggregateInjectMocksFields(clazz);
	val ret = tryConstructorInjection(clazz, fields, mock);
  if (! ret.fieldWasInitializedUsingConstructorInjection()) {
    trySetterOrPropertyInjection(clazz, fields, mock);
  }
```

# Details

Before 2.23.15, if the `@InjectMocks` field has a field that not listed in the constructor argument will fill by setter/property injection at the 2nd loop 😃
It may not the expected behaviors by Mockito authors, but some users' code depends on this behavior.

My suggestion is to revert the [Fixes #1587 : Remove unnecessary loop from InjectingAnnotationEngine by LihMeh · Pull Request #1588 · mockito/mockito · GitHub](https://github.com/mockito/mockito/pull/1588) at this time."Tokuhiro Matsunotokuhirom10/29/19, 10:37:02 AM
1767.01821'MismatchReportingTestListener' has already been added and not removed using MockitoJUnitRunner" - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
```
import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.hasProperty;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.hamcrest.MockitoHamcrest.argThat;

import java.io.File;
import java.io.IOException;
import java.util.function.Consumer;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.pdfsam.support.params.SingleOutputTaskParametersBuilder;
import org.pdfsam.test.InitializeAndApplyJavaFxThreadRule;

@RunWith(MockitoJUnitRunner.class)
public class BrowsablePdfOutputFieldTest {
    @Rule
    public TemporaryFolder folder = new TemporaryFolder();
    @Rule
    public InitializeAndApplyJavaFxThreadRule fxThread = new InitializeAndApplyJavaFxThreadRule();
    @Mock
    private SingleOutputTaskParametersBuilder<?> builder;
    @Mock
    private Consumer<String> onError;

    @Test
    public void valid() throws IOException {
        BrowsablePdfOutputField victim = new BrowsablePdfOutputField();
        File value = folder.newFile(""test.pdf"");
        victim.getTextField().setText(value.getAbsolutePath());
        victim.apply(builder, onError);
        verify(builder).output(argThat(hasProperty(""destination"", equalTo(value))));
        verify(onError, never()).accept(anyString());
    }

    @Test
    public void invalid() {
        BrowsablePdfOutputField victim = new BrowsablePdfOutputField();
        victim.enforceValidation(true, true);
        victim.getTextField().setText(""ChuckNorris"");
        victim.apply(builder, onError);
        verify(builder, never()).output(any());
        verify(onError).accept(anyString());
    }
}
```
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
Mockito 3.0.0, AdoptOpenJDK 11.0.4, Linux Mint
 - [ ] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)

I migrated from 1.10.19 to the 3.0.0 version and I have few tests using the MockitoJUnitRunner which are failing with the following stacktrace:

```
org.mockito.exceptions.misusing.RedundantListenerException: 
Problems adding Mockito listener.
Listener of type 'MismatchReportingTestListener' has already been added and not removed.
It indicates that previous listener was not removed according to the API.
When you add a listener, don't forget to remove the listener afterwards:
  Mockito.framework().removeListener(myListener);
For more information, see the javadoc for RedundantListenerException class.
	at org.mockito.internal.runners.DefaultInternalRunner$1$1.evaluate(DefaultInternalRunner.java:41)
	at org.junit.rules.ExternalResource$1.evaluate(ExternalResource.java:48)
	at org.pdfsam.test.JavaFXThreadRule$1.lambda$evaluate$0(JavaFXThreadRule.java:48)
	at com.sun.javafx.application.PlatformImpl.lambda$runLater$10(PlatformImpl.java:428)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:389)
	at com.sun.javafx.application.PlatformImpl.lambda$runLater$11(PlatformImpl.java:427)
	at com.sun.glass.ui.InvokeLaterDispatcher$Future.run(InvokeLaterDispatcher.java:96)
	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method)
	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:277)
	at java.base/java.lang.Thread.run(Thread.java:835)
```
It seems something internal, I didn't add or remove any `MismatchReportingTestListener` and moreover the same code was working with the 1.10.19 and is working if I remove the `MockitoJUnitRunner` and replace the `@Mock` annotation with a `Mockito.mock` in a `@Before` method.


""A lot of updates exist between 1.10.19 and 3.0.0. Could you bisect the versions and figure out which minor version introduced the issue? =||= 2.26.0 looks like the one introducing this issue, all green in 2.25.1 =||= @torakiki, can you provide us a simpler test that reproduces the issue? We are looking for a test without dependencies such as InitializeAndApplyJavaFxThreadRule, so that we can run & reproduce it in Mockito project.

Thanks for reporting!  =||= @torakiki any luck? I'm having the same issue, upgrading from 2.23.4

@mockitoguy here's a simple test reproducing the issue in my case:
```java
@RunWith(MockitoJUnitRunner.class)
public class UuidHelperTest {


    @Test
    public void should_Get_16_Bytes_From_a_UUID() {
        UUID uuid = UUID.randomUUID();

        byte[] result = UuidHelper.getBytesFromUUID(uuid);

        assertThat(result.length, is(16));
    }

}

public class UuidHelper {

    public static final int UUID_SIZE_IN_BYTES = 16;


    public static byte[] getBytesFromUUID(UUID uuid) {
        ByteBuffer bb = ByteBuffer.wrap(new byte[UUID_SIZE_IN_BYTES]);
        bb.putLong(uuid.getMostSignificantBits());
        bb.putLong(uuid.getLeastSignificantBits());

        return bb.array();
    }

}
``` =||= @SharonHart, this test works fine with current Mockito (3.0). Can you provide a test that fails with current Mockito? Thank you! =||= @mockitoguy It works with the current Mockito version for me as well, on a clean project.
 But in one specific project it doesn't, after a similar upgrade, as the one mentioned in this issue.  =||= @marcphilipp, @TimvdLippe Maybe this PR is related?
https://github.com/mockito/mockito/pull/1672/files#diff-f266327a2222bf41843bb64e18ba766eL59
It was merged between the versions @torakiki mentioned [here](https://github.com/mockito/mockito/issues/1767#issuecomment-527094823). 
Used to removeListener in case of test failure during setup, the same thing as the exception states that needs to be done.

Edit: I've reverted the commit locally and published to m2. Everything works now. Can this be reverted or checked for root cause? =||= @SharonHart Which version of JUnit are you using? We had a regression since 4.13 which is why we made the changes. See https://github.com/junit-team/junit4/pull/1599 =||= @TimvdLippe JUnit 4.12

By the way, seems like what's causing the regression for me is the withBefores statement part, not the 'started' field removal in the RunListener. But, the regression you've mention was with the prior, right? =||= @SharonHart Could you please provide a sample project so we can reproduce the issue? =||= @marcphilipp Unfortunately, I can't. I tried to copy the test to a clean project and it didn't reproduce.
Happening only in command line build, in one project which I can't share due to size and internal dependencies. 
I can verify if a fix works though, the same way I've managed to check if reverting the commit fixed the issue. =||= Are you running tests in parallel or anything like that? =||= Yes, in our CI pipeline. But reproduced locally with a single executor. It might be that the single one is running modules in parallel. I'm not sure.  =||= How are you running those tests? Maven Surefire? =||= No, with gradle, without extra plugins =||= What happens when you upgrade to JUnit 4.13-rc-1? =||= Same. =||= While I cannot provide a sample project to reproduce this issue, here are some observations that I made when running into the same issue:
1. I seems to be related one of the `@Rule`: I use a similar rule to what @torakiki has in his example:
<pre>
public class JavaFXThreadingRule implements TestRule {

        /**
        * Flag for setting up the JavaFX, we only need to do this once for all tests.
        */
        private static boolean jfxIsSetup;

        @Override
        public Statement apply(Statement statement, Description description) {

            return new OnJFXThreadStatement(statement);
        }

        private static class OnJFXThreadStatement extends Statement {

            private final Statement statement;

            public OnJFXThreadStatement(Statement aStatement) {
                statement = aStatement;
            }

            private Throwable rethrownException = null;

            @Override
            public void evaluate() throws Throwable {

                if(!jfxIsSetup) {
                    setupJavaFX();

                    jfxIsSetup = true;
                }

                final CountDownLatch countDownLatch = new CountDownLatch(1);

                Platform.runLater(() -> {
                    try {
                        statement.evaluate();
                    } catch (Throwable e) {
                        rethrownException = e;
                    }
                    countDownLatch.countDown();
                });

                countDownLatch.await();

                // if an exception was thrown by the statement during evaluation,
                // then re-throw it to fail the test
                if(rethrownException != null) {
                    throw rethrownException;
                }
            }

            protected void setupJavaFX() throws InterruptedException {

                long timeMillis = System.currentTimeMillis();

                final CountDownLatch latch = new CountDownLatch(1);

                SwingUtilities.invokeLater(() -> {
                    // initializes JavaFX environment
                    new JFXPanel();

                    latch.countDown();
                });

                System.out.println(""javafx initialising..."");
                latch.await();
                System.out.println(""javafx is initialised in "" + (System.currentTimeMillis() - timeMillis) + ""ms"");
            }

        }
}</pre>
2. My test class contains multiple test methods. Running them separately woks, when running them in combination (from within the IDE) the first one succeeds and then the remaining fail with this exception.
3. Removing the rule makes all tests succeed safe the ones that actually require the rule. =||= @hotzst Nice! I have managed to find that for me as well, a MethodRule we're implementing is what caused this. Question is, how should it be changed for the updated Mockito version.

```java

import org.joda.time.DateTimeZone;
import org.junit.rules.MethodRule;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;
import org.mockito.Mockito;
import org.mockito.internal.junit.MockitoTestListener;

import java.util.TimeZone;

/*
* When adding this rule to a Junit test, any @Test method annotated with @TimeZoned will be ran multiple times, each time
* with a different system timezone.
* This rule is useful to ensure you are handling all timezones correctly.
* Note: for Mockito, you may need to use Mockito.reset() if you are using verify().
* */
public class TimeZoneUpdateRule implements MethodRule {

    final private TimeZone timeZone;
    final private DateTimeZone dateTimeZone;
    private final static String[] allTimeZones = {""UTC"", ""Asia/Jerusalem"", ""Europe/London"", ""US/Pacific"", ""EST5EDT"", ""US/Eastern"",
            ""Australia/Sydney"", ""US/Central"", ""Asia/Tokyo"", ""America/Chicago"", ""GMT"",
            ""Europe/Amsterdam"", ""Europe/Berlin"", ""Brazil/East"", ""Asia/Jakarta"", ""Europe/Athens"",
            ""Australia/Queensland"", ""Asia/Singapore"", ""Asia/Bangkok"", ""America/Bogota"",
            ""America/Los_Angeles"", ""Asia/Hong_Kong"", ""America/New_York"",
            ""America/Argentina/Buenos_Aires""};

    public TimeZoneUpdateRule() {
        timeZone = TimeZone.getDefault();
        dateTimeZone = DateTimeZone.getDefault();
    }

    public void reset() {
        setTimeZone(timeZone, dateTimeZone);
    }

    protected void after() {
        reset();
    }

    private void setTimeZone(String timeZoneID) {
        setTimeZone(TimeZone.getTimeZone(timeZoneID), DateTimeZone.forID(timeZoneID));
    }

    private void setTimeZone(TimeZone timeZone, DateTimeZone dateTimeZone) {
        System.setProperty(""user.timezone"", timeZone.getID());
        TimeZone.setDefault(timeZone);
        DateTimeZone.setDefault(dateTimeZone);
    }

    private static String[] getTimeZones() {
        return allTimeZones;
    }


    @Override
    public Statement apply(final Statement st, final FrameworkMethod method, Object target) {
        return new Statement() {
            public void evaluate() throws Throwable {
                TimeZoned timeZoned = method.getAnnotation(TimeZoned.class);
                if(timeZoned !=null){
                    String[] timeZones =  timeZoned.timeZones().length > 0  ? timeZoned.timeZones() : getTimeZones();
                    applyAllTimeZones(st, timeZones);
                }else{
                    st.evaluate();
                }
            }

        };
    }

    private void applyAllTimeZones(Statement st, String[] timezones) throws Throwable {
        try {
            for (String tz : timezones) {
                setTimeZone(tz);
                st.evaluate();
            }
        }catch (AssertionError t){
            throw new AssertionError(getMessage(), t);
        }catch (Exception e){
            throw new RuntimeException(getMessage(), e);
        }
        finally {
            after();
        }
    }

    private String getMessage() {
        return ""test failed for timezone ["" + TimeZone.getDefault().getID()+ ""]"";
    }
}
``` =||= Thanks for the additional info. I think #1821 should restore the old behavior. =||= Thanks! =||= "Guard against multiple evaluations of before statement"Some rules evaluate the base statement multiple times, e.g. to execute
tests repeatedly. The changes made in #1672 led to an exception in such
cases because the `MockitoListener` was registered multiple times. Now,
we only add the listener the first time the statement is evaluated in
order to restore the old behavior.

Fixes #1767."Marc Philippmarcphilipp11/10/19, 08:02:27 PM
1839.01840Bintray badge is out of date"The badges in README.md show:
```
maven-central 3.2.0 Download 3.1.13
```
That makes the project looks sloppy, as if the developers forgot to update their downloads. ""Download"" is actually a link to Bintray, which should be clarified.

Bintray does have version 3.2.0. The old version is shown because the package name in the link is wrong. It should be ""mockito"", not ""mockito-development"""Fixes #1839 : Badge improvements in README.md"```
*  Fixes #1839 : Badge improvements in README.md
   
   Use shields.io badge for Bintray, as the Bintray hosted badge shows
   ""Download"" and cannot be made to show ""Bintray"".
   
   Split an excessively long line for the first row of badges.
   
   Update the alt text for ""Release Notes"". Non-graphical users would only
   see a link to the release notes.
   
   ""Javadoc"" was misspelled as ""Javadocs"".
   
   Use HTTPS for all links.
   
   Use direct links to the package on Maven Central and Bintray.
   
   Use the default color for Javadoc, red looks as an error.
```"Pavel Roskinproski12/06/19, 03:25:02 PM
1841.01842Update byte-buddy to 1.10.5"Hi,

Byte-buddy had a bug that prevented running tests in IntelliJ due to space in the executable name: https://github.com/raphw/byte-buddy/issues/732 This was fixed in [1.10.5](https://github.com/raphw/byte-buddy/releases/tag/byte-buddy-1.10.5) so it would make sense to update it in Mockito as well."Upgrade byte buddy to 1.10.5"check list

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_

Fixes #1841 

Byte buddy had a bug that prevented running tests in IntelliJ that's now fixed."Ville Saukkonenvillesau12/12/19, 12:53:14 AM
1843.01845java.time.Duration not present before SDK 26"Unable to use Mockito 3.1.7+ with Android on lower SDK devices.

Reason:
- https://github.com/mockito/mockito/issues/1815
- https://github.com/mockito/mockito/pull/1818

https://developer.android.com/reference/java/time/Duration <-- This was not added to Android until SDK 26.

https://developer.android.com/about/dashboards <-- here are some distribution stats.  Most noticeably, this would impact testing for 70% of the market and is not ideal.  

```
java.lang.NoClassDefFoundError: java.time.Duration
at org.mockito.Mockito.timeout(Mockito.java:2856)
```""This is an unintended breakage. `java.time.Duration` was added in Java 8, which is our minimum supported version. Android is lacking behind in implementing these, which means that we have to come up with a compatibility guarantee for Android SDK versions.

@kluever I would like to revert your change for now until we can resolve this matter. =||= Womp womp...OK! =||= > https://developer.android.com/about/dashboards <-- here are some distribution stats. Most noticeably, this would impact testing for 70% of the market and is not ideal.

And this would impact backend even more. Mockito 3 is java 8 based, there's no reason to not use java 8 types.

Plus changing the API back and forth introduces loads of compatibility issues.

I'd rather revert https://github.com/mockito/mockito/pull/1845, and instead introduces compatibility  verification modes for pre Java 8 users.

And I believe there's some new game changing feature coming to stock android tool chain if it's not already thetre: **desugaring**. In particular it could desugar APIs : https://jakewharton.com/androids-java-8-support/#desugaring-apis =||= > I'd rather revert #1845, and instead introduces compatibility verification modes for pre Java 8 users.

Yeah I would like to recommit `java.time.Duration`, but would like to solve the problem of compatibility first. Since it is unlikely anyone used this method in the short period (<1 week) it was unavailable, I think the overall impact has been minimal. Given that the value is minimal, but would break the majority of Android users, I think reverting is the correct choice.

We might be able to add the API in a separate class and exclude it in `mockito-android`? The more prominent problem is that Android has not supported Java 8 features for a long time, which is now a problem. =||= The fact that Android is not real Java is the base of the issue, this is likely that Android API and JDK API diverge or evolve differently. Android is dragging behind every backend library due to this issue with API level. And Mockito 3 is Java 8, if some needs older version there's still Mockito 2.x, that is tailored for previous versions of the JDK.

My opinion with this is :
If application needs to stick with older versions of the API level, then they have to understand the project cannot update some libraries as well, and that's fine. Previous mockito versions work.
That's the same as server development, if I'm on Java 8 I cannot use the fancy new stuff that are available on some libraries that are tailored for JDK 12, that's a bummer but that's software life. =||= @TimvdLippe Hello, ""anyone"" here and I managed to use it. I use compiler flag that treats deprecation warnings as errors and resolve them immediately and not let code rot years until upgrading unsupported libraries becomes yearlong project of its own.

For now I can make revert to over own commit, but it will also cause problems to others writing new test..

> [error] 17 errors found
[error] (Test / compileIncremental) Compilation failed   =||= Mockito claims no breaking changes for Mockito 3...the Duration addition made this untrue. The Duration API should be separated so that Android who may not have accessibility to newer versions of Java for years can still function and update. =||= > ""Mockito 3 does not introduce any breaking API changes, but now requires Java 8 over Java 6 for Mockito 2.""

There wasn't any braking changes, worked fine with Java 8+ when change were combined with deprecation tags. It is point of view what is braking change, and in my point of view, first baking change happened when added API was removed.

I probably can stop my upgrades and wait 4.x. I was stuck to `1.10.19` over 2 years waiting https://github.com/mockito/mockito/issues/1074 to be resolved, now that I can use 3.2.0 (probably 3.2.2 works also) I can wait another year or more. =||= When it breaks the majority of the market share for a platform and requires an SDK level that only supports the last 2-3 SDK levels, it most certainly is. Are you claiming in <1 week you have a full test suite that would be rendered useless by this reversion? This killed 400+ tests for me.

Just use the version before the revert :P

As mentioned above it's not going away forever, it just needs to be a separate API to be best practice for all platforms. =||= > Mockito claims no breaking changes for Mockito 3

Yes that was for users that needed to upgrade from Java 6 to Java 8. To use Mockito 3, the consuming project needs to be compiled and run with Java 8 already, that means that all APIs that were present in Mockito 2 are present in Mockito 3, but does not prevent Mockito additional API using Java 8 types to be added like `Optional`.

> When it breaks the majority of the market share for a platform and requires an SDK level that only supports the last 2-3 SDK levels, it most certainly is.

When the project is upgraded to the latest version that is based on Java 8 minimum when the Android SDK that is not even Java 8 compatible, the responsibility is not on the library.

> ""Mockito 3 does not introduce any breaking API changes, but now requires Java 8 over Java 6 for Mockito 2.""

That holds true as Mockito is following Java versions, not Android lifecycle. If you can compile with Java 6 it will compile the same if the consuming project uses with Java 8. Android SDK is another story. 

Currently I think that old Android SDKs users should prefer Mockito 2 as the APIs of the Android SDK and Java 6 are somewhat aligned, otherwise they should assume possible breakage if using Mockito 3 which is Java 8 minimum (that means class version and runtime APIs). =||= Why penalize Android developers when it could be a separate API and give both parties what they want?

Again, no one is saying ""take Duration and Java 8 away permanently"" at the detriment of web/java developers...simply, it needs to be implemented in a compatible manner for both.

The fact is, this change is new in Mockito 3.1.7+ and the impact is more for developers updating with an existing test suite than those who are just now writing tests with this new functionality. =||= I dont have time to provide a full comment (1AM here), but will provide one tomorrow.

For now: please accept my apology for those who used the new Duration API and were impacted by the revert. This has been an unfortunate change that broke a lot of existing Android users. Given the widespread usage of Mockito in the Android community and thus the large impact of the breaking change by relying on java.time.Duration, reverting felt like the least intrusive option. Yes, this would again break users who used the new api, but my assumption was that the amount of users that eagerly upgraded to the new api would be minimal, compared to existing users.

However, we do need to resolve this issue at large, as we should not hold back improvements on Mockito itself, because a different ecosystem is/was lacking behind. For this, I wanted to provide myself and the other core maintainers some more time to make a decision. That's why I reverted the PR in question, to allow us to make a sensible and thoughtful decision.

I will do a full write-up tomorrow and also notify the Android folks at Google of this issue. Hopefully they can figure out a solution that would not hold libraries like Mockito (but I imagine a lot of other libraries as well) back.

I apologize for any inconvenience caused. Thank you for your understanding. I will comment further tomorrow. =||= > Why penalize Android developers when it could be a separate API and give both parties what they want?

Android developers are not penalized, this is how software versionning is working. Android devs using a more recent version of the ANdroid SDK can use later versions. 

You have to ask yourself if Android SDK pre 26 is not Java 8 compatible, why is the project you are working on using Java 8 libraries ?

Also, providing a separate API for Android SDK is certainly feasible, given the pace and the direction of the Andorid SDK development compared to Java, we might end up with many API classes, I'm not sure that's wise. AssertJ do that, and it's a regular pain to use as method are moved to AssertionsJava6, etc. Not to mention the code change needed when upgrading.

[@JakeWharton 22h
The video of my @KotlinConf talk ""What's new in Java 19: The end of Kotlin?"" is now available!](https://twitter.com/JakeWharton/status/1207278039991762950?s=20)

Having a separate Android API is not out of question, but it has various drawbacks, including maintainability on Mockito's side as well as on the consumer side. I'll be be quite cautious on this path. I'd rather prefer saner appraoch with versionning. Or Android devs to resolve this issue, e.g. with _D8_ that will _desugar_ stuff for older SDKs.

[@JakeWharton 17h
Just published ""D8 Library Desugaring"" which covers how APIs like streams, optional, and java.time are backported in AGP 4.0.](https://twitter.com/JakeWharton/status/1207344151450308608?s=20)

 =||= I started writing a postmortem, which you can find at https://github.com/mockito/mockito/wiki/Android-Java-8-%60java.time.Duration%60-postmortem

Since it is almost Christmas vacation, i won't be able to start working on some of the action items. In the new year, I can hopefully work on that. =||= @TimvdLippe Note that the market share link you used hasn't been updated for nearly 1 year:

""Data collected during a 7-day period ending on May 7, 2019."" =||= ""Revert ""Add Duration overloads. Fixes #1815""""Reverts mockito/mockito#1818

Fixes #1843"Tim van der LippeTimvdLippe12/16/19, 11:47:03 AM
1846.01847Broken unused stubbing reporting when matching previous stubbed call"When stubbing the same method call twice, and the second stub setup matches to first stubbed call, the first stub is not reported as unused, because Mockito detects the next stub setup as a usage of the previous stub setup. This is an example test:
```
public class UnnecessaryStubbingWithImplicitEqMatchers {
    @Mock IMethods mock;
    MockitoSession mockito = Mockito.mockitoSession().initMocks(this).strictness(Strictness.STRICT_STUBS).startMocking();

    @After public void after() {
        mockito.finishMocking();
    }

    @Test public void unnecessary_stubbing() {
        given(mock.simpleMethod(""1"")).willReturn(""one"");
        given(mock.simpleMethod(""2"")).willReturn(""three"");
        given(mock.simpleMethod(""1"")).willReturn(""two"");
        given(mock.simpleMethod(""1"")).willReturn(""four"");

        mock.simpleMethod(""1"");
        mock.simpleMethod(""2"");
    }
}
```

The test above should fail with `UnnecessaryStubbingException` containing two unused stubs, but it does not.

Mockito version: v3.2.4""Nice catch! I'll review the PR! =||= Hey @mockitoguy @andreisilviudragnea, I think this PR has introduced a new bug (or a regression if you like).

The problem arises when using Deep Stubs, as every call in a deep stub counts as used stubbing, but if you end up stubbing that mock for real this change will change the state of the original stubbing and your test will fail with an `UnnecessaryStubbingException`

The following example is in Scala, I don't have a running Java project at hand, but I can provide a 100% Java example if this is not enough to explain the problem

```scala
  class Foo {
    def userClass: Bar = {...}
  }
  class Bar {
    def callMeMaybe: Baz = {...}
  }
  class Baz {
    def callMe: Option[String] = {...}
  }

val aFoo = mock[Foo](DefaultAnswers.ReturnsDeepStubs)
aFoo.userClass.callMeMaybe.callMe returns Some(""my number"")
aFoo.userClass.callMeMaybe.callMe.value shouldBe ""my number""
```

That code will fail as there are 2 stubbings for `callMe`, one automatically created by the deep stub (see `ReturnsDeepStubs.class` line 67) and one for the actual stubbing I'm making to return `Some(""my number"")`.
 =||= This also breaks tests that needs to legitimately stub the same invocation multiple times. Particularly with invocations that have to arguments (since all invocations will match a previous stub). See https://github.com/mockito/mockito/commit/ce1632ddd6c55a7e85bec606536aa582a3b3aea1#diff-90b7e8e4bd136ee96421dc2adde3a918R71.

A simple common example is when stubbing a `Clock`:
```
@Mock
private Clock clock;

@Test 
void test() {
    Instant instant1 = Instant.ofEpochMillis(...);
    Instant instant2 = instant1.plus(...);

    when(clock.instant()).thenReturn(instant1);
    // do something at instant1

    when(clock.instant()).thenReturn(instant2);
    // do something at instant2
}
``` =||= @pkoenig10 yes, although that may not be the best example as you could use a chain of `thenReturn()` and have a single stubbing.
That said, for a non-experienced user that may not be obvious at all, so we'd have to weight it. =||= It's not obvious to me how you would work around this if your code calls `clock.instant()` a large or variable number of times. I find the suggested work around to be pretty verbose and unergonomic:
```
when(clock.instant())
    .thenReturn(instant1)
    .thenReturn(instant1)
    // repeat however many times is necessary
    .thenReturn(instant2)
    .thenReturn(instant2)
    // repeat however many times is necessary
```

I think the best and simplest way to improve this behavior is to not unmark the previous stubbing if it has been used. If the stubbing has not previously been used, then I think the current behavior is appropriate. Unfortunately this does seem like it will be a simple fix since the a second stubbing causes a previous stubbing to be marked as used. =||= @pkoenig10 I fail to see how that is less verbose than multiple stubbings, but in any case, that's not the point.
I think this change should be reverted until it can be given a deeper thought. do you agree? @mockito/developers ? =||= Revert in progress: https://github.com/mockito/mockito/pull/1878 =||= "Fixed undetected unused stubbing when matching previous stubbed call"Fixes #1846
"Andrei Silviu Dragneaandreisilviudragnea12/31/19, 03:09:33 AM
1877.01878Regression: Overriding stubbing"Hi,

There seems to be a regression in 3.3.0 from 3.2.4 (published on Maven Central).
The documentation states : 
> Stubbing can be overridden: for example common stubbing can go to fixture setup but the test methods can override it. Please note that overridding stubbing is a potential code smell that points out too much stubbing

But by simply making a copy of a stub by duplicating its line (or more realistically returning a different value in the second stub), an `UnnecessaryStubbingException` is thrown :

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;

import java.io.ByteArrayInputStream;
import java.io.IOException;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class ATest {

  @Mock
  private ByteArrayInputStream stream;

  @Test
  public void duplicate() throws IOException {
    Mockito.when(stream.read(any())).thenReturn(1337);
    Mockito.when(stream.read(any())).thenReturn(1337); // duplicate line
    int value = stream.read(new byte[2048]);
    assertEquals(1337, value);
  }
}
```

```
org.mockito.exceptions.misusing.UnnecessaryStubbingException: 
Unnecessary stubbings detected.
Clean & maintainable test code requires zero unnecessary code.
There are 1 unnecessary stubbing (click to navigate to relevant line of code):
  1. -> at ATest.duplicate(ATest.java:21)
Please remove unnecessary stubbings or use 'lenient' strictness. More info: javadoc for UnnecessaryStubbingException class.
	at org.mockito.junit.jupiter.MockitoExtension.afterEach(MockitoExtension.java:181)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAfterEachCallbacks$11(TestMethodTestDescriptor.java:248)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAllAfterMethodsOrCallbacks$13(TestMethodTestDescriptor.java:268)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeAllAfterMethodsOrCallbacks$14(TestMethodTestDescriptor.java:268)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1540)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeAllAfterMethodsOrCallbacks(TestMethodTestDescriptor.java:267)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeAfterEachCallbacks(TestMethodTestDescriptor.java:247)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:143)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:115)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService.invokeAll(ForkJoinPoolHierarchicalTestExecutorService.java:115)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.ForkJoinPoolHierarchicalTestExecutorService$ExclusiveTask.compute(ForkJoinPoolHierarchicalTestExecutorService.java:171)
	at java.base/java.util.concurrent.RecursiveAction.exec(RecursiveAction.java:189)
	at java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)
	at java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1020)
	at java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1656)
	at java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1594)
	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:177)
```

 - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
 - [x] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)""Revert ""Fixed undetected unused stubbing when matching previous stubbed call""""Reverts mockito/mockito#1847

Fixes #1877 
Based on feedback in #1846"Tim van der LippeTimvdLippe02/26/20, 10:12:37 PM
1875.01890thenThrow(Class) no longer creates new instances"As of #1162, `thenThrow(Class)` no longer creates new instances for each invocation.  We had tests that were reliant on that behavior; for example:
```
	@Test
	public void thenThrow() {
		Supplier<Object> r = mock(Supplier.class);
		when(r.get()).thenThrow(RuntimeException.class);
		RuntimeException first = null;
		for (int i = 0; i < 2; i++) {
			try {
				r.get();
			} catch (RuntimeException e) {
				if (first == null) {
					first = e;
				} else {
					first.addSuppressed(e);
				}
			}
		}
		if (first != null) {
			throw first;
		}
	}
```
These tests now fail:
```
java.lang.IllegalArgumentException: Self-suppression not permitted
	at java.lang.Throwable.addSuppressed(Throwable.java:1043)
	at example.Test.thenThrow(Test.java:10)
```""Hello, I've taken a look at the issue and it is still apparent in commit 560adf377677a4a2c658a0b24e2f9c2e0b373c20. It appears to be that `thenThrow(Class)` instantiates the Throwable when it is called rather than instantiating it upon mock interaction.

### Background
To why this leads to the behaviour described in the issue is that the Throwable is passed to `thenThrow(Throwable)` which instantiates a custom Answer with `new ThrowsException(throwable)` and passes into `thenAnswer(Answer)`. This Answer, of course, stores the Throwable and throws it with every repeat mock interaction.

Before the merge, `thenThrow(Class)` used to call `thenAnswer(Answer)` directly with its own custom Answer, ThrowsExceptionClass. This Answer instantiated the Exception with each mock interaction.

### Suggested Solution
My suggestion is to introduce an Answer similar to ThrowsExceptionClass described above (or a modified version of ThrowsException) and have `thenThrow(Class)` create that and call `thenAnswer(Answer)`.

I can think of two ways to implement the suggestion. Both ways involve storing the Class\<Throwable\> and using Objenesis to instantiate the Throwable in the new Answer class, however:

1. Create the new Answer class with similar code to ThrowsException but instead of throwing the stored Throwable it uses a new instance based of the stored Class\<Throwable\>.
2. Modify ThrowsException to use a protected getter method for the Throwable. Then extend ThrowsException with the new Answer for Class\<Throwable\> which overrides the getter method to instantiate a new Throwable.

Option 1 doesn't modify existing behaviour that works but has more duplicate code. Option 2 offers less duplicate code but modifies existing behaviour that works.

I prefer option 2.
 =||= Happy to review a PR for this. We probably need to make a few iterations on the design, but agreed we can fix this issue.

However, if the necessary changes appear to be complicated, I am inclined to close this as working as intended. =||= "Fix mocks throwing same instance with throwable class"Fixes mocks throwing the same Throwable instance consecutively after specifying the mock behaviour with `doThrow(Class)` or `thenThrow(Class)`.

This is achieved by moving the instantiation of the Throwable into a new Answer called ThrowsExceptionClass - much like ThrowsException. Then `thenThrow(Class)` calls `thenAnswer(Answer)` with a new instance of ThrowsExceptionClass rather than `thenThrow(Throwable)`. Similar for `doThrow(Class)`, `doThrow(Throwable)` and `doAnswer(Answer)`.

Fixes #1875 

@TimvdLippe Just have a quick inquiry: The test in UninstantiableThrowableTest is failing because it expects an InstantiationError to be thrown in the middle of stubbing (check PR #1549). The new code doesn't instantiate in the middle of stubbing anymore. How do I ignore the test? Or do I just delete the test file? I'm used to using an annotation to ignore tests. The PR should be ready after that's sorted and any other suggested changes."dean-burdaky03/21/20, 02:37:30 PM
1891.01892Build is not reproducible"Repeated subsequent builds of the project create outputs which are not byte-for-byte identical, and so cannot be reproduced locally (see: [Reproducible Builds](https://reproducible-builds.org/))

This is due to:
 * File modification timestamps in JARs.
 * Non-deterministic file ordering in JARs.
 * OSGi bundle embedding timestamps in JAR manifests.

Given the build environment under which a version was created, I would like to be able to compare the checksums published on Bintray and/or Maven Central with a locally built version against the same environment, to assure myself that the artifact being pulled has actually been generated from this source code.

(I have a PR to address this which I am happy to raise)
"Feel free to open a PR and we can take a look 😄  =||= Make JARs build reproducibly"Fixes #1891 

## Overview

This PR makes the java bytecode generated by this project [reproducible](https://reproducible-builds.org/). This means that under identical builds condition (for example Java version), repeated builds should provide the same output byte-for-byte.

It achieves this by:

* using Gradle's [reproducible archives](https://docs.gradle.org/current/userguide/working_with_files.html#sec:reproducible_archives) functionality to fix timestamps and file ordering within JARs
* re-archiving JARs that are non-deterministic because they contain timestamps in their Manifests

Motivation for this change is best explained on the previously linked Reproducible Builds page.

## Confirming the change

```shell
#!/bin/bash -e

rm -f checksums*

./gradlew clean build -x test --parallel

find . -name '*.jar' \
    | grep '/build/libs/' \
    | sort \
    | xargs sha256sum > checksums-1.txt

./gradlew clean build -x test --parallel

find . -name '*.jar' \
    | grep '/build/libs/' \
    | sort \
    | xargs sha256sum > checksums-2.txt

diff checksums-1.txt checksums-2.txt
```

The diff should be empty, that is to say, both independent runs of the build should have generated byte-for-byte identical outputs, with the exception of the JavaDocs jars

## Omitting Javadocs

Despite Gradle allegedly supporting `noTimestamp` through [StandardJavadocDocletOptions](https://docs.gradle.org/5.3/javadoc/org/gradle/external/javadoc/StandardJavadocDocletOptions.html), I was unable to actually get this to work and remove the timestamped build comment in the javadoc. 

I'll happily fold this into the PR if I (or someone else) can get it to work.

---

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_"Alex Wilsonmrwilson03/24/20, 02:00:37 PM
1905.01914ArgumentMatchers.matches not working"* Ver. mockito-core:3.3.3
* Java Pattern and java Matcher

```java
Pattern pat = Pattern.compile(""^zman-server-"");
Matcher mat = pat.matcher(""zman-server-store.properties"");
mat.find() // return true
```

* Mockito matcher not wrking:

```
when(streamer.load( matches(pat))).thenReturn(stream);

Output:
- this invocation of 'load' method:
    streamer.load(
    ""zman-server-store.properties""
);
 - has following stubbing(s) with different arguments:
    1. streamer.load("""");

```""Hello,

I've taken a look at the issue and after doing some digging I found that `matches(Pattern)` uses [`java.util.regex.Matchers.matches()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Matcher.html#matches()) in `org.mockito.internal.matchers.Matches.matches(Object)` which requires the entire region to match, not just some sub-region like [`Matchers.find()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Matcher.html#find()) does. This means that your matcher fail when testing to see if your answer, `thenReturn(stream)`, is suitable for the mock's `load(...)` invocation.

I'll probably make a PR with the solution, appropriate acceptance testing and any needed documentation changes.

 =||= Thx, that explain a lot. =||= "Fix Pattern matcher not matching to subregion"Issue #1905 talked about a particular pattern using Java's Pattern class that causes Mockito to not properly match the argument (provided with an invocation) to the expected answer.

It was later discovered that the Pattern matcher matches to the entire region, not some subregion, by using Java's `Matcher.match()` (see [comment](https://github.com/mockito/mockito/issues/1905#issuecomment-615295546) in #1905). This commit fixes that by using `Matcher.find()`.

Fixes #1905"dean-burdaky04/20/20, 03:44:31 PM
1898.01942RETURNS_DEEP_STUBS override a mock's toString to `null`"This example describes the issue:

```
  @Test
  public void mocksWithDeepStubsReturnNameOnToString() {
    Object proudMock = Mockito.mock(
        Object.class,
        Mockito.withSettings()
            .name(""I'm a mock!"")
            .defaultAnswer(Mockito.RETURNS_DEEP_STUBS));

    // fails, toString() returns null
    assertThat(proudMock.toString()).isEqualTo(""I'm a mock!"");
  }
```

I'm experiencing this on 2.26.0, (looking at [ReturnsDeepStubs](https://github.com/mockito/mockito/blame/release/3.x/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java) looks like it hasn't changed much since then).

I think toString should still return the mock's name, right now it returns a `null`."Fixes #1898 : Return mock name from toString method for deep stub mocks"Return mock name from toString for deep stub mocks. It was previously returning null.

Fixes #1898"akluball05/31/20, 12:33:50 PM
1923.01948[build] bump gradle to latest 5.x release"Problem

Gradle is out date which results in us not having bugs fixed, new
features, or performance improvements

Solution

Upgrade gradle to the latest 5.x (current major version we use). Also
switch from `-bin` to `-all` which mildly increases distribution size
but makes it much easier to debug or diagnose issues. This has no impact
to end users.

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_
"Update gradle 6"This included a couple of breaking changes:
- The build plugin is now part of the Gradle Enterprise plugin
- The osgi plugin was removed, for which we have to use the bndtools
plugin instead
- Kotlin version has to be updated, including their coroutine
library versions

Gradle 6 is required for us to build on Java 14.

Supersedes and closes #1923"Tim van der LippeTimvdLippe06/16/20, 01:20:07 PM
1013.01955Enable mocking static methods in Mockito"# Static methods mocking with Mockito

This is a placeholder ticket for enabling mocking static methods in Mockito. Example action items that are totally negotiable and can ran in parallel. We're looking for someone who can lead this effort.

- [x] Research + discuss whether it is a good idea to enable static methods mocking in Mockito. The theory is that it is useful for legacy code, which is most code in the world.
- [x] Research on how other mocking frameworks do that and whether it is considered useful feature for their users.
- [x] Design and present for discussion an API for static mocking (slightly relevant ticket: #643)
- [x] Work with @raphw / ByteBuddy to come up with hacky prototype (the hackier, the better!)
- [x] Mold the prototype with the API, remove enough rough edges so that the feature is good enough for incubating rollout
- [x] SHIP IT!""I am torn on this one. If we provide this possibility, we might invite developers into bad practices. Every time a developer uses this feature, it should be very explicit that it is bad practice imo. Would it be possible to come up with a solution that is clear on this front, but still allows the developer to opt-in? =||= Great feedback. That's the first thing to figure out when working on this ticket :) =||= the way I saw mocking of static methods for myself was to only mock calls to static methods that happen within a mock. This would be useful, for example, for implementing spies in a situation like:

```java
class Foo {
  String bar() { return Util.makeString(); }
}
```
With Mockito, I would like to see something like:
```java
Foo foo = spy(new Foo());
doReturn(""foo"").when(foo).invokesStatic(Util.class).makeString();
assertThat(foo.bar()).isEqualTo(""foo"");
```

What do you think? As for a hack, I am missing a component in Byte Buddy which I was supposed to write for a customer at some point what did however not pull through. I am not currently in a position to spend so much time to build this component, due to my personal situation, but please prototype away. I think the API and spec work is crucial to make this a success. =||= Great feedback! Thank you Rafael for sharing your thoughts.

Is the component you mentioned a lot of work in ByteBuddy? Is this something that we can ask the community to help out or you're the best person to take on?

I'd rather see more robust API but your API idea is certainly workable. Mocking statics should be rare and our API should be optimized for common use cases and not edge/rare cases. We can always iterate based on feedback :)

Here's my preference as of today:

```java
//setup
mockStatic(Util.class);

//then
doAnswer().when(() -> Util.foo());
when(Util.foo()).thenReturn(""foo"");
verify(() -> Util.foo());
verify(never(), () -> Util.foo());
```

If we choose to support mocking static methods, I'd rather offer API that is robust enough to support all kinds of use cases. I like when tools are separated from policies and are opinionated but not dogmatic :) If we think that mocking static is disgusting, we can ship it in a different jar called ""mockito-for-crappy-code"", loosely following @TimvdLippe idea.

The main use cases for mocking statics I see are:
 - legacy code (I really, really want to write a unit test but I don't dare to change some ancient ugly code)
 - dealing with some awkward static 3rd party APIs. This scenario is currently workable by developing some injectable API layer on top of 3rd party statics. However, the workaround could be cumbersome and can spoil the clarity of codebase.

Without addressing above 2 use cases, developers around the world will be looking for help in tools like Powermockito, and such.

The biggest downside of offering static mocking is making it too easy to test crappy, procedural code full of static methods. We would remove a motivation to refactor the code into clean OO / DI.

 =||= Should we also send out a Tweet to gather some community insights? =||= If this feature uses the Java Instrumentation API, it will not work on Android devices, so it might confuse Android developers.
If so, I think it should not be integrated into the `mockito-core` artifact. =||= I came across this issue by chance (I was just curious to know what you were planning for Mockito 3), but I'd like to share my experiences of working with static method mocking.

I used to work on several large codebases that made extensive use of static methods and used PowerMock (and PowerMockito) heavily for testing. My main memories of that time were that the tests were really slow to run (in some cases tests that use PowerMock were literally ten times slower than those that didn't) and that we ultimately had to remove all usages of PowerMock because it wasn't compatible with newer versions of Java. I also recall there being incompatibilities with some libraries were using that required special setup in the tests to make them pass, although I no longer remember the details of that.

I can understand concerns about promoting bad code, but as a Mockito user I'd be more worried about the impact on performance and robustness. Not all of the code we were using PowerMock for was legacy. Some of it was new code written by an inexperienced team (of which I was part of) and knowing that Mockito devs disapproved of our design patterns probably wouldn't have made any difference.

This was a few years ago now and techniques for mocking static methods may have improved significantly since then. If you think there's a performant and robust way to implement this feature then I'd welcome it (even though I'd hope I never have to use it). =||= Really good feedback, thank you guys. I helps us make good decisions about the features/API we plan. =||= In my opinion in general testing static methods is a bad idea and it would be better to refactor the code, however, sometimes it's something that is needed. For instance, testing a default method `given()` in [mockito-java8 interface](https://github.com/szpak/mockito-java8/blob/master/src/main/java/info/solidsoft/mockito/java8/api/WithBDDMockito.java#L68) delegating to a static method in `BDDMockito.given()` the easiest solution I see is to generate in runtime a list of static methods in `BDDMockito` and execute parameterized test for every of them verifying that a corresponding method in `WithBDDMockito` interface delegates to it with proper parameters. In that case static method mocking would be beneficial. Maybe I will wait for PowerMockito for Mockito v2 to test Mockito itself...

Alternatively I would need to play with AOP and load-time weaving, code generation in runtime or some other not very pleasant to use technique (unless you have some good ideas how to do it easier). =||= @szpak, thank you for the feedback! Interesting use case.

I think we all agree that mocking statics is a bad practice and an anti-pattern in general. The question is whether we enforce the ""no mocking statics"" policy (e.g. not offer the feature in the tool) or let the user decide to enforce it or not (e.g. offer the feature). =||= Please, consider the legacy code issue. Sometimes you don't have any choice. 
Enforcing or not a practice shouldn't be the decision of a framework but of the team.
Also, for now, we're using Powermock as a workaround for this need but it's not compliant with the last versions of Mockito. We're blocked with 1.9.x version of Mockito.
It's another good reason to get this feature: Limit dependencies.

We already need all these libraries to get decent unit test in pure Java world:
JUnit,
JUnitParams as Junit Parametrized are awfull
AssertJ for expressive and clear assertions
Mockito ... and Powermock

and i shouldn't mention other peripheral libraries:
DBUnit,
SpringDBunit
JBehave, JGiven for BDD style .... 

Then you can write all your testing stuf in Groovy and you only need ... Spock


Please! Let user choose. Othewise, why did you provide private method mocking in the recent versions athough it's considered as a ""bad"" practice for TDD purists ? 

Finally, thanks for your great work. Mockito is really a nice framework  =||= Mocking static methods is a different use case, maybe that means it should be a different tool. 

Answer the following questions (to yourself):
- Do you want to support a double tool in the long term? 
- Does it use the same set of dependencies and only those? 
- Does mocking static methods fall nicely into the current design?

If you answer all 3 with ""Yes"", then go ahead. If at least one is a ""No"" consider the alternatives:
- Build a Mockito extension
- Build a new tool and call it Mackarita
- Leave the other tool to someone else

Just my two cents. =||= I agree with most of you and think that mocking static methods is not a good idea.
If some method uses static method provided by legacy library/framework, then it can be easily wrapped in object and provided as mockable dependency. It's not perfect solution, but is educational - shows developers that writing too complex static util methods hurts and makes code hard to test. If Mockito had such feature, many of developers would consider it as acceptable practise and produce bad code.
Another issue is parallel tests execution. In my current project we used to use PowerMockito to mock static methods and after some time our tests started to fail because of concurrency issues:
1. Thread A mocked static method X.y and stopped.
2. Thread B mocked static method X.y and stopped.
3. Thread A was awaken and run test - it failed because thread B overwritten static method's behaviour expected in test run by A.

We ended up with wrapping static methods in injectable objects and removed PowerMockito from project dependencies. =||= I had asked about this at some point in the past and was told it was being considered. Glad to see that's actually happening.

In my opinion, support for mocking static methods is a good idea for the simple reason that the standard Java classes that ship with the JRE have tons of static methods. Consider the NIO.2 API as an example. If you want to read a file using that API, you might do something like:
```java
Files.readAllLines(Paths.get(""myfile""));
```

Now, is there a way to test this without mocking static methods? Obviously yes; you could make a IFiles interface and then make a JREFilesImpl that passes the calls through to the static methods. But that's a bunch of extra effort, it adds complexity to your code, and obscures the methods that are actually being called. In my opinion, I shouldn't need to do that to test my code's ability to properly read some file.

So +1 for the ability to mock static methods. =||= > Now, is there a way to test this without mocking static methods?

Well, in my opinion file name/path from your example is good candidate for passing it to method/setter/constructor instead of hardcoding it and you can just create test file in filesystem. Such Java API methods are considered as simple and reliable and there is no need to mock them like you wouldn't mock `java.util.List` if your method operated on data from given list. You would just create actual list with test data. =||= There are at least 2 problems with that argument: a) you can't test behavior when exceptions occur, and b) you can't test behavior if the path is for a different OS. I realize the latter is an esoteric use case, but I actually am working on a project that is developed on Windows but runs exclusively on Linux. =||= I think the recurring theme right now is: either you are pro or you are strictly against it. Personally, I am for clean tests and therefore consider static mocking very bad practice. However, our users apparently have usecases that require (intrusive?) solutions such as PowerMock. Given that these users opt for such solutions signals that the other solution would be no tests at all, and that is probably what we would never want.

Given that solutions like PowerMock are built not only on Mockito, but also other libraries, they can not be easily updated like Mockito can. This incentives Mockito to solve static mocking, if users opt-in for it.

Even though I inherently disagree with static mocking, I think it is only fair that we as Mockito developers offer users the option to opt-in a less intrusive and upgrade-compatible solution. Therefore, I would vouch for a different artifact (probably called `mockito-legacy`), which offers static mocking. This should signal our users that this is for legacy purposes and should be strictly discouraged, but at least gives them a way out. This particular solution would tick off all points of @jlink

In the end, no matter which outcome, there will always be disappointed developers. We will not be able to find a golden solution for this particular problem and I am fairly convinced it will never happen either.

We can always try it out with the new artifact and discontinue it later if it is significantly misused.

One sidenote: putting everything in a new artifact would scatter the mockito ecosystem. We should probably find a better solution for this, potentially in Mockito 3. =||= I disagree with @TimvdLippe.  I don't believe that in an open source world you can ""try it out with the new artifact and discontinue it later if it is significantly misused."". Once it's there in the library users will require it to be there. You'll have to support that feature etc. Either it's there or not. Not often can you easily deprecate sth and roll it back afterwards. Typically it requires a couple of release cycles.

@TimvdLippe you're mentioning this "" However, our users apparently have usecases that require (intrusive?) solutions such as PowerMock"". I have a comment on that. As an exercise from time to time I'm trying to answer PowerMock questions on StackOverflow. Typically someone says that there's a static method somewhere that they're calling and it does some logic that they want to stub. The question I often ask to those people is ""Why are you doing this?"". Would you really want to stub a call to `StringUtils` ? Another frequent problem is that the design is flawed and that's why one is looking for hacks. (e.g. http://stackoverflow.com/questions/37059406/how-can-i-get-powermock-to-return-the-expected-value-from-a-static-method/37066436#37066436 , http://stackoverflow.com/questions/37052069/program-termination-during-quartz-scheduler-verification-using-power-mockito/37066521#37066521 , http://stackoverflow.com/questions/31840964/powermock-private-method-with-null-pointer-exception/37066400#37066400 or http://stackoverflow.com/questions/32195928/getting-powermockito-to-mock-a-static-method-on-an-interface/32537392#32537392)

That's why I fully agree with @karollewandowski . ""Every problem can be solved with a layer of abstraction"" ;) You can't mock a static method? Ok then, wrap it in a class which you can stub. Is it wrong? Quite the contrary. Rarely should you call static methods directly and if you do, most likely these are utils that you don't want to stub. You should encapsulate the logic of a static method in an object that makes business sense to use it.

Summing it up giving people a tool to stub static methods is making them even easier to write bad code. Instead of thinking of how to fix the design they'll be able to make the design even worse.  =||= @TimvdLippe Just one thing: If you create a new artifact like ""mockito-legacy"" communicate clearly if you're planning to support it mid/long-term or if it's just an experiment. Some people are willing to experiment together with you, others will be pissed off when you quit support after they have heavily used it. =||= @rdicroce I completely disagree with this statement:

> Now, is there a way to test this without mocking static methods? Obviously yes; you could make a IFiles interface and then make a JREFilesImpl that passes the calls through to the static methods. But that's a bunch of extra effort, it adds complexity to your code, and obscures the methods that are actually being called. In my opinion, I shouldn't need to do that to test my code's ability to properly read some file.

You're design is wrong. If you had 

```
Files.readAllLines(Paths.get(myFilePath));
```

You could via a constructor inject `myFilePath` to point to your test resources. You don't even need to create any additional classes. =||= The Android community would like mock static methods, well at least me.
Why? : The Android SDK provides many static utility methods with classes like TextUtils. The downside is that there implementation is only provided on the device or emulator. When users run Unit-Test on there local machine they will get the famous ""Method not mocked"" exception.

> The android.jar file that is used to run unit tests does not contain any actual code - that is provided by the Android system image on real devices. Instead, all methods throw exceptions (by default). This is to make sure your unit tests only test your code and do not depend on any particular behaviour of the Android platform (that you have not explicitly mocked e.g. using Mockito). 

They are many workarounds for this issue like PowerMock or Roboelectric. Roboelectric is a great testing framework but it is damn slow and maintainance intensiv. PowerMock is not stable state to be used with Mockito 2. So I think at least Android users will love this feature. 
  =||= @ChristianSchwarz I do not agree, using Android static utils or Android framework in your business logic is a bad smell. Well structured Android app do not need mocking static methods, nor Roboelectric. Calls to Android framework must be abstracted and current Mockito implementation helps to enforce that. If you want to test view layer then go with Instrumentation tests and Espresso. =||= @dbacinski, I am not an expert on Android so bear with me, please :) Adding extra layer introduces more method calls which can be problematic on large apps that hit dex method limit, right? =||= @szczepiq you are right that you need additional methods to abstract Android apis, but this is a cost of good architecture. Dex method limit is not a huge problem anymore because now there is native platform support for multidex apps. =||= @marcingrzejszczak Your response a) does not address the call to readAllLines(), and b) does not address either of the issues I raised in https://github.com/mockito/mockito/issues/1013#issuecomment-291602703

To all: it seems to me there's a fundamental divide in this thread between people who are of the opinion that it's fine to just make a wrapper class for static calls, and people who are of the opinion that wrapper classes add bloat and shouldn't be necessary. I don't see either side convincing the other, so I'm not sure where that leaves us. =||= > Your response a) does not address the call to readAllLines(), and b) does not address either of the issues I raised in #1013 (comment)

@rdicroce I haven't explicitly but the answer is simple

> a) does not address the call to readAllLines(),

If the path is a parameter you don't have to mock the call at all. You can pass 

a) a path that exists - to test the positive scenario
b) a path that doesn't exist - that way it will blow up and you'll test an exception

> . I realize the latter is an esoteric use case, but I actually am working on a project that is developed on Windows but runs exclusively on Linux.

You can write a couple of tests that are exclusively executed depending on the OS (example for Windows - http://stackoverflow.com/questions/23410738/run-unit-tests-only-on-windows ). Again, if you use parameters instead of magic values then you can do basically whatever you want.

> To all: it seems to me there's a fundamental divide in this thread between people who are of the opinion that it's fine to just make a wrapper class for static calls, and people who are of the opinion that wrapper classes add bloat and shouldn't be necessary. I don't see either side convincing the other, so I'm not sure where that leaves us.

I'd say that the divide is between people who want to design their code properly and those who want to take the path of least resistance (which isn't a wrong choice sometimes).
 =||= >I'd say that the divide is between people who want to design their code properly and those who want to take the path of least resistance.

Static members aren't something good, I hope it's quite obvious. But Java has them and will support them, whether we like it or not. So I'd say that educating and influencing is good, forcing might be not. It's like ""oooh, your code is using statics, so it can't be tested with Mockito"".
(Not to mention that some people would like to have nice unclebobish tests but aren't allowed to refactor the code they have to maintain. I know it's sick, but hey, this is reality sometimes.) =||= @marcingrzejszczak 

> If the path is a parameter you don't have to mock the call at all. You can pass
>
> a) a path that exists - to test the positive scenario
> b) a path that doesn't exist - that way it will blow up and you'll test an exception

That may solve this particular case. What about other static APIs that can throw a variety of different exceptions? Are you saying users should go through the hassle of setting up every possible scenario? What happens if there are scenarios the user can't set up? You may as well not bother with a mocking framework at all in that case.

> You can write a couple of tests that are exclusively executed depending on the OS (example for Windows - http://stackoverflow.com/questions/23410738/run-unit-tests-only-on-windows ). Again, if you use parameters instead of magic values then you can do basically whatever you want.

This makes it impossible to run the tests in the environment where the code is developed. Again, I know this is an esoteric use case, but it is a valid one IMO.

> I'd say that the divide is between people who want to design their code properly and those who want to take the path of least resistance.

I won't speak for anyone else in favor of mocking static methods, but I don't see that as designing code improperly. Adding a whole extra layer of abstraction that's completely unnecessary outside of testing? That does strike me as being improper. =||= This will be my last answer cause obviously we are not going anywhere with this.

@pioorg

> Static members aren't something good, I hope it's quite obvious. But Java has them and will support them, whether we like it or not...

Yes it's obvious. Someone has to afterwards maintain that code. Both the business and the library. Another thing is that you don't have to mock all of those calls. Why would you stub a `StringUtils` class ? Makes absolutely no sense. 

@rdicroce

>  Are you saying users should go through the hassle of setting up every possible scenario? What happens if there are scenarios the user can't set up...

Of course not. You can catch a generic exception and that's enough. 

> This makes it impossible to run the tests in the environment where the code is developed

That's false. Some of your tests will be executed only on Windows. Some others on Linux etc. 

> I won't speak for anyone else in favor of mocking static methods, but I don't see that as designing code improperly

That's why I would just call the static method. If in your static method you have a lot of complex logic then it should get wrapped.

All in all - I think that this is a wrong decision for Mockito. But that's only my opinion. =||= > Yes it's obvious. Someone has to afterwards maintain that code. Both the business and the library. Another thing is that you don't have to mock all of those calls. Why would you stub a StringUtils class ? Makes absolutely no sense.

With all the respect, I don't care about any *Utils classes or any other particular code snippets.
What I mean is that:

1. statics are valid from syntax PoV
2. they already exist in legacy code 
3. some folks can't change that code ""only because we'd like to have Mockito in tests""

So if one can't change the code, refactor it and add the wrappers around the static calls, they also can't use Mockito because ""Mockito doesn't support statics"". To me it comes to ""bad code -> bad tests"". Sorry ;-)
While I perfectly understand there are reasons not to include it in ""standard"" distribution artefact, having another one being mockito-extension-for-ppl-who-dont-have-nice-code.jar might be acceptable.
 =||= Just some toughts about  the prevailing opinion ""statics methods are evil"". 
From my experience there are 2 different kinds of static methods ""good"" and ""evil"", i wouldn't say that all static methods are evil.

 * Static methods are ""evil""  when they alter the state of a of a static member or in other words they depend on a state. When such a method is called the result may be an other when called in the future with the same input.
E.g:
```java
 class LogManager {
     static LoggerPlugin plugin = ...
     static void logInfo(String message){
        plugin.write(INFO,message);
     }
 }
```
 When the LoggerPlugin changes during runtime the result may be different, e.g logged to a different media.

 *  Static methods are also ""evil"" when they call a static method that is ""evil"" as described above, cause they inherit the nasty side effects.
E.g:
```java
 class Log{
  static void info(String message){
      LoggerMananger.logInfo(message); 
  }
 }
```


 * Static methods are are ""good"" when they don't depend on a state / access a static member and thus have the same result on every call.
E.g:  `Math.max(int,int) `


In the java eco system exists both evil and good static methods. I don't see a much points to mock ""good"" static methods. It makes only sense when they do quite complex stuff and you don't want to mock all bits of there input to satisfy there implementation. Even in famous frameworks we are faced with ""evil"" static methods (hello `Singleton.getInstance()`). To handle these evil cases mockito can do it's part and support the poor devs among us who have to deal with it. I wouldn't blame mockito if devs start to introduce the ""evil's""  to there code base. Mockito is a mocking framework, not a good style enforcement tool, thats the task for the team and/or lead developer.



 =||= @ChristianSchwarz 
> Static methods are are ""good"" when they don't depend on a state / access a static member and thus have the same result on every call.

True, there are even some schools in which all private methods should be static, don't depend on anything apart arguments, don't change the state of any object and don't do anything beside computing the result. So they're functions, just like sin(angle) is: the angle isn't changed, and sin is only the result of the angle, always the same (provided the geometry is always the same ;-) )
I find this functional style of programming very good, but in fact it has rather not much to do with statics as such. IMHO sometimes it's better to tell newbies ""don't use statics, 'couse they're generally bad""... It's a kind of ""lie for children"". =||= Unfortunately as history has shown multiple times, when developers see a tool and its use cases, they do not always understand the impact and weight of its features. They consider all features equal and do not understand that some of them should only be used as a last resort.

The canonical example in the Java world is the abuse of Java introspection/reflection and AOP for even trivial scenarios. Even outside the Java world we see the misuse of advanced features by developers who use them ""simply because they are there"". 

If we are to go forward with this (and I am strongly against this, as I considered a major advantage of Mockito the fact that it did not allow testing of static methods) I would suggest the following:

- Create a ""mockito-legacy"" artifact/extension/add-on 
- Require a configuration file option for Mockito to actually enable this add-on
- Print in the log file when the test runs a huge warning (similar to what Maven does when you don't define a version) that using this add-on is an anti-pattern and a code-smell
- Provide a link to the user that has a page with common refactoring scenarios that show how we can get rid of static methods.

Maybe I am missing something, but I really would like some examples on how legacy code cannot be refactored to remove the static dependency. Unless of course you cannot change the code at all, which for me makes the creation of unit tests questionable (because if a unit test fails what are you going to do then?) =||= @kkapelon: I also wish all Java code was pure OO design and that everyone actually knows what that means ;-) I hope such a huge warning ""you're doing it wrong"" could educate and maybe convert a few folks.

> Maybe I am missing something, but I really would like some examples on how legacy code cannot be refactored to remove the static dependency.

It's not about the code itself. I've seen big name companies enforcing policies in which before bugfixing, the case has to be replicated in tests. (Kinda TDD, they claim sometimes.) Then, once the test fails just like the ticket describes, the support team is allowed to change the code to make it pass (and sadly, usually minimum changes). It's rather difficult to make a test to cover statics if your testing tool set doesn't allow that. Chicken and egg problem.

It's like all these The Daily WTF stories in which ""don't change it, it ain't broke, 'couse it works!"", so the code is like Java 1.4...
 =||= This would be great! We could finally stop bikeshedding ""static is *eeevil*"" because not testable. =||= > We could finally stop bikeshedding ""static is eeevil"" because not testable.

Well, IMHO static is eeevil in many cases not only because not testable :-D =||= The mocking framework shouldn't restrict the design options - it's just not the job of a mocking framework! I've seen a lot of code polluted with mocking-only interfaces. And there are a lot of cases where a simple static method is a perfect design decision. `final` is also rarely used, because mocking frameworks (besides the great [JMockit](http://jmockit.org/)) have trouble with it. =||= DONT DO IT!  PowerMockito exists for those cases where you absolutely need to mock static methods.  Right now Mockito conforms to the commonly held opinion that static is for methods that are testable without mocks (think: StringUtils).  Static for other stuff should be discouraged (there are exceptions, obviously) - in those situations, encapsulating the static calls in a protected @VisibleForTesting method should suffice for unit testing and for those other ""legacy or not"" situations, there's always PowerMockito.   =||= @trumpetx I just wanted to note that the reason we are investigating this change is that some companies are in the legacy code situation, where adopting PowerMockito would be too disruptive. Therefore, these companies would be unable to test their classes. Even if they could adopt PowerMockito, the tests become significantly more difficult to understand, just to be able to test their legacy code.

The question is: should we as Mockito give the opt-in for these situations, as other options are too invasive? I think every Mockito core developer agrees that static mocking is bad and should not be done, but sadly we can not dictate what the industry does or has to deal with.

Just wanted to give perspective on why we are opening this issue. =||= @TimvdLippe , I can't see how Powermockito would be disruptive for tests (certainly no more disruptive than adding MockitoStaticWhatever.)

Additionally, too difficult to understand?  Seriously?  If someone has static mocks in their tests, and they're too difficult to understand, they probably need to find a new career.  I'm not saying this to be mean spirited or whatnot, but it sounds like you're just making reasons to adopt this change. =||= Also for reference, I cross-posted this issue on Reddit and there some other arguments/viewpoints posted there: https://www.reddit.com/r/java/comments/64pdk1/mockito_discussion_on_introduction_of_mocking/ =||= @TimvdLippe 
Thanks for your link. The recent posts have led me to another...
http://mvnrepository.com/artifact/org.powermock/powermock-api-mockito/usages
I'm just wondering why so many of them... =||= I haven't had experience with ByteBuddy but I'd be willing to give it a shot. As far as names, how do we feel about `mockito-gore` to really indicate you need a strong reason to use this jar? =||= Just a few more words from me, maybe last ones ;-)
There's a method in Mockito:
`org.mockito.Matchers#isNull(java.lang.Class<T>)`
Isn't NULL considered to be ""The Billion Dollar Mistake""? Shouldn't the programmers all around the world be educated that passing a null reference (instead of a `java.util.Optional`) is a very bad practice?
Maybe this `isNull` method should be deprecated and eventually removed in future versions?

I've seen a lot of code being polluted by `if (reference == null)` and `catch (NullPointerException e)`... More than by ""incorrect use of statics"". (But YMMV.)
If supporting statics is going to create such bad habits among programmers AND Mockito is meant to be a forced education, then I guess support for NULLs should be removed in future versions and people should write wrappers to handle NULLs from their legacy code, as NULL is worse habit IMHO. ;-)

Unless Mockito is meant to be a testing/mocking framework, not forced education course.
Thank you. =||= I would like to add some comments from my own experience. I completely understand the people that are saying to add an abstraction to the static methods that you are invoking. However, in a legacy code that is expensive and requires a lot of effort. 

Additionally, there are frameworks like [GWT](http://www.gwtproject.org/) that support polymorphism, but not like you would think. One needs to call a static method that will do the creation of the object on runtime and runtime there is Javascript. There ware ways that you can write tests that will emulated the client code for GWT, but they are really slow. Currently, we use PowerMockito with Mockito 1.9.5, because we can't update to a later Mockito. However, if Mockito had this support it would be much easier to do the testing. =||= This discussion has been very active and helpful, thank you everyone for participating!

I think we have sufficient background information to make a final decision @mockito/core Shall we discuss this on Slack and write a wiki page on our full analysis and final verdict? Then we can inform the community for a final review (of a potential implementation) and round up this feature. =||= > Shall we discuss this on Slack and write a wiki page on our full analysis and final verdict? Then we can inform the community for a final review (of a potential implementation) and round up this feature.

Has the verdict on static support been reached?

 =||= We have not. Every single core member has been swamped with various IRL activities. Probably this fall we will be back in full force. This is one of the features that we will be addressing :smile:  =||= The team was not actively working on this. The ticket is marked ""please contribute"" for a reason ;) Currently I work with @thekingnothing on creating Mockito APIs so that Powermock can cleanly integrate (#1110) this will effectively provide reasonable support for static mocking. 

Hope this clarifies the status! Thank you for reminder - this is useful for us to manage our priorities. =||= Static methods are totally OK. You just have to know when to use them.

I think the following code is entirely correct and sufficiently abstracted for the purpose of a modern-day application:

    // guava imports
    class ApplicationResources {
      // points to a file in the .war
      private static final CharSource DEFAULT_CONFIG_SOURCE = Resources.asCharSource(Resources.get(""etc/default.config""), UTF_8);
      static CharSource defaultConfigSource() {
        return DEFAULT_CONFIG_SOURCE;
      }
    }

I need to access a static value in my application. But for the purpose of proper testing, I need to test various default values, so it makes sense to provide another `CharSource` during the tests than at runtime.

Just imagine that this is embedded in some JEE application. There is no sense in writing this method as non-static. I could write `new ApplicationResources().defaultConfigSource()`. What is that code? Is it real? Others might imagine I make this class a (singleton) bean. A bean requires the class to be public. I don't want any of its method to be accessed outside of the package, so there are no reasons to make this class public, so this class has no reasons to be a bean.

However I still have to test classes that use this class. But I'm stuck in the testing because I just can't mock its methods (besides using all the workarounds mentioned above).

I agree that mocking static method should be used very, very rarely, but it should exist for those rare cases. =||= Personally, I plan to add this feature. I still need to do some ground work in Byte Buddy to make this feasible. It is not as easy as I hoped, unfortunately and it might take some time. The same goes for the seamless integration with PowerMock.

If anybody would be willing to sponsor the development, I am happy to use paid hours, within my open source commitment, this might take a few more month to complete but I am certain to finish this at some point. Java 9 compatibility takes priority at the moment. =||= **tl;dr:** mocking static methods can be implemented mostly like regular mocking with [a few quirks when spying on static methods with side-effects](https://github.com/moltmann/dexmaker/wiki/Experiments-with-mocking-static-methods-via-mockito#spying-and-doreturn).

I implemented a [prototype](https://github.com/linkedin/dexmaker/compare/master...moltmann:staticMock) of this for the dexmaker based mocking used on Android. Examples and tests can be found in [MockStatic.java in the diff](https://github.com/linkedin/dexmaker/compare/master...moltmann:staticMock#diff-923767ff4d088765b531f9151e31b1c3R127).

I summarized my observations on a [wiki page](https://github.com/moltmann/dexmaker/wiki/Experiments-with-mocking-static-methods-via-mockito). =||= I think I found a [nicer version for mocking static methods via `doReturn().when()`](https://github.com/moltmann/dexmaker/wiki/Experiments-with-mocking-static-methods-via-mockito#create-temporary-object-just-for-calling-static-methods). So the total interface for static methods could be designed as:

    try (StaticMockingInProgress<MyClass> token = spyStatic(MyClass.class)) {
        when(MyClass.aStaticMethod()).thenReturn(“mockedValue”);
        assertEquals(“mockedValue”, MyClass.aStaticMethod());
        
        doReturn(“fakeValue”).whenStatic(MyClass.class).anotherStaticMethod();
        assertEquals(“fakeValue”, MyClass.anotherStaticMethod());
    }
    
    assertEquals(“originalValue”, MyClass.aStaticMethod());
    assertEquals(“originalValue”, MyClass.anotherStaticMethod());

In Summary we could limit the necessary changed to:
- `mockStatic`/`spyStatic` instead of `mock`/`spy`. This is required as `mockStatic`/`spyStatic` needs to return a token to define the scope of the mocking instead of a mocked object
- `doReturn(...).whenStatic(Class)` instead of `doReturn(...).when(Object)`. This is necessary as when mocking a static method, there is no mocked object =||= Addendum to previous comment. I think we should also have a `resetStatic(Class<T> class)` method. Then using the StaticMockingInProgress object becomes optional but recommended. =||= Hey @moltmann, thank you for taking a stab at the prototype!

Given that we provide an API for mocking statics in mockito-core, will you be able to come up with the implementation in dexmaker? 

Can you implement static mocking in dexmaker right now, with current version of mockito-core API? For example, can you add ```MockitoStatic``` class to dexmaker and offer static mocking to dexmaker users? If not, what are the problems with mockito-core API that block you. =||= I am trying to sum up all discussion I had and what I learnt from this thread.

I updated my prototype at https://github.com/moltmann/dexmaker/tree/staticMock using 
- whenStatic 
- explicit finishStaticMocking

# Stubbing

How does ""when"" work for static methods?

## when(λambda)

### Suggested APIs

```
when(() -> MyClass.myMethod()).thenReturn(""mocked return value"");

doReturn(""mocked return value"").when(() -> MyClass.myMethod());

verify(() -> MyClass.myMethod());
```

### Problems

#### Not clear what method is called

If the lambda calls two methods, e.g.:

```
doReturn(""mocked return value"").when(() -> MyClass.firstMethod().secondMethod());
```

or 

```
doReturn(""mocked return value"").when(() -> {
    Object o = MyClass.firstMethod();
    return o.secondMethod()
});
```

Which method should we set up mocking for? `MyClass#firstMethod()` or `?#secondMethod()`.

- We need to make sure the return type matches the parameter of doReturn. We only know the return type of the the lambda, i.e. the return value of secondMethod. Hence we have to set up mocking for the second method.
  We don't set up mocking for `MyClass.firstMethod()`. What should `MyClass.firstMethod()` do? Call the real method? Return null? To make the code above work `MyClass.firstMethod()` has to call the real method. But this might have side effects. The point of the `doReturn(...).when(...)` syntax is to avoid side-effects.
- The second method is most likely an instance (non static) method. Should we allow setup for instance methods using the when-with-lambda?

I think we need to enforce only a single mocked method call on a mock in the lambda. Hence we have to listen to all possible methods calls, and intercept them. Once a second one or one of the wrong return type is intercepted we need to throw an exception. Hence above examples will throw an exception.

##### Possible extension

One possible extension would be do declare a restriction on what to intercept like

```
doReturn(""mocked return value"").when(MyOtherClass.class, () -> {
    MyOtherClass o = MyClass.firstMethod();
    return o.secondMethod()
});
```

Which declares that we want to set up mocking for `MyOtherClass`, not `MyClass`.

#### Conflict between old and new doReturn-when

```
doReturn(() -> ""A"").when(() -> MyClass.firstMethod());
```

In above case Mockito needs to decide if this is the new setup method or an incomplete version of 

```
Supplier<String> m = mock(Supplier.class);

doReturn(() -> ""A"").when(m).get();
```

it can do this by checking if the parameter to m is a mock during runtime, but the when(λambda) API needs to support both cases, hence when(λambda) has to return a lambda type, i.e.

```
LambdaStubber<Supplier<T>> doReturn(Supplier<T> ret) {
    return new LambdaStubber<Supplier<T>>(ret);
}

public static class LambdaStubber<T> implements Stubber {
    Supplier<T> when(Supplier<T>) {
        ....
    }
}
```

##### Possible extension

This issue might be mitigated by introducing

```
doReturn(() -> ""A"").whenStatic(() -> MyClass.firstMethod());
```

## `T whenStatic(Class<T>)`

```
doReturn(""mocked return value"").whenStatic(MyClass.class).myStaticMethod();

verifyStatic(MyClass.class).myStaticMethod();
```

`doReturn(...).whenStatic(MyClass.class)` returns a mock instance of `MyClass` with all instance methods throwing a stubbing exception. So the user will not accidentally call a instance method on this special stubbing-mock.

### Problems

`doReturn(...).whenStatic(MyClass.class)` returns a mock instance of `MyClass`. Hence calling `doReturn(...).whenStatic(MyClass.class).myStaticMethod()` is equivalent to

```
MyClass m = mock(Myclass.class);
m.myStaticMethod();
```

While it is valid Java to call static methods on instances, all IDE code checkers, linters and tools like errorprone will light up like a christmas tree and tell you not to do it.

# Life-time of static mocking

Regular instance mocking is tied to an object's lifetime. Static methods do not have such a life-time, hence when to know when to reset the methods and stop collecting invocations.

## `mockStatic(Class)` -> `finishStaticMocking(Class)`

This is the most basic solution. The advantage is that this works with every possible test-framework and if someone wants to have a nicer API they can e.g. build a `AutoClosable` that automatically calls `finishStaticMocking(...)` when a try-with-resources block is exited.

## MockitoSessions

As far as I understood there can only be one session at a time. Hence scenarios with interleaved life-cycles of static mocking can not be supported. Example:

```
mockStatic(A.class)
mockStatic(B.class)

when(A.m()).thenReturn(""mockA"")
when(B.m()).thenReturn(""mockB"")

assertEquals(""mockA"", A.m());

finishStaticMocking(A.class)

assertEquals(""mockB"", B.m());

finishStaticMocking(A.class)
```

Of course if the user wants to use sessions (or other session like tools, such as the Mockito JUnit runner) they should apply to static mocking too. =||= I implemented the recommendation of https://github.com/mockito/mockito/issues/1013#issuecomment-291045005 in :
- Code: https://github.com/moltmann/dexmaker/tree/staticMock
- JavaDoc: https://moltmann.github.io/dexmaker/com/android/dx/mockito/inline/extended/package-summary.html
- Example: https://github.com/moltmann/dexmaker/blob/staticMock/dexmaker-mockito-inline-extended-tests/src/androidTest/java/com/android/dx/mockito/inline/extended/tests/MockStatic.java#L76

It mostly works even though some parts of the implementation use nasty reflection. =||= @moltmann Could you please open PR for your changes?  =||= @avanathan My code is currently based on [dexmaker-mockito](https://github.com/linkedin/dexmaker) and does not work with the bytebuddy mock maker used by vanilla Mockito. I think we should first agree on the interface before trying to make this work with bytebuddy. =||= @moltmann, thank you for working on this! I plan to re-engage soon. =||= I didn't see it discussed, but the main use case for me wanting to mock a static field is logging.   Popular logging frameworks (especially SLF4J) store a log object in a static field `private static final Logger logger = LoggerFactory.getLogger(MyClass.class)`.

In tests I would like to mock this field, so I can validate logging calls at critical places in the business logic, for business reasons of audit trails and operations support. =||= Imo you shouldn't mock the logger but assert whether the logging output contains the desired value  =||= @binkley Can we go one step back?
If you have business reasons to write some audit logs, they _might_ be part of your business. Ergo: your model and your domain. That's perfectly fine in banks, insurance, security, other areas.
Are you really sure _techy_ logs are the way to satisfy the business needs?
E.g. in SLF4J/Logback it's a matter of the configuration for the precise runtime in production. So even if you test static calls, there's no guarantee that this will happen in real business. Someone may misconfigure SLF4J. So again, _maybe_ the audit should become explicit part of your model? =||= @binkley 
>I didn't see it discussed, but the main use case for me wanting to mock a static field is logging. 

> In tests I would like to mock this [static] field

This feature is not intended to set mocks on fields neither with modifer static, private or final. It is meant to enable mocking for static methods. In other words this feature would enable you to stub the static logger factory method, e.g like: `when(LoggerFactory.getLogger(MyClass.class)).thenReturn(mockedLogger)` =||= There are some use cases where I've to mock the third party code while running unit tests. 

`IOUtils.toString(File file, ...)`
or 
`RequestContext.getCurrentContext()`

I'm not sure how and why should I refactor this code. 
 =||= @ghsatpute - The standard way is with a wrapper; e.g. 

```
public interface IOUtilsWrapper {
    default String toString(File file, ....) {
        return IOUtils.toString(File file, ...);
    }
}
```

And pass in either a mock of IOUtilsWrapper, or the real thing. =||= @GregDThomas  
Are you suggesting that in my actual code I should use `IOUtilsWrapper` class? That would be an overkill if I have too many such methods? Or am I missing something?  =||= @ghsatpute  - in the absence of the ability to mock a static, yes. Alternatively, consider the user of PowerMock - https://github.com/powermock/powermock/wiki/Mockito#mocking-static-method =||= I already wrote an extension on top of Mockito+AspectJ, with syntax like
```
when(() -> YourClass.staticMethod(...)).thenReturn(...)
```
It's available here: https://github.com/iirekm/varia/tree/develop/ajmock

Maybe the good way of thinking is:
- pure Mockito - for new, pretty, shiny, testable code
- AjMock - for legacy, untestable code to be able to add tests to it without modifying the source code (which is hard and may break something) =||= With all of the text expended on the horrors of static methods, I have yet to read any solid justification for these strongly held opinions.   It really appears, to me, to be pure dogma and not engineering.

As a software developer, static methods have a great appeal.  The explicitly disavow any state.  That's a big deal and a very, very good thing.   Fwiw, in part due to their lack of state, static methods are themselves _more_ easily covered in JUnit tests.

The _only_ down sides to static methods, that I can see, are a) they cannot be overridden by derived classes, which leads to b) they are more difficult to mock in unit tests.

Downside a) is actually a good thing and easily worked around using a non-static wrapper (as illustrated above) in use cases that require such.

Which leaves mocking.   And only mocking.

So, if there is a good way to help deliver well tested code, I'm all for it.  So, please, add support for mocking static calls directly to Mockito core as soon as is convenient. =||= ""The explicitly disavow any state.""
so what's the point to mock/stub them, if it is just a pure logic.
Static methods actually allow state modification of any accessible part of app, that's the main problem why ppl would like to override its behaviour. =||= From my point of view Mockito is a mocking tool, not a linter, it should not tell you whether your code is good or bad, or dictate how to write it. It's all a matter of taste, like the endless ""tabs vs spaces"" debate and you won't find 2 developpers with the same coding style, so just let people setting up their linting tool the way they want. And even if you think that static is evil, since static methods are allowed in Java anyway, your software can possibly use 3rd party librairies that use them and that you would like to mock, and wrapping everything is overkill (but that's also a matter of taste :) ) =||= @dbacinski sometimes even though they contain pure logic they sometimes use the hardware/network resources. For example, reading some file, or getting something over the Internet would probably be better represented as a static method, as they don't contain any state, but I'd like to mock them when I'm running the test case. 

I agree with @anthofo . I'm using `IOUtils.toString(classpathFile)`. I could right away use this method in my code, but because of this limitation, 
1. I've had to write a wrapper class
2. Create an instance of that class in my caller method 
3. Mock when doing testing. 
And just because I cannot mock the static third-party method. I could write less code/classes if I was able to mock static methods.  =||= I'd argue that a static method that uses the network or disk isn't a good static method - it relies too much on external inputs for it to be a pure function. But, that's personal preference, clearly many people do this, and as such I do think Mockito should offer the option to mock statics. =||= > I am torn on this one. If we provide this possibility, we might invite developers into bad practices. Every time a developer uses this feature, it should be very explicit that it is bad practice imo. Would it be possible to come up with a solution that is clear on this front, but still allows the developer to opt-in?

IMHO, 

1. mockito should not be used as an enforcer for avoiding static methods. May be some other tools need to take care of this. 
1. If we add static method testing feature in mockito - we could use mockito to test legacy code.  =||= >> ""The explicitly disavow any state.""
> so what's the point to mock/stub them, if it is just a pure logic.
> Static methods actually allow state modification of any accessible part of app, that's the main problem why ppl would like to override its behaviour.

In my case, we have a directory structure that contains hundreds of thousands of files.  These files were created by a complex, analytical application executed repeatedly over several years.  Different versions of that software wrote different flavors of the files in varying sub-directory structures.  I have a static class that builds paths to those files based on a small number of inputs.  All of the ""state"", which is based on known behavior of different versions of the analytic software, is known at compile time and has almost no dependencies.

To unit test software that consumes these files, without re-creating the runtime environment, it's really helpful to mock the results of the path generating static methods to point to files packaged as test resources.

Again, the _only_ case against static methods is that Mockito doesn't support mocking them (or is preventing PowerMock from doing so)!!   Every other argument against boils down to a style preference.

Otherwise, there are any number of valid use cases where all state is known at compile time, but that it is very helpful to mock the results for unit test purposes.

 =||= > I'd argue that a static method that uses the network or disk isn't a good static method - it relies too much on external inputs for it to be a pure function. But, that's personal preference, clearly many people do this, and as such I do think Mockito should offer the option to mock statics.

@GregDThomas 
I think, people use static methods because they don't have any state. Sure, there are too many external inputs, but there is _**no state**_. If I read the file a thousand times, I'll get the same output. And I don't think that if we make it no-static those _external inputs_ automatically gets solved. Basically I've to write the same piece of code. 

For stateful code, use class methods and for stateless methods use static.  =||= > > To all: it seems to me there's a fundamental divide in this thread between people who are of the opinion that it's fine to just make a wrapper class for static calls, and people who are of the opinion that wrapper classes add bloat and shouldn't be necessary. I don't see either side convincing the other, so I'm not sure where that leaves us.
> 
> I'd say that the divide is between people who want to design their code properly and those who want to take the path of least resistance (which isn't a wrong choice sometimes).

This really highlights the difference between discussing the needs of the feature and judging the development choices of other teams.

I think @rdicroce got it right. What we see in this issue is that many people are perfectly comfortable buidling wrapper classes for this single, exclusive need [or even PowerMock, which does a bunch stuff, but again for this single purpose] and others wish they could just test the code they already got.

For the first group of people, no action is needed, but also nothing would be lost -- They'd just keep using Mockito while skipping the static mocking. For the second group, I think Mockito [core, by the way] is lacking a feature that could genuinely help them.

In any case, thanks to the team for even investigating this. I hope it gets implemented. =||= what is the current state of this FR? is there any progress is there any decision? =||= This is not currently pursued. It is technically possible but it is a bigger venture and I am currently lacking the time for it. I'd love to do it but I would need at least three full time weeks for it and between projects and other open source work, I cannot currently find that much space. =||= So, any plans on supporting this? =||= As @raphw said it is technically possible. I managed to write [a prototype to stub static methods](https://github.com/ChristianSchwarz/mockito-lambda/commit/a0101976f7af5db5effa39269ec69538eb6f2b78), it also allows to stub `static void` methods using a lambda like that:

```
Mockito.mockStatic(StaticUtil.class);
when(()->StaticUtil.voidFoo()).thenThrow(new RuntimeException());

// or  equivalent 
when(StaticUtil::voidFoo).thenThrow(new RuntimeException());
```

Unfortunatly the idea to use lambda as `when`  argument was rejected years ago (#828 ). 

Therefore the first step should be to define a scope and an API that needs to be accept by the mockito-core developers. 
 =||= The issue exists for about 3 years, So any plan to support it? =||= > So any plan to support it?

The OP of this issue is the founder of mockito, so the answer is yes. Due to the lack of time non of the core developers can't work on it.  
I would like to work on it but I am afraid that a PR won't get reviewed or merged due to the shortage of time of the core mockito developers. An other option would be to fork mockito, but that undertaking is to much effort for me alone since you need to setup the whole release infrastructure.

Nevertheless everyone reading this is invited to participate, either by API discussion, prototypes or other toppics to drive this. =||= Getting this feature right takes a lot of effort and time, as Rafael pointed out. Moreover, in the current situation with the pandemic, we are finding ourselves with less time on our hands and are dealing with problems not related to programming 😢 

There is consensus in the core team that we do want this feature. We have written prototypes and explored this space. Based on these explorations, we had to conclude that it was more challenging than we initially expected. This is not something you can implement in 1 PR and has implications on the larger architecture of Mockito.

While you of course have the option to fork, these problems would remain. We expect you will have a difficult time implementing proper static method support in the current project structure. That's to say: it is probably possible to hack it in, but that is not good for longterm maintenance of the project. Given that Mockito is a mature project used by a lot of users, implementing these hacks would not be the appropriate decision for the large majority of our users.

In my personal judgement, this feature points to the issue that Mockito has matured over time, but we are now finding shortcomings in the current architecture. A better look at the internal implementation and a potential overhaul would help us plan support for this feature. However, I think we are obligated to maintain API stability and prevent a Mockito 2 upgrade scenario, where customers face a large cost of upgrading. Getting that balance right is difficult and time-consuming. Time that we do not have at this moment in time, given the state of the world and the effect that has on our mental/physical health. =||= What is the state of Mockito + PowerMock?   Mostly, I use Mockito.  I end up using different versions on different projects.  My recollection is that, with newer versions of Mockito, it _intentionally_ no longer plays nice with PowerMock.   I.e. all that is required is to re-enable an API or two to re-nable PowerMock.  No need to duplicate that feature set. =||= I am not sure where you got that information from, but that is not our intention. If Powermock 2 and Mockito 3 don't work together, that is a bug. =||= @CharlieReitzel I personally don't like using PowerMockito since Coverage tools show zero coverage for the classes in which we've used PowerMockito.  =||= @ghsatpute Hi Ganesh, I have heard that complaint in the past.  But have had a problem getting coverage measurements for the class under test while using PowerMock.    I am assuming, of course, you don't apply PowerMock to the class under test. =||= @TimvdLippe Forgive me if I have lost the specifics.  It's been a couple years.  Last I checked, I could not use any version of PowerMock with any 2.x version of Mockito and the reason was that certain methods that were public in 1.x became private in 2.x.   If that issue has been resolved in the meantime, I would suggest the following:

1. Verify it is, in fact, possible mock static methods using PowerMock 2 and Mockito 3.
2. Close this issue as ""Won't fix"" with the guidance to use PowerMock for that purpose.

Personally, I agree that, if you find yourself wanting to mock a static method, first think hard about it and see if there isn't a better way to get the job done.   But, sometimes, you just need a sledgehammer!  :--) =||= @CharlieReitzel https://mvnrepository.com/artifact/org.powermock/powermock-api-mockito2 should be compatible with Mockito 2/3. For more info see https://github.com/powermock/powermock/wiki/Mockito-2-Maven

This ticket is about supporting static method mocking in Mockito, without having to rely on Powermock. Since we see merit in supporting that use case in Mockito, we will keep this issue open. =||= I just had a look at the suggestion of @ChristianSchwarz - nicely done! (Could you squash the commits and remove the formatting/import changes?)

I will try to make this my summer project. I know a lot of people want this and I just had too much Byte Buddy maintenance lately to commit to it but I still really want to do it. I have to have a deeper look at Christian's solution and check all edge cases but I think the API makes sense and after some clean up, this might be the way to go! =||= Alright, something bit me yesterday and I built a POC with a slightly different approach. What always bothered me about static mocks was their potential inferrence with parallel test cases and so forth, but all of this is solvable. I put the working prototype on a branch and suggest this API:

https://github.com/mockito/mockito/blob/static-mock/subprojects/inline/src/test/java/org/mockitoinline/StaticMockTest.java

I'll clean it up and add documentation. Feedback welcome! =||= Hi Rafael,  I like the scoping of the mock via Closable interface.   +1.   Also, Java 8 method references make a lot of sense in this context.  

Just out of interest, this looks a bit different than Christian's use of lambdas.  Or does it work out the the same thing (w/ the Java compiler handing Mockito a `Function`  to mock, either way)? =||= Thanks @raphw  for that and glad to see some progress on it. I do want to reiterate that you should not take this project on if you do not have the mental/physical capacity to do so. As a fellow maintainer, I would prefer if you stay in the running, rather than overloading you with this project.

Let us know if we can assist you in any matter possible. Very glad to see an elegant solution this problem, so props for figuring this out! Evidence yet again we can be lucky we have you on our side working on these problems 😄  =||= @raphw glad you took some inspiration and motivation out of my attempt. I had quick look into  your branch, looks like you are going full steam ahead. 

Some questions and toughts:

-  The scope meant to automatically reset the static mock after usage, right?
   - It is safe when used with ""try with resource"" but people might use it without, its not possible to enforce it.
   - The try with resource adds noise / ceremony to the test it self , an other option is to do the reset automatically after a test.
   - How to mock multiple static classes?
   - Can I stub a static method in a before-each so it is not required to stub it in every test?

 - On twitter you wrote the static mocks are thread local
   - What if I am testing a larger component that runs code in multiple threads, how to do that?


  
   

 =||= Hi Christian,

thanks for your prototype. It helped me to put the last bits of the puzzle on its place. The thing that bothers me the most with static method mocks is the inability to run tests in parallel. It can really add a lot of confusion since not everybody expects it, for example when adjusting a build script. This way, it is fully safe. I think for now, we leave it this way; it would however not be difficult to add a `MockSettings` option to include additional threads or to even make the mock global. I still think we leave it out of the first version and consider it for later.

Mocking multiple classes for static methods is fully possible:

```
try (
  MockedStatic<Foo> foo = Mockito.mockStatic(Foo.class);
  MockedStatic<Bar> bar = Mockito.mockStatic(Bar.class)
) {
  // ...
}
```

The only thing that is not allowed is to mock the same class twice but Mockito will detect this and throw an exception. I also adjusted the JUnit integration to make the ceremony superfluous. You can simply do:

```java
@Mock 
MockedStatic<Foo> foo;
```

in a JUnit test when using the rule or extension and the same works in JUnit 5's extension for method parameters. Mockito will then take care of the lifecycle. If the explicit model is used and the mock is not closed, it is currently unsafe. We could however add functionality to clear all mocks on a thread within the runner and rules where I do however expect the annotations to be used mostly.  =||= @raphw I know I am a little late to the party. Is it possible to simplify the API a bit so users are not forced to use the MockStatic instance like this:


```
try(MockedStatic<Dummy> ignore = Mockito.mockStatic(Dummy.class)) {
            when(Dummy::foo).thenReturn(""bar"");
            verify(Dummy::foo);
            
}
```

Once the `Verification`-Lambda is executed you know that `Dummy.foo()` was called. Then you can map the `Dummy.class` to the corresponding `MockedStatic` object. This way users don't need to reference the `MockedStatic` object. This also allows to simplify futher by obmitting the try-with-resource. E.g:

```
Mockito.mockStatic(Dummy.class, ()=>{  //Note: The lambda defines the scope of the static mock
  when(Dummy::foo).thenReturn(""bar"");
  verify(Dummy::foo);
});
```

 =||= I can see for myself that we add something like: 

```java
Mockito.mockStatic(Dummy.class).scope(() -> { 
  ... 
});
```

`mockStatic` is already overloaded, I would like to avoid another overload to keep it synchronous with `mock`. Not sure if I like the lambda syntax. It works nicely with no-arg methods but not so much otherwise. I think at least that introducing it into the standard API should be another ticket, if accepted. =||= Thank Rafael you for the constuctive discussion and considering other opinions and approches. Such a behaviour is rarly found !

> Not sure if I like the lambda syntax.
Yes I know what you mean, it adds noise.

Talking about the scope: An other option is to enable static mocks via`@StaticMock` or `staticMock(Class)` and then reset/disable them automatically after each test. If required users can call `resetStatic(Class)` in the test.

 =||= I don't think I would support a lambda-solution or a solution that relies on a return type. If we would return a special interaction method, where you later have to call `close()` yourself, then you can assign this to any variable/field and make it longlived. This opens up a whole can of worms with working with static method mocking.

Therefore, for me, one requirement for static method mocking is that it is explicitly limited to scope and can't escape that scope. The `try`-solution addresses this point, but the lambda return call does not. =||= When you use the lambda you will be safe, the static mock will only life in the scope of the lambda.

```
Mockito.mockStatic(Dummy.class).scope(() -> { 
  ... 
});
```
The mock is generated when you call the `scope(..)` method, then the lambda/scope is executed.After that the mock will be closed/reset. There is no way to escape the scope. But this extra method and lamda add complexity, same goes for the overloaded mockStatic method that accepts the scope/lambda. 

----

The `MockedStatic` approach don't give you guarantees if the user doesn't use try-with resource like this:

```
var dummy= Mockito.mockStatic(Dummy.class);
dummy.when(Dummy.foo()).thenXXX();
```
The mocking/stubbing/verifing will work as expected but leaves the Class in a mocked state. 


The automatic close/reset at the end of a test is an option that can be considered. =||= Replacing `Mockito.mockStatic(klass, () -> { … })` with the fluent `Mockito.mockStatic(klass).scope(() -> { … })` may look nice (to others, not necessarily to me :-)), but then the compiler won't complain when the scope is missing.
If you want to force a scope, please make it a parameter of (all overloaded) `mockStatic`. =||= The problem with only allowing it in a given lambda scope is that any alternartive life-cyle management approaches are not supported. Having the construct available for example allows for the use in Junit extensions and rules.

The try-with-resources construct can be forgotten but it is also the most flexible option. I suggest we stick to it for the first release.  =||= I'm late to this conversation, and I'm glad to see that there is some movement on this. I am firmly in support of the addition of static method mocking to Mockito. It is true that there are workarounds - someone wrote: ""Every problem can be solved with a layer of abstraction"" - but then there is the corollary that seems to be forgotten: ""...except for the problem of too many layers of abstraction."" Simplicity should be a goal of code - we shouldn't add complexity without good reason, and layers of abstraction add complexity at all levels (in development and at runtime). In the case of mocking statics, it is certainly *possible* to get around this problem (to an extent) by adding a new layer of abstraction - but this adds complexity. We may often decide the trade-off is worth it to make our code testable, but wouldn't it be better if you didn't have to make the trade-off? If you could mock statics without paying the price of adding an extra level of indirection? Also, adding a layer of abstraction is only possible in code that I have control over. What if I'm using a third-party library? `System.currentTimeMillis()` is a classic example - there's no good way to reliably simulate code running at different system times without mocking this static method (you can use wrappers in your own code, but there's no guarantee that all the 3rd-party libraries you might want to use will).

I also wanted to throw a couple of things into the mix, in commentary on the current implementation-in-progress:

1. _constructors are effectively static methods_. I think it would be great if whatever mechanism is implemented here to mock static methods can also be used to mock constructors. Doing so gives you a way to inject mock instances of dependencies into your class-under-test without requiring you to rewrite the class-under-test for this purpose. JMockit provides such a capability, and I would love to see Mockito have it too (as JMockit doesn't play will with OSGi, whereas Mockito does).
2. There has been talk about the temporal scope of the static mock, but I think that consideration also needs to be given to the caller scope: which classes will see the mocked method and which will see the original. I'm thinking here in particular the case of mocking methods of common classes (eg, JDK classes) that might also be in use by the test framework. The test framework will rely on the normal behaviour of the mocked class while you will want the class-under-test (and its dependencies) to see the mocked behaviour. It wouldn't be a good idea to mock (eg) `System.currentTimeMillis()` if it was going to be seen by the test framework as it will mess up the running of the test, but it would be great to be able to mock it for the code-under-test. =||= Thanks, this is about my train of thought. Additionally, it is sometimes just not feasible to refactor code. Either the code is not yours or you cannot change a legacy code base (immediately). In these cases, it is very convenient to have the possibility to mock static methods, also to give you safety if you are changing code in intermediate steps to finally remove them. 

Construction mocks are in the making and will be part of 3.5.0. You can have a look at my open PRs if you want to give it a test run. It's fully working and I am only waiting for the Mockito team members to return from their vacations to get some feedback from them before merging.

Finally note that Mockito forbids mocking the static methods of `System` (and `Thread`). Those methods are to much cemented into class loading which happens in the same thread. At some point, we might add instrumentation to class loading to temporarily disable the static mocks within it to make mocking these classes, too, where we also would need to disable their intensification properties. You can however easily mock `Instant.now()`. =||= "Mockito #1013: Defines and implements API for static mocking.Fixes #1013 - allows for static method mocking in Mockito.Rafael Winterhalterraphw07/10/20, 07:31:02 PM
1960.01961Documentation: `@Mock` on method parameters"While writing [an article about using `@Mock` as a method parameter](https://www.jvt.me/posts/2020/06/27/mockito-mock-parameter/), I noticed that the [JavaDoc for Mockito](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html#mock_annotation) doesn't mention the ability to use `@Mock` as a parameter to a test method.

How would be best to add that as a PR, given it's dependent on the test runner?

I was thinking something like:

```
 * <h3 id=""9"">9. <a class=""meaningful_link"" href=""#mock_annotation"" name=""mock_annotation"">Shorthand for mocks creation - <code>&#064;Mock</code> annotation</a></h3>
 *
 * <ul>
 * <li>Minimizes repetitive mock creation code.</li>
 * <li>Makes the test class more readable.</li>
 * <li>Makes the verification error easier to read because the <b>field name</b>
 * is used to identify the mock.</li>
 * </ul>
 *
 * <pre class=""code""><code class=""java"">
 *   public class ArticleManagerTest {
 *
 *       &#064;Mock private ArticleCalculator calculator;
 *       &#064;Mock private ArticleDatabase database;
 *       &#064;Mock private UserProvider userProvider;
 *
 *       private ArticleManager manager;
 *
 *       @Test
 *       void testSomething(@Mock ArticleDatabase database) {
 * </code></pre>
```""We mention that information in https://javadoc.io/doc/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html as we don't support initiating Mocks on parameters with JUnit4. Therefore, we should add a parameter something like:

```java
 *       @Test
 *       void testSomething(@Mock ArticleDatabase canOnlyBeInstantiatedWithJUnit5) {
```

Other than that, please open a PR 😄  =||= Oh I didn't realise that, thanks! I'll amend my article with that knowledge too.

Am I OK to add a PR for both the v2 and v3 documentation, given it works on both versions? =||= We no longer publish v2 updates, so v3 only. =||= "Document using `@Mock` with method parameters"Although we've called it out in the [JUnit extension], we should also
make sure it's clear in the core documentation to make it more visible.

We can fully-quality the `@Test` annotation to make clear that it has to
be with JUnit 5.

Closes #1960.

[JUnit extension]: https://javadoc.io/doc/org.mockito/mockito-junit-jupiter/latest/org/mockito/junit/jupiter/MockitoExtension.html"Jamie Tannajamietanna06/29/20, 04:15:19 PM
1972.01973Update dependency to byte buddy version 1.10.13"https://github.com/mockito/mockito/blob/release/3.x/gradle/dependencies.gradle#L7

1.10.13 is available: https://github.com/raphw/byte-buddy/releases/tag/byte-buddy-1.10.13"Feel free to open a PR with the version bump 😄  =||= update dependency to byte buddy version 1.10.13"Fixes #1972 : update byte buddy to 1.10.13 to include fixes and support JDK 16"Michael Krollmickroll07/15/20, 12:52:47 PM
1985.01986README should refer the latest available documentation"**Actual:**
README contains link `latest documentation` 
http://javadoc.io/page/org.mockito/mockito-core/2/org/mockito/Mockito.html 
which redirects to 
https://javadoc.io/static/org.mockito/mockito-core/2.9.0/org/mockito/Mockito.html 
(Note: version is `2.9.0`)

**Expected:**
The link `latest documentation` should point to the latest available documentation 
http://javadoc.io/page/org.mockito/mockito-core/3/org/mockito/Mockito.html
which redirects to 
https://javadoc.io/static/org.mockito/mockito-core/3.4.4/org/mockito/Mockito.html 
at the current moment (Note: version is `3.4.4`)."Feel free to open a PR :) =||= Fixes #1985 : Update README to refer the latest documentationFixes #1985 Valery Yatsynovichvalfirst07/20/20, 01:08:22 PM
1988.01989MockitoJUnitRunner causes NPE when using @Mock on MockedStatic fields"check that

 - [x] The mockito message in the stacktrace have useful information, but it didn't help
 - [x] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [x] Provide versions (mockito / jdk / os / any other relevant information)
 - [x] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)

**Versions:**
 - mockito: 3.4.4
 - junit: 4.12
 - jdk: 1.8
 - os: windows 10

**Example:**

1. [MockitoJUnitRunnerWithMockedStaticTest](https://github.com/Cybermite/mockito-static-npe-example/blob/bdd30465632b21c36ce7635929e7825c5878ee83/src/test/java/org/mockito/example/MockitoJUnitRunnerWithMockedStaticTest.java)
    * Reproduces the problem documented in this issue.
1. [MockitoOpenMocksMockedStaticTest](https://github.com/Cybermite/mockito-static-npe-example/blob/bdd30465632b21c36ce7635929e7825c5878ee83/src/test/java/org/mockito/example/MockitoOpenMocksMockedStaticTest.java)
    * Same tests but manually opens and closes the mocks (doesn't use the runner). Shows the tests are ran as expected.

**Problem:**

The `MockitoJUnitRunner` is causing a `NullPointerException` when the test class contains a `@Mock` instance field with a type of `MockedStatic`. This exception only occurs for tests that are ran after a prior test fails. If all the tests pass, there are no issues.

Stack Trace (Test 1):

```
java.lang.AssertionError: intentional failure
	at org.junit.Assert.fail(Assert.java:88)
	at org.mockito.example.MockitoJUnitRunnerWithMockedStaticTest.testName1(MockitoJUnitRunnerWithMockedStaticTest.java:40)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.mockito.internal.runners.DefaultInternalRunner$1$1.evaluate(DefaultInternalRunner.java:54)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.mockito.internal.runners.DefaultInternalRunner$1.run(DefaultInternalRunner.java:99)
	at org.mockito.internal.runners.DefaultInternalRunner.run(DefaultInternalRunner.java:105)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:40)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:163)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:538)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:760)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:206)

org.mockito.exceptions.misusing.NotAMockException: Argument passed to Mockito.mockingDetails() should be a mock, but is an instance of class java.lang.Class!
	at org.mockito.internal.runners.DefaultInternalRunner$1$2.testFinished(DefaultInternalRunner.java:81)
	at org.junit.runner.notification.SynchronizedRunListener.testFinished(SynchronizedRunListener.java:56)
	at org.junit.runner.notification.RunNotifier$7.notifyListener(RunNotifier.java:190)
	at org.junit.runner.notification.RunNotifier$SafeNotifier.run(RunNotifier.java:72)
	at org.junit.runner.notification.RunNotifier.fireTestFinished(RunNotifier.java:187)
	at org.junit.internal.runners.model.EachTestNotifier.fireTestFinished(EachTestNotifier.java:38)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:331)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.mockito.internal.runners.DefaultInternalRunner$1.run(DefaultInternalRunner.java:99)
	at org.mockito.internal.runners.DefaultInternalRunner.run(DefaultInternalRunner.java:105)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:40)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:163)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:538)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:760)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:206)
```

Stack Trace (Test 2):

```
java.lang.NullPointerException
	at org.mockito.example.MockitoJUnitRunnerWithMockedStaticTest.testName2(MockitoJUnitRunnerWithMockedStaticTest.java:54)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.mockito.internal.runners.DefaultInternalRunner$1$1.evaluate(DefaultInternalRunner.java:54)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
	at org.mockito.internal.runners.DefaultInternalRunner$1.run(DefaultInternalRunner.java:99)
	at org.mockito.internal.runners.DefaultInternalRunner.run(DefaultInternalRunner.java:105)
	at org.mockito.internal.runners.StrictRunner.run(StrictRunner.java:40)
	at org.mockito.junit.MockitoJUnitRunner.run(MockitoJUnitRunner.java:163)
	at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)
	at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:538)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:760)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:460)
	at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:206)
```

**Investigation:**

After some investigation, it appears the first test is failing twice (once in the test and once in the testFinished listener). This code:

https://github.com/mockito/mockito/blob/573bf0df389964d7fdeb4de486882d4599b8033c/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java#L75-L96

Line 81 is where it fails the second time. If we navigate down the call hierarchy, it appears it fails because the static mock has already been cleaned up so the framework doesn't think it's a mock and fails with a `NotAMockException`.  Since it fails there, it doesn't set the listener to null which will in-turn result in the mocks not being initialized on the next test that's ran (hits line 51):

https://github.com/mockito/mockito/blob/573bf0df389964d7fdeb4de486882d4599b8033c/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java#L42-L59

Since the mocks are not initialized for the second test, it ultimately causes the `NullPointerException`.

It's also causing the remaining tests after the first test failure to bounce back and forth between `NullPointerException` and `NotAMockException`. The reason for this appears to be because [this failure](https://github.com/mockito/mockito/blob/573bf0df389964d7fdeb4de486882d4599b8033c/src/main/java/org/mockito/internal/runners/DefaultInternalRunner.java#L67) object never gets reset after it's processed so it keeps restarting the chain of throwing the two exceptions back and forth.

Also, I did include a sample test that manually opens and closes the mocks (doesn't use MockitoJUnitRunner) and everything is working as expected. Using the try-with-resource works fine as well.

I did investigate further and noticed something related to this might have been addressed in [this PR](https://github.com/mockito/mockito/pull/1968/files?file-filters%5B%5D=.java#diff-d24b5a756bdb953f5effcddac2b17b72R42). It only updated the findStubbings method to skip the static mocks, though. Was the AllInvocationsFinder.find(...) method intentional left out of that or just an oversight?""Just tried the tests with using MockitoRule and it's working as expected as well. =||= @raphw this issue still exists in 3.4.6. Was the PR supposed to fix all of this or only a part of it? The linked example above still causes NPE. This one: [MockitoJUnitRunnerWithMockedStaticTest](https://github.com/Cybermite/mockito-static-npe-example/blob/bdd30465632b21c36ce7635929e7825c5878ee83/src/test/java/org/mockito/example/MockitoJUnitRunnerWithMockedStaticTest.java) =||= I was under the impression that I fixed it but I will take another look if it is not. I refactored your test and added it to the built but maybe I broke it in the process. =||= I just ran the test with the latest Mocktio and it works as expected. Are you sure that you are running the right version?  =||= Yep, just doubled checked. It's using 3.4.6. Are you running my test class (without modification) or your refactored version of it? If you modified it, can you send me modified one and I'll double check it. =||= Copy pasted it as it is i to the release/3.x branch.  =||= Okay, sorry for the confusion. When I was investigating this issue on July 25, I must have installed into locally and it got shoved into my local .m2 repo as 3.4.6 without the fix. Then when you fixed it and I updated the pom version to point to 3.4.6 it didn't redownload it because it was already in my local repo.

I deleted it from my local .m2 repo and redownloaded it from maven-central. Everything is good now. Thanks! =||= Perfect, Gradle does not work with snapshot versions, happened to me a few times, too.  =||= "Do not pass static mocks to regular listener callback."Does not include static mocks in regular listener logic as it might distort existing mock collectors that do not expect scoped mocks. Fixes #1988.

We have passed `Class` objects to the listener to indicate a static mock. The class object is of course itself not a regular mock and it's cleaner to create a callback method of it's own. This way, existing listeners remain logically backwards compatible, including our own listener that is used within the JUnit runner (we have only tested the rule, I added a test for the runner, too)."Rafael Winterhalterraphw07/29/20, 03:22:12 PM
1992.01998Update to org.objenesis 3.x"Hi all,

we are slowly updating our product to Java 11; we've managed to move to Java 11 runtime, now we are trying to also compile with Java 11.

We ran into a problem with `org.easymock` (it doesn't work with Java 11 compiled classes, https://github.com/easymock/easymock/issues/218). The problem is resolved in 4.x versions.

Unfortunately, 4.x versions of `org.easymock` run only with `org.objenesis` 3.x, which `mockito` so far does not accept (upper bound for `org.objenesis` is 2.6).

Are there plans to update `mockito` to run with `org.objenesis` and if so are there known timelines?

Some more background:

We essentially wished to update to latest `mockito` and `easymock` earlier (during the Java 11 runtime move), but were unable to do so due to conflicting `org.objenesis` requirements. If we want to compile with Java 11 however, we are made to choose between  `easymock` or `mockito`, or waiting. We would prefer to wait, if a `mockito` update that runs with `org.objenesis` 3.x would be available soon.

Sorry if this should be an e-mail message and not an issue in the tracker, or if this is a duplicate (I didn't find much about `org.objenesis` in the issue list).

Best regards and thanks,
Simeon"I would be happy to review a PR that updates our version of Objenesis 😄  =||= I'll check the contribution guide, though I can't promise much. So far Java 11 compile is not top priority in my team. =||= Update objenesis to 3.1"see http://objenesis.org/notes.html

fixes #1992
"Erhard Pointlepeee08/09/20, 11:35:34 AM
2015.02017Issues mocking Java framework classes in Robolectric with mockito-inline"Hi Mockito folks,

Currently it is not possible to mock a Java framework class (e.g. java.io.File) in Robolectric when mockito-inline is used. This issue has come up a bunch of times in Robolectric, mostly when Kotlin is used to write Robolectric tests.

https://github.com/robolectric/robolectric/issues/5522
https://github.com/robolectric/robolectric/issues/5638
https://github.com/robolectric/robolectric/issues/5865

For instance, if a trivial tests is run with the Robolectric test runner with mockito-inline:

```java
  @Test
  public void file_getAbsolutePath_isMockable() throws Exception {
    File file = mock(File.class);
    doReturn(""absolute/path"").when(file).getAbsolutePath();
    assertThat(file.getAbsolutePath()).isEqualTo(""absolute/path"");
  }
```

An NPE will result:
```
java.lang.NullPointerException
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.isConstructorMock(MockMethodDispatcher.java:41)
	at java.base/java.io.File.<init>(File.java)
	at java.base/sun.net.www.protocol.file.Handler.openConnection(Handler.java:80)
	at java.base/sun.net.www.protocol.file.Handler.openConnection(Handler.java:72)
	at java.base/java.net.URL.openConnection(URL.java:1063)
	at java.base/sun.net.www.protocol.jar.JarURLConnection.<init>(JarURLConnection.java:84)
	at java.base/sun.net.www.protocol.jar.Handler.openConnection(Handler.java:41)
	at java.base/java.net.URL.openConnection(URL.java:1063)
	at java.base/java.net.URLClassLoader.getResourceAsStream(URLClassLoader.java:327)
	at org.robolectric.internal.bytecode.SandboxClassLoader.getClassBytesAsStreamPreferringLocalUrls(SandboxClassLoader.java:101)
	at org.robolectric.internal.bytecode.SandboxClassLoader.getByteCode(SandboxClassLoader.java:172)
	at org.robolectric.internal.bytecode.SandboxClassLoader.maybeInstrumentClass(SandboxClassLoader.java:129)
	at org.robolectric.internal.bytecode.SandboxClassLoader.lambda$loadClass$0(SandboxClassLoader.java:115)
	at org.robolectric.util.PerfStatsCollector.measure(PerfStatsCollector.java:53)
	at org.robolectric.internal.bytecode.SandboxClassLoader.loadClass(SandboxClassLoader.java:115)
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:521)
	at org.robolectric.Shadows.reset(Shadows.java:2298)
	at org.robolectric.android.internal.AndroidTestEnvironment.resetState(AndroidTestEnvironment.java:518)
	at org.robolectric.RobolectricTestRunner.lambda$finallyAfterTest$0(RobolectricTestRunner.java:349)
	at org.robolectric.util.PerfStatsCollector.measure(PerfStatsCollector.java:75)
	at org.robolectric.RobolectricTestRunner.finallyAfterTest(RobolectricTestRunner.java:347)
	at org.robolectric.internal.SandboxTestRunner$2.lambda$evaluate$0(SandboxTestRunner.java:272)
	at org.robolectric.internal.bytecode.Sandbox.lambda$runOnMainThread$0(Sandbox.java:89)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
```

Robolectric uses an instrumenting ClassLoader that transforms Android classes to use real implementations:
https://github.com/robolectric/robolectric/blob/master/sandbox/src/main/java/org/robolectric/internal/bytecode/SandboxClassLoader.java#L105

Here is a fork of Robolectric that has a test that captures the issue:
https://github.com/hoisie/robolectric/tree/mockito-inline-test

You can see the failure using the following command:
`./gradlew  :integration_tests:mockito-experimental:test`

Any tips/help debugging would be greatly appreciated. It would be nice to figure out what Robolectric is doing to prevent this from working.



""Are you moving `org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher` to another class loader? Normally, Mockito injects this class into the bootstrap class loader and then initializes this dispatcher with a random identifier. All inline mocks call this class with the very same identifier to communicate with Mockito. The bootstrap loader is used to avoid any issues with class loader hierarchies.

The null pointer exception suggests that the class `org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher` exists on multiple class loaders and that the initialization hit another class loader then the dispatcher. The easiest would be to build something into Robolectric that makes sure that the class loader tricks you apply never targets the `MockMethodDispatcher`. It must only exist in the boot loader at all times. =||= This is indeed the problem, the loader of `MockMethodDispatcher` if resolved from the mock type is `org.robolectric.internal.AndroidSandbox$SdkSandboxClassLoader`. The dispatcher must always be loaded by the bootstrap class loader. You need to exclude it from your class loader shadowing for it to work with boot classes, otherwise the boot classes cannot communicate with Mockito. =||= Can you try again with the release from just now? I defined the window of intercpting construction as narrowly as possible. =||= Thanks for taking a look! I'm excited to give this a shot. Seems like [3.5.4](http://dl.bintray.com/mockito/maven/org/mockito/mockito-inline/3.5.4) hasn't been pushed completely to the maven repo, so I may do a local build if it doesn't show up.

Robolectric does indeed instrument the `org.mockito.*` classes, so I'll make sure that org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher is not being instrumented. Do any other Mockito classes have to be excluded from instrumentation? I tried to exclude all Mockito classes from being instrumented, but then it became impossible to use Mockito to mock Android classes, which is another use case that we would like to support. If we do not instrument org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher, do you see any issues with using Mockito to mock classes instrumented in the Robolectric class loader? =||= That seemed to work! Thanks!! =||= We struggled with Bintray for a while and releases got broken.

It's all about the mock being able to communicate with Mockito. A class on the bootstrap loader can only communicate with classes on the boot loader. I assume your class loaders are child-first? Even those should be parent first for the boot loader, normally.  This way, frameworks dispatching via the bootloader would generally function with Robolectric. =||= "Only enable mocking of types right before instantiation to avoid circular interception of constructor creation.Fixes #2015.Rafael Winterhalterraphw08/21/20, 08:50:15 AM
2011.02023Stackoverflow error when upgrading to v3.5.2"I tried to upgrade from Mockito v3.4.6 to v3.5.2 and I'm getting a stackoverflow error (same error with v3.5.0) when running some tests (not all of them, just a few ; even in the same class : some tests pass and others don't).

Stacktrace :
```
java.lang.StackOverflowError
	at java.base/java.lang.ThreadLocal.get(ThreadLocal.java:163)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:260)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:53)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
        ...
```

I didn't succeed in reproduce the error in a small project, but I'll spend more time to try and post the sources here when/if I have a reproducible case.

Environment :
- Mockito v3.5.2
- JUnit v5.6.2
- Java :
> openjdk version ""11.0.8"" 2020-07-14
> OpenJDK Runtime Environment (build 11.0.8+10-post-Ubuntu-0ubuntu118.04.1)
> OpenJDK 64-Bit Server VM (build 11.0.8+10-post-Ubuntu-0ubuntu118.04.1, mixed mode, sharing)
- Maven : v3.6.0 (tests are run by the maven-surefire plugin)""I just discovered that the error happens when I launch all my unit tests in the Maven module, but it's fine if I run the test or the test class only.

```sh
$ cd myproject/my-mvn-module-1
$ mvn test
#
# [ERROR]   MyBeanTest.test1 » StackOverflow
#
$ mvn -Dtest=MyBeanTest test
# 
# Tests run: 7, Failures: 0, Errors: 0, Skipped: 0
#
$ mvn -Dtest=MyBeanTest#test1 test
# 
# Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
#
```

Maven configuration (in the root pom.xml) :
```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.22.2</version>
    <configuration>
        <skipTests>${skip.unit.tests}</skipTests>
        <includes>
            <include>**/*Test.java</include>
        </includes>
        <argLine>-Dnet.bytebuddy.experimental=true @{argLine} -Dfile.encoding=${project.reporting.outputEncoding}</argLine>
        <trimStackTrace>false</trimStackTrace>
    </configuration>
</plugin>
``` =||= Thanks for reporting. Can you supply an example test case? It looks like an exception is supposed to be thrown but the constructor mocking intercepts its creation where something causes another exception which is again passed to the handler.

Do you mock exceptions somewhere?

Also, could you share the bottom of the stack trace which is where the circularity is introduced. =||= Seeing the same thing myself, although I don't have a stable reproduction scenario. The same was observed with `3.5.0` =||= Could you try the latest release to see if the problem still occurs? =||= Sorry I was not clear originally, I saw the problem at first on `3.5.0` but still see it with `3.5.2`. =||= @raphw 

Yes I mock some exceptions in other test classes but the ones who ends with StackoverflowError. I will take some time today or next week to try to reproduce the bug in a small project.

The full stacktrace :
```
java.lang.StackOverflowError
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:53)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	/* [...] */
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at java.base/java.lang.ClassCastException.<init>(ClassCastException.java:58)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	/* end of stacktrace */
``` =||= This can't be the full stack trace since it needs to origin somewhere. Maybe it's cut off in the print?

I think I know the problem and tried to fix it. Unfortunately, we have some release issues but you could build *release/3.x* locally and try if the problem still occurs. =||= I'm seeing the same error when trying to go from 3.4.6 to 3.5.0.
```
java.lang.StackOverflowError
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.isConstructorMock(MockMethodDispatcher.java:57)
	at java.base/java.lang.Exception.<init>(Exception.java)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
... 
```
seems to be related to using a @Spy in the test class, when I change the @Spy to an @Mock the error goes away.  What seems odd in my case is everything is ok until there are more than 15 tests in the class.  15 tests will pass and any additional tests will fail.

The message of the first exception is `Unexpected spy for java.util.AbstractMap on instance of java.util.concurrent.ConcurrentHashMap`    =||= @raphw Same issue with v3.5.5.

Stacktrace :
```
java.lang.StackOverflowError
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
        [...]
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.lang.Throwable.<init>(Throwable.java)
	at java.base/java.lang.Exception.<init>(Exception.java:66)
	at java.base/java.lang.RuntimeException.<init>(RuntimeException.java:62)
	at org.mockito.exceptions.base.MockitoException.<init>(MockitoException.java:34)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:273)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
``` =||= @jdussouillez That gets us one step closer but I needed to add an exception for when the error is thrown. Could you build the *constructor-dispatch* branch locally and see what exception you get in your setup? =||= @raphw I installed v3.5.6 from the *constructor-dispatch* branch : no more errors, all the tests were executed and passed. So I guess commit https://github.com/mockito/mockito/commit/eaa12bfc018ed00fcd35588dc900d657a9740e32 fixes the issue.

Feel free to ask if you want me to do more tests. =||= That's strange since the exception indicates a scenario that should not occur. I merely fixed the recursion.

Can you set a breakppint to see why this happens? What instance is created during spy construction?  =||= @raphw I didn't succeed in setting breakpoints but I added some logs (before [this line](https://github.com/mockito/mockito/blob/constructor-dispatch/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java#L268)).

Patch : 
```diff
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
index 96477f477..6b37ea09e 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
@@ -265,6 +265,9 @@ public class InlineByteBuddyMockMaker
                         } else if (type.isInstance(spy)) {
                             return spy;
                         } else {
+                            System.out.println(""type = "" + type.getName());
+                            System.out.println(""object = "" + object);
+                            System.out.println(""spy = "" + spy.getClass().getName());
                             isSuspended.set(true);
                             try {
                                 // Unexpected construction of non-spied object
```

Logs (type is always `java.util.AbstractMap`):
```
type = java.util.AbstractMap
object = {}
spy = com.myproject.bean.MyBean1

type = java.util.AbstractMap
object = {}
spy = com.myproject.bean.MyBean2

type = java.util.AbstractMap
object = {}
spy = com.myproject.bean.MyBean3
[...]
``` =||= Could you also add a stack trace at the same spot? (`Thread.dump()`) =||= Code snippet to dump : 
```java
try {
    Thread.dumpStack();
} catch (Throwable t) {
    System.out.println(""error while dumping stack: "" + t.getMessage());
}
```


1. Logs using [`Thread.dumpStack()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#dumpStack()) **after** `isSuspended.set(true);`

```
type = java.util.AbstractMap
object = {}
spy = com.myproject.bean.MyBeanTest$TestClass
<dump>
java.lang.Exception: Stack trace
	at java.base/java.lang.Thread.dumpStack(Thread.java:1388)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$new$3(InlineByteBuddyMockMaker.java:272)
	at org.mockito.internal.creation.bytebuddy.MockMethodAdvice.handleConstruction(MockMethodAdvice.java:176)
	at org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher.handleConstruction(MockMethodDispatcher.java:69)
	at java.base/java.util.AbstractMap.<init>(AbstractMap.java)
	at java.base/java.util.concurrent.ConcurrentHashMap.<init>(ConcurrentHashMap.java:828)
	at java.base/java.lang.ClassLoader.<init>(ClassLoader.java:333)
	at java.base/java.lang.ClassLoader.<init>(ClassLoader.java:457)
	at java.base/jdk.internal.reflect.DelegatingClassLoader.<init>(ClassDefiner.java:72)
	at java.base/jdk.internal.reflect.ClassDefiner$1.run(ClassDefiner.java:60)
	at java.base/jdk.internal.reflect.ClassDefiner$1.run(ClassDefiner.java:58)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/jdk.internal.reflect.ClassDefiner.defineClass(ClassDefiner.java:57)
	at java.base/jdk.internal.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:400)
	at java.base/jdk.internal.reflect.MethodAccessorGenerator$1.run(MethodAccessorGenerator.java:394)
	at java.base/java.security.AccessController.doPrivileged(Native Method)
	at java.base/jdk.internal.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:393)
	at java.base/jdk.internal.reflect.MethodAccessorGenerator.generateConstructor(MethodAccessorGenerator.java:92)
	at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:55)
	at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:490)
	at org.mockito.internal.util.reflection.ReflectionMemberAccessor.lambda$newInstance$0(ReflectionMemberAccessor.java:26)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.lambda$newInstance$4(InlineByteBuddyMockMaker.java:631)
	at org.mockito.internal.util.reflection.ReflectionMemberAccessor.newInstance(ReflectionMemberAccessor.java:26)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.newInstance(InlineByteBuddyMockMaker.java:626)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.doCreateMock(InlineByteBuddyMockMaker.java:373)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createSpy(InlineByteBuddyMockMaker.java:349)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:44)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:61)
	at org.mockito.Mockito.spy(Mockito.java:2033)
	at com.myproject.bean.MyBeanTest.test1(MyBeanTest.java:274)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.platform.commons.util.ReflectionUtils.invokeMethod(ReflectionUtils.java:686)
	at org.junit.jupiter.engine.execution.MethodInvocation.proceed(MethodInvocation.java:60)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.engine.extension.TimeoutExtension.intercept(TimeoutExtension.java:149)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestableMethod(TimeoutExtension.java:140)
	at org.junit.jupiter.engine.extension.TimeoutExtension.interceptTestMethod(TimeoutExtension.java:84)
	at org.junit.jupiter.engine.execution.ExecutableInvoker$ReflectiveInterceptorCall.lambda$ofVoidMethod$0(ExecutableInvoker.java:115)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:98)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$invokeTestMethod$6(TestMethodTestDescriptor.java:212)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.invokeTestMethod(TestMethodTestDescriptor.java:208)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:137)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.execute(TestMethodTestDescriptor.java:71)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:135)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1541)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:220)
	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$6(DefaultLauncher.java:188)
	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:202)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:181)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:128)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invokeAllTests(JUnitPlatformProvider.java:150)
	at org.apache.maven.surefire.junitplatform.JUnitPlatformProvider.invoke(JUnitPlatformProvider.java:124)
	at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:384)
	at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:345)
	at org.apache.maven.surefire.booter.ForkedBooter.execute(ForkedBooter.java:126)
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:418)
</dump>
```

2. Logs using [`Thread.dumpStack()`](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Thread.html#dumpStack()) **before** `isSuspended.set(true);`

```
type = java.util.AbstractMap
object = {}
spy = com.myproject.library.LibraryBean1
<dump>
type = java.lang.Throwable
object = java.lang.Exception
spy = com.myproject.library.LibraryBean1
<dump>
type = java.lang.Throwable
object = java.lang.Exception
spy = com.myproject.library.LibraryBean1

[...]

error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
error while dumping stack: Unexpected spy for java.lang.Throwable on instance of java.lang.Exception
</dump>
``` =||= I thought it would be related to class loading.

I am curious however how you end uo with the reflection member accessor. It should be the instrumentation based one. Are you using the latest build?  =||= > Are you using the latest build?

I pulled the *constructor-dispatch* branch this morning before giving you the `Thread.dumpStack()` output. I just switched to branch *release/3.x* (3.5.6, next 3.5.7), applied my logs and run my tests again : same results.
 =||= Strange, I'll investigate. Could you make sure that you don't have a stale version? You are using *mockito-inline* or are you configuring the mock maker manually?  =||= > Could you make sure that you don't have a stale version?

I already checked using `mvn dependency:tree` but it says I'm using 3.5.7 (I'm using the *release/3.x* branch).
I will try to copy my project, use v3.5.2 and remove code step by step until I can reproduce the bug with only a few files so I can provide you a reproducible example.

----

> You are using mockito-inline or are you configuring the mock maker manually?

I'm using mockito-core :

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>3.5.7</version>
    <scope>test</scope>
</dependency>
```

And I do not configure anything manually. I just have the `src/test/resources/mockito-extensions/org.mockito.plugins.MockMaker` config file which contains
```
mock-maker-inline
```
 =||= That explains it. You can drop the config and just use the inline artifact which defines the nock maker for you. The member accessor is another plugin which requires manual activation using a similar file if you don't use the other artifact.  =||= > You can drop the config and just use the inline artifact which defines the nock maker for you.

I used mockito-inline v3.5.6, all tests passed but 3. The 3 that fails are new ones (not the ones who failed before) and none of them use Mockito (but all of them are on enums, apparently `MyEnum.values()` returns an array with null values inside). But they're executed correctly when running them manually, class by class ([like I did before](https://github.com/mockito/mockito/issues/2011#issuecomment-677610343))

Do you know how can I generate the inline JAR from the sources ? I can't provide you the logs I added in the source with mockito-inline because the JAR is not generated by `./gradlew -x check clean build`. =||= @raphw Thank you for the fix and the time spent on this. It works great ! =||= "Initializes classes prior to instrumentation to avoid uncontrolled code execution.Fixes #2011 - triggeres initializers explicitly.Rafael Winterhalterraphw08/25/20, 10:32:46 PM
2007.02024Android instrumentation test packaging fails for mockito-android 3.5.0 with minSdk < 26"We've upgraded from `mockito-android:3.4.6` to `mockito-android:3.5.0`. I'm attempting to package up my instrumented tests by running the `assembleAndroidTest` gradle task. The task fails with the following errors:
```
/Users/<me>/.gradle/caches/transforms-2/files-2.1/fb7959dc5bfc8ebb26ad0660efa1929e/jetified-mockito-core-3.5.0.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
/Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
```

and with root cause:
```
com.android.tools.r8.utils.b: Error: /Users/<me>/.gradle/caches/transforms-2/files-2.1/4d4498fa5552ba637b5a9594a0871b80/jetified-objenesis-3.1.jar:org/objenesis/instantiator/util/DefineClassHelper$Java8.class, java.lang.Class org.objenesis.instantiator.util.DefineClassHelper$Java8.defineClass(java.lang.String, byte[], int, int, java.lang.Class, java.lang.ClassLoader, java.security.ProtectionDomain), MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.utils.y0.a(:21)
        at com.android.tools.r8.utils.O.a(:51)
        ... 35 more
```
""Should be fixed with #2006 =||= We still have issues with 3.5.2. We are unable to update to new version and use `assembleAndroidTest` task.

```
/usr/local/gradle/caches/transforms-2/files-2.1/225c46d0e9f10ff5ef3f4d9a009c4924/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)

``` =||= @kozaxinan Are you certain that you are using 3.5.2 and aren't accidentally using an older version of either Mockito or ByteBuddy? We have had confirmations from other users that 3.5.2 fixed the issue you are seeing, so it would be good to double check that you have the correct version. =||= @TimvdLippe I confirm the issue still occurs also in our project with the exact same error.
- mockito-core 3.5.2
- mockito-android 3.5.2
- mockito-inline 3.5.2
- objenesis 3.1
- bytebuddy 1.10.13 =||= Looks like the issue was introduced in objenesis 3.x (upgraded in https://github.com/mockito/mockito/pull/1998)
Forcing objenesis to 2.6 makes `assembleAndroidTest` task succeed. =||= Aha, thanks for letting us know. I will create a revert. =||= Still getting this error with 3.5.7 =||= Here's the stacktrace that I get when using 3.5.7:

```
/Users/azizbekian/.gradle/caches/transforms-2/files-2.1/63e24576c0e1d1e5b675c1c61e4e5727/jetified-objenesis-3.1.jar: D8: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
Stack trace:
com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.errors.a.a(:7)
        at com.android.tools.r8.ir.conversion.O.b(:58)
        at com.android.tools.r8.ir.conversion.O.a(:104)
        at com.android.tools.r8.ir.conversion.O.a(:53)
        at com.android.tools.r8.graph.C.b(:43)
        at com.android.tools.r8.ir.conversion.O.b(:35)
        at com.android.tools.r8.utils.U0.a(:10)
        at com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask.runInterruptibly(TrustedListenableFutureTask.java:125)
        at com.google.common.util.concurrent.InterruptibleTask.run(InterruptibleTask.java:69)
        at com.google.common.util.concurrent.TrustedListenableFutureTask.run(TrustedListenableFutureTask.java:78)
        at com.google.common.util.concurrent.MoreExecutors$DirectExecutorService.execute(MoreExecutors.java:322)
        at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:66)
        at com.google.common.util.concurrent.AbstractListeningExecutorService.submit(AbstractListeningExecutorService.java:36)
        at com.android.tools.r8.utils.U0.a(:3)
        at com.android.tools.r8.ir.conversion.O.a(:10)
        at com.android.tools.r8.D8.d(:29)
        at com.android.tools.r8.D8.b(:1)
        at com.android.tools.r8.utils.W.a(:30)
        at com.android.tools.r8.D8.run(:11)
        at com.android.builder.dexing.D8DexArchiveBuilder.convert(D8DexArchiveBuilder.java:116)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.process(DexingTransform.kt:296)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.processNonIncrementally(DexingTransform.kt:243)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.doTransform(DexingTransform.kt:153)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.access$doTransform(DexingTransform.kt:69)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:104)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform$transform$1.invoke(DexingTransform.kt:69)
        at com.android.build.gradle.internal.tasks.BlocksUtilsKt.recordArtifactTransformSpan(BlocksUtils.kt:33)
        at com.android.build.gradle.internal.dependency.BaseDexingTransform.transform(DexingTransform.kt:100)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformer.transform(DefaultTransformer.java:193)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$TransformerExecution.execute(DefaultTransformerInvocationFactory.java:332)
        at org.gradle.internal.execution.steps.ExecuteStep.lambda$execute$0(ExecuteStep.java:32)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:32)
        at org.gradle.internal.execution.steps.ExecuteStep.execute(ExecuteStep.java:26)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:67)
        at org.gradle.internal.execution.steps.CleanupOutputsStep.execute(CleanupOutputsStep.java:36)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:49)
        at org.gradle.internal.execution.steps.ResolveInputChangesStep.execute(ResolveInputChangesStep.java:34)
        at org.gradle.internal.execution.steps.CancelExecutionStep.execute(CancelExecutionStep.java:43)
        at org.gradle.internal.execution.steps.TimeoutStep.executeWithoutTimeout(TimeoutStep.java:73)
        at org.gradle.internal.execution.steps.TimeoutStep.execute(TimeoutStep.java:54)
        at org.gradle.internal.execution.steps.CatchExceptionStep.execute(CatchExceptionStep.java:34)
        at org.gradle.internal.execution.steps.CreateOutputsStep.execute(CreateOutputsStep.java:44)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:54)
        at org.gradle.internal.execution.steps.SnapshotOutputsStep.execute(SnapshotOutputsStep.java:38)
        at org.gradle.internal.execution.steps.BroadcastChangingOutputsStep.execute(BroadcastChangingOutputsStep.java:49)
        at org.gradle.internal.execution.steps.CacheStep.executeWithoutCache(CacheStep.java:159)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:72)
        at org.gradle.internal.execution.steps.CacheStep.execute(CacheStep.java:43)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:44)
        at org.gradle.internal.execution.steps.StoreExecutionStateStep.execute(StoreExecutionStateStep.java:33)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:38)
        at org.gradle.internal.execution.steps.RecordOutputsStep.execute(RecordOutputsStep.java:24)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.executeBecause(SkipUpToDateStep.java:92)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.lambda$execute$0(SkipUpToDateStep.java:85)
        at java.util.Optional.map(Optional.java:215)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:55)
        at org.gradle.internal.execution.steps.SkipUpToDateStep.execute(SkipUpToDateStep.java:39)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:76)
        at org.gradle.internal.execution.steps.ResolveChangesStep.execute(ResolveChangesStep.java:37)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:36)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsFinishedStep.execute(MarkSnapshottingInputsFinishedStep.java:26)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:94)
        at org.gradle.internal.execution.steps.ResolveCachingStateStep.execute(ResolveCachingStateStep.java:49)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:79)
        at org.gradle.internal.execution.steps.CaptureStateBeforeExecutionStep.execute(CaptureStateBeforeExecutionStep.java:53)
        at org.gradle.internal.execution.steps.ValidateStep.execute(ValidateStep.java:74)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.lambda$execute$2(SkipEmptyWorkStep.java:78)
        at java.util.Optional.orElseGet(Optional.java:267)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:78)
        at org.gradle.internal.execution.steps.SkipEmptyWorkStep.execute(SkipEmptyWorkStep.java:34)
        at org.gradle.internal.execution.steps.legacy.MarkSnapshottingInputsStartedStep.execute(MarkSnapshottingInputsStartedStep.java:39)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:40)
        at org.gradle.internal.execution.steps.LoadExecutionStateStep.execute(LoadExecutionStateStep.java:28)
        at org.gradle.internal.execution.impl.DefaultWorkExecutor.execute(DefaultWorkExecutor.java:33)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.lambda$call$2(DefaultTransformerInvocationFactory.java:200)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.fireTransformListeners(DefaultTransformerInvocationFactory.java:269)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$300(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:178)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$2.call(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:409)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$CallableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:399)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.call(DefaultBuildOperationExecutor.java:94)
        at org.gradle.internal.operations.DelegatingBuildOperationExecutor.call(DelegatingBuildOperationExecutor.java:36)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.lambda$doTransform$0(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.lambda$withWorkspace$0(ImmutableTransformationWorkspaceProvider.java:81)
        at org.gradle.cache.internal.LockOnDemandCrossProcessCacheAccess.withFileLock(LockOnDemandCrossProcessCacheAccess.java:90)
        at org.gradle.cache.internal.DefaultCacheAccess.withFileLock(DefaultCacheAccess.java:191)
        at org.gradle.cache.internal.DefaultPersistentDirectoryStore.withFileLock(DefaultPersistentDirectoryStore.java:177)
        at org.gradle.cache.internal.DefaultCacheFactory$ReferenceTrackingCache.withFileLock(DefaultCacheFactory.java:201)
        at org.gradle.api.internal.artifacts.transform.ImmutableTransformationWorkspaceProvider.withWorkspace(ImmutableTransformationWorkspaceProvider.java:76)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.lambda$withWorkspace$0(AbstractCachingTransformationWorkspaceProvider.java:55)
        at com.google.common.cache.LocalCache$LocalManualCache$1.load(LocalCache.java:4718)
        at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3445)
        at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2194)
        at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2153)
        at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2043)
        at com.google.common.cache.LocalCache.get(LocalCache.java:3851)
        at com.google.common.cache.LocalCache$LocalManualCache.get(LocalCache.java:4713)
        at org.gradle.api.internal.artifacts.transform.AbstractCachingTransformationWorkspaceProvider.withWorkspace(AbstractCachingTransformationWorkspaceProvider.java:55)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.doTransform(DefaultTransformerInvocationFactory.java:175)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory.access$000(DefaultTransformerInvocationFactory.java:79)
        at org.gradle.api.internal.artifacts.transform.DefaultTransformerInvocationFactory$1.invoke(DefaultTransformerInvocationFactory.java:141)
        at org.gradle.api.internal.artifacts.transform.CacheableInvocation$1.invoke(CacheableInvocation.java:58)
        at org.gradle.api.internal.artifacts.transform.TransformationOperation.run(TransformationOperation.java:39)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:395)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:387)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$1.execute(DefaultBuildOperationExecutor.java:157)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:242)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:150)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor.access$1500(DefaultBuildOperationExecutor.java:49)
        at org.gradle.internal.operations.DefaultBuildOperationExecutor$ParentPreservingQueueWorker.execute(DefaultBuildOperationExecutor.java:437)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runOperation(DefaultBuildOperationQueue.java:231)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.access$600(DefaultBuildOperationQueue.java:173)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:210)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable$1.create(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.work.DefaultWorkerLeaseService.withLocks(DefaultWorkerLeaseService.java:180)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.runBatch(DefaultBuildOperationQueue.java:204)
        at org.gradle.internal.operations.DefaultBuildOperationQueue$WorkerRunnable.run(DefaultBuildOperationQueue.java:178)
        at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:64)
        at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:48)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:56)
        at java.lang.Thread.run(Thread.java:748)
        Suppressed: java.util.concurrent.ExecutionException: com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
                at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:552)
                at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:513)
                at com.google.common.util.concurrent.FluentFuture$TrustedFuture.get(FluentFuture.java:86)
                at com.android.tools.r8.utils.U0.a(:14)
                at com.android.tools.r8.utils.U0.a(:9)
                ... 114 more
        [CIRCULAR REFERENCE:com.android.tools.r8.errors.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)]
Caused by: com.android.tools.r8.a: MethodHandle.invoke and MethodHandle.invokeExact are only supported starting with Android O (--min-api 26)
        at com.android.tools.r8.ir.conversion.N.a(:633)
        at com.android.tools.r8.ir.conversion.N.a(:674)
        at com.android.tools.r8.r.n.A.a(:236)
        at com.android.tools.r8.ir.conversion.o.a(:153)
        at com.android.tools.r8.ir.conversion.N.a(:133)
        at com.android.tools.r8.graph.l.a(:93)
        at com.android.tools.r8.graph.l.a(:71)
        at com.android.tools.r8.graph.l.buildIR(:1)
        at com.android.tools.r8.graph.C0.buildIR(:1)
        at com.android.tools.r8.graph.T.a(:152)
        at com.android.tools.r8.ir.conversion.O.a(:412)
        at com.android.tools.r8.ir.conversion.O.b(:53)
        ... 127 more


``` =||= I updated all mockito packages to 3.5.9 but unfortunately I do get still the same error as above. =||= This still seems to fail for me:
```
Execution failed for task ':mergeDexGplayDebugAndroidTest'.
> Could not resolve all files for configuration ':gplayDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=18, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/tobi/.gradle/caches/transforms-2/files-2.1/66df4f0b18795a51947f8881933478f9/jetified-objenesis-3.1.jar.
         > Error while dexing.

```

I removed     
`androidTestImplementation ""org.mockito:mockito-core:$mockitoVersion""`
and changed:
```
testImplementation (""com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0"") {
        exclude group: ""org.mockito"", module: ""mockito-core""
    }
```

If you want to test it: https://github.com/nextcloud/android/pull/6768
 =||= This is still happening in 3.5.10:

- https://pastebin.ubuntu.com/p/rKzc6MVhBf/
- https://github.com/relaycorp/relaynet-gateway-android/pull/120 =||= @gnarea You are depending on Objenesis 3, which is incompatible with Android <26. Please downgrade to Objenesis 2 and depend on `mockito-android`. For more info, see the context in #2024 =||= @TimvdLippe looks like `mockito-core` still has objenesis 3.1 as a dependency. 
```
+--- project :my-project
|    \--- org.mockito:mockito-core:3.5.10
|         +--- net.bytebuddy:byte-buddy:1.10.13
|         +--- net.bytebuddy:byte-buddy-agent:1.10.13
|         \--- org.objenesis:objenesis:3.1

+--- org.mockito:mockito-android:3.5.10
|    +--- org.mockito:mockito-core:3.5.10 (*)
|    +--- net.bytebuddy:byte-buddy-android:1.10.13
|    |    +--- net.bytebuddy:byte-buddy:1.10.13
|    |    \--- com.jakewharton.android.repackaged:dalvik-dx:9.0.0_r3
|    \--- org.objenesis:objenesis:[2.6, 3.0) -> 3.1
``` =||= @francescocervone That is correct. For non-Android projects, they can use Objenesis 3 just fine. =||= @TimvdLippe it's pretty common for Android projects having some pure JVM Gradle modules, not depending on Android. In that case we must depend on `mockito-core` which depends on Objenesis 3. What do you suggest in that case?

Anyway, even if we don't depend directly on `mockito-core`, we get the same error on `mockito-core` (I suppose that's because `mockito-android` depends on `mockito-core`).
```
> Transform artifact mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) with DexingNoClasspathTransform
D8: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])
Stack trace:
com.android.tools.r8.a: Private interface methods are only supported starting with Android N (--min-api 24): java.lang.Object org.mockito.plugins.MemberAccessor.lambda$newInstance$0(java.lang.reflect.Constructor, java.lang.Object[])

[ stacktrace ]

* What went wrong:
Execution failed for task ':app:mergeExtDexDebugAndroidTest'.
> Could not resolve all files for configuration ':app:debugAndroidTestRuntimeClasspath'.
   > Failed to transform mockito-core-3.5.10.jar (org.mockito:mockito-core:3.5.10) to match attributes {artifactType=android-dex, dexing-enable-desugaring=false, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingNoClasspathTransform: /Users/me/.gradle/caches/transforms-2/files-2.1/9ebcc121d44dc6f808610b5ee83414a2/jetified-mockito-core-3.5.10.jar.
         > Error while dexing.
```

Do you need an example project? =||= @francescocervone That last stacktrace is yet another issue that is new to me, as it complains about private interface methods. That seems to be unrelated to Objenesis. The code in question is https://github.com/mockito/mockito/blob/b6ae6cf12b93ef9445e524224375aab1eb76129d/src/main/java/org/mockito/plugins/MemberAccessor.java#L24-L28

I guess older versions of Android do not support default interface methods. I am not sure what to do here, as that seems to be a problem where Android did not support all features of Java 8. Since Mockito 3 targets Java 8, that would be incompatible with older versions of Android.

Can you use Mockito 2 solely for tests running on older versions of Android? =||= > Can you use Mockito 2 solely for tests running on older versions of Android?

No, because this is a compilation error which depends on the minimum supported Android version. Almost every Android project should use Mockito 2 until android 26 will be the ""generally accepted"" minimum sdk supported version (probably in at least 5 years 😄). =||= @francescocervone What I mean is that you have 2 test suites. 1 testsuite for all tests >= 26 and 1 testsuite for all tests <26. For the testsuite >= 26 you can use Mockito 3 + Objenesis 3, as they support Java 8+. For the testsuite <26 you can use Mockito 2 + Objenesis 2, as they support Java 6+. By splitting up the test suites, you can use modern Mockito for modern Android and older Mockito for older Android. That should work right? =||= Also to reiterate, we have introduced Animal Sniffer to ensure we don't break Android again. We set the target to 24 per https://github.com/mockito/mockito/pull/2006/files#diff-c197962302397baf3a4cc36463dce5eaR104 which seemed the most reasonable cut-off for Java 8 support that Mockito 3 relies on. Therefore, rather than having a cut-off at 26, we would be talking about a cut-off at 24. I am not sure when the Android community moves past that cut-off? =||= @TimvdLippe as far as I know you cannot have 2 test suites in the same android project compiling against 2 Android versions. The minimum Android supported version is a property (`minSdkVersion`) defined in the android project's `build.gradle` file through the Android Gradle Plugin.

> I am not sure when the Android community moves past that cut-off? 

Maybe [this chart](https://gs.statcounter.com/android-version-market-share/mobile-tablet/worldwide) can be helpful? In my case, we currently support Android 21 as min SDK. =||= We could try to update Animal Sniffer to level 21 and see what the effect is. If we can make `mockito-core` compatible with that, without introducing breaking changes for the wider Java ecosystem, then I am open to that. However, when @raphw tried that previously, it turned out that a large portion of `mockito-core` was *already* incompatible. This led us to believe that we would have already broken our users and (since we hadn't received complaints before), 24 felt like the best option.

3.5.0 was a big release and a lot of work went into it to support modern Java, which is probably the reason we have hit numerous issues with it. I wonder how many changes in 3.5.0 affect compatibility compared to previous Mockito releases. Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21? Then we can assess breakages and go from there. =||= Reopening this issue, as I think it is clear by now we are going to need support from developers working in the Android ecosystem on figuring out how to resolve these issues. =||= FYI: at least in my case, the workaround suggested above worked: https://github.com/relaycorp/relaynet-gateway-android/pull/120. But that project doesn't have JVM modules (they're all external deps). We're also supporting API 21+. =||= @TimvdLippe 
>Could you clone Mockito and try to work out what changes are required to make Mockito compatible with 21?

I will. =||= If I remember correctly, types like predicate and function are not available which are part of our public API. This can be fixed but requires breaking public API.  =||= @gnarea , that didn't work for my setup, minSdk = 21:

```
* What went wrong:
Execution failed for task ':app:mergeExtDexDevDebugAndroidTest'.
> Could not resolve all files for configuration ':app:devDebugAndroidTestRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-desugaring-v2=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /Users/azizbekian/.gradle/caches/transforms-2/files-2.1/adb8b362b2ccf145263475708478d34b/jetified-objenesis-3.1.jar.
         > Error while dexing.
``` =||= @raphw If I remember correctly, we are already shipping `Optional` and `Function` in our public API prior to 3.5.0. Since Android tests were passing with 3.4.0, I don't think including these symbols in our public API is problematic. Therefore, I don't think we should be changing these types in our API. (This is also what confuses me the most, as to why some parts work and why other parts don't work, even though Animal Sniffer is claiming nothing should in theory work) =||= I'm not an Android expert. `DefineClassHelper` is only used by specific instantiators that are not used in Android. So ideally this class can be excluded from the compilation by Dex it should solve the problem. =||= @TimvdLippe I played a little bit with mockito and the issue I mentioned [in this comment](https://github.com/mockito/mockito/issues/2007#issuecomment-688321579) is solved by adding in the android project's build.gradle:
```gradle
android {
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
}
```
Android Gradle Plugin 3.0 and higher [supports default interface methods](https://developer.android.com/studio/releases/gradle-plugin#j8-library-desugaring).

---

The objenesis 3.x issue included in `mockito-core` mentioned [here](https://github.com/mockito/mockito/issues/2007#issuecomment-688252464) instead can be avoided by excluding objenesis from `mockito-core` or any library/project depending on `mockito-core`:
```gradle
dependencies {
    androidTestImplementation 'org.mockito:mockito-android:3.5.10'
    androidTestImplementation('org.mockito:mockito-core:3.5.10') {
        exclude group: 'org.objenesis'
    }
    androidTestImplementation(project(':depending-on-mockito-core')) {
        exclude group: 'org.objenesis'
    }
}
```
This workaround is a little bit inconvenient IMHO, but solves the issue. =||= @francescocervone Thanks for the investigation. With regards to your first solution, can we automatically apply that to `mockito-android` or do users of that artifact need to specify it in their `build.gradle`? For the latter, if you solely depend on `mockito-android` you should be good to go. If that is inconvenient, maybe it can be solved in Objenesis 3 instead (not sure if that is possible). =||= @TimvdLippe 
> can we automatically apply that to mockito-android or do users of that artifact need to specify it in their build.gradle?

Users need to specify it in their `build.gradle`.

---

> if you solely depend on mockito-android you should be good to go

True, but I think this ""solution"" is pretty weak. For example, if the project declares [`mockito-kotlin`](https://github.com/nhaarman/mockito-kotlin) dependency, objenesis must be excluded since `mockito-kotlin` depends on `mockito-core`. In general, if the android project depends on some module/project/library depending on `mockito-core`, the workaround must be applied. =||= Again, I'm not sure but can't you just exclude `DefineClassHelper`? That will solve the problem and no need to remove Objenesis. I don't think I can solve it from the Objenesis side. If I can please tell me why? Deploy an objenesis-android excluding these classes will just make everything really messy. =||= @henri-tremblay is there a way to exclude a class from the compilation of a library? How can we exclude `DefineClassHelper`?
Even if we were able to exclude that class: Objenesis is built with Java 8 and it's likely to introduce similar issues in future. This circle will end when one of these classes using some unsupported Java 8 feature, will be part of the Objenesis core and we will not be able to just ""exclude"" it. =||= @TimvdLippe there is a handier workaround for objenesis 3.x, without excluding it from `mockito-core`.
In root `build.gradle` we can add:
```gradle
allprojects {
    configurations.all {
        resolutionStrategy.force 'org.objenesis:objenesis:2.6'
    }
}
``` =||= @francescocervone I don't know. That's why I was saying ""Not an Android expert"" :-) Let me ask around. It's sad to downgrade to Android 2. The other solution would be to split objenesis in 2. One with the core instantiators and one with the exotic ones. Can you hack the objenesis jar to remote this class and just compile with the new jar to tell me if it works? =||= Ok. I had some feedback from @mhausherr. The error is in R8. So we could ignore like this in `proguard-rules.pro`:
```
-assumenosideeffects class org.objenesis.instanciator.util.DefineClassHelper {
    *;
}
``` =||= @henri-tremblay 🤔 It cannot be R8. R8 obfuscates, optimizes and shrinks the code in release builds. It doesn't run in test unless you don't explicitly enable it also for debug builds.
More info here -> https://developer.android.com/studio/build/shrink-code =||= @jakewharton (if I remember correctly, you know a lot more about minification, R8 and problems like this. If that's not the case, please let me know and feel free to ignore this message)

Hey Jake,

Please see the above messages regarding problems with Mockito transitively depending on Objenesis 3 which broke Android compatibility. However, Objenesis compilation broke, despite the class in question not being used in Android tests. As such, the class could be removed with the proguard configuration @henri-tremblay (maintainer of Objenesis) posted.

@francescocervone thinks that is not the appropriate solution, as R8 should not be performing these kind of cleanups.

Sadly I am lacking the knowledge to figure out what is the appropriate solution here and how we can move forward and I had hoped you would be able to help us figuring out.

Thanks in advance for your time and once again, if you prefer not to be involved, feel free to say so and I will try to find another domain expert 😄  =||= @TimvdLippe I didn't say that R8 should not be performing these kind of cleanups. I said that R8 is not involved at all, therefore the R8 rule suggested by @henri-tremblay is not a valid workaround.  =||= @TimvdLippe I created #2053 to fix this issue. With range usage in `strictly` tag, gradle fails to force dependency. I verified with our project. For androidTest, If we just use moctiko-android and exclude mockito-core from mockito-kotlin (or any dependency that has  mockito-core), there shouldnt be any issue. 
This fix still not great but until objenesis supports android sdk < 26, it should work. =||= For anyone who is looking to contribute, please check out the upstream issue at https://github.com/easymock/objenesis/issues/79 =||= I am going to close this issue in favor of https://github.com/easymock/objenesis/issues/79 =||= I have pushed the changes moving some instantiators in a new project. Could you please check if it works? =||= Release 3.2 was done. It should work now. =||= Using version 3.8.0:

```
Execution failed for task ':App:mergeExtDexDebug'.
> Could not resolve all files for configuration ':App:debugRuntimeClasspath'.
   > Failed to transform objenesis-3.1.jar (org.objenesis:objenesis:3.1) to match attributes {artifactType=android-dex, dexing-enable-desugaring=true, dexing-incremental-transform=false, dexing-is-debuggable=true, dexing-min-sdk=21, org.gradle.category=library, org.gradle.libraryelements=jar, org.gradle.status=release, org.gradle.usage=java-runtime}.
      > Execution failed for DexingWithClasspathTransform: /home/circleci/.gradle/caches/modules-2/files-2.1/org.objenesis/objenesis/3.1/48f12deaae83a8dfc3775d830c9fd60ea59bbbca/objenesis-3.1.jar.
         > Error while dexing.
``` =||= Release 3.2 of _Objenesis_ was done, Mockito still needs to have its dependency updated to 3.2. 

This can be worked around by declaring the Objenesis dependency yourself like `implementation 'org.objenesis:objenesis:3.2` and rely on gradle's dependency resolution to go with the 3.2 version instead of the 3.1 currently included with Mockito =||= @PaulKlauser Do you mind sending us a PR which updates the version? =||= https://github.com/mockito/mockito/pull/2249 =||= Could you consider publishing this to Maven as well? =||= Mockito 3.9.0 should be published to Maven Central: https://github.com/mockito/mockito/runs/2288011033?check_suite_focus=true =||= Thanks! It's still at 3.8.0 on [mvnrepository](https://mvnrepository.com/artifact/org.mockito/mockito-core) and [maven](https://search.maven.org/search?q=a:mockito-core) but I suppose it can take several hours for the change to propagate. =||= Yes these systems take a while to obtain the new information. 3.9.0 is published here: https://repo1.maven.org/maven2/org/mockito/mockito-core/3.9.0/ =||= Just mentioning that I had [this exact crash](https://github.com/mockito/mockito/issues/2007#issuecomment-686925445) and upgrading to 3.9.0 from 3.8.0 fixed it.

 However, it might be worth mentioning that any Android project that is just using `JCenter` as a repository will not return the right information for latest version. Android projects need to begin adding `mavenCentral()` as a repository, which previously was unnecessary because JCenter mirrored Maven Central. That's changing and it's because of this that my particular project didn't recognize the 3.9.0 update.
```
repositories {
    google()
    mavenCentral()  <-- many projects need to add this, explicitly
    jcenter()
    maven { url 'https://jitpack.io' }
}
``` =||= https://blog.gradle.org/jcenter-shutdown =||= "Fixes #2007 : Downgrade objenesis version for mockito-android"check list

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [ ] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_

Fixes #2007 

After building, mockito android pom includes objenesis 2.6 while mockito-core has objenesis 3.1.

Locally build version is Tested with our internal project to verify fix. 

```
  androidTestImplementation('com.nhaarman.mockitokotlin2:mockito-kotlin:x.y.z') {
    exclude group: 'org.mockito', module: 'mockito-core'
  }
```

pom of mockito-android.
```
<dependencies>
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <version>3.5.8</version>
      <scope>compile</scope>
      <exclusions>
        <exclusion>
          <artifactId>objenesis</artifactId>
          <groupId>org.objenesis</groupId>
        </exclusion>
      </exclusions>
    </dependency>
    <dependency>
      <groupId>net.bytebuddy</groupId>
      <artifactId>byte-buddy-android</artifactId>
      <version>1.10.13</version>
      <scope>compile</scope>
    </dependency>
    <dependency>
      <groupId>org.objenesis</groupId>
      <artifactId>objenesis</artifactId>
      <version>2.6</version>
      <scope>compile</scope>
    </dependency>
  </dependencies>
```

Side note: I had problem with animal sniffer on release/3.x branch. I had to disable android api 24 signature check to compile the app.
```
org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker:507  Undefined reference (android-api-level-24-7.0_r2): java.lang.instrument.Instrumentation
org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker:507  Undefined reference (android-api-level-24-7.0_r2): boolean java.lang.instrument.Instrumentation.isModifiableClass(Class)
```

Breaking changes solutions for android modules
## Solution 1

If you have motkito-kotlin with mockito-android, exclude mockito-core from mockito-kotlin.

```
        implementation(""com.nhaarman.mockitokotlin2:mockito-kotlin:<version>"") {
            exlcude group: ""org.mockito"", module: ""mockito-core""
        }
```

## Solution 2
Don't add mockito-core with mockito-android

## Solution 3
Use dependency resolution

in root build.gradle

```
subprojects {
  configurations.configureEach {
    resolutionStrategy.eachDependency { details ->
      if (details.requested.group == 'org.objenesis') { 
        details.useVersion '2.6'
      }
    }
  }
}
```


"Sinan Kozakkozaxinan09/01/20, 10:26:25 PM
1802.02034"Exception ""The mock object was garbage collected.""""We received the following exception while running tests using Mockito, either version 3.0.0 or 3.1.0, and I'm filing this bug as requested:
```
Exception in thread ""main"" java.lang.IllegalStateException: The mock object was garbage collected. This should not happen in normal circumstances when using public API. Typically, the test class keeps strong reference to the mock object and it prevents getting the mock collected. Mockito internally needs to keep weak references to mock objects to avoid memory leaks for certain types of MockMaker implementations. If you see this exception using Mockito public API, please file a bug. For more information see issue #1313.
	at org.mockito.internal.invocation.mockref.MockWeakReference.get(MockWeakReference.java:32)
	at org.mockito.internal.invocation.InterceptedInvocation.getMock(InterceptedInvocation.java:106)
	at org.mockito.internal.stubbing.InvocationContainerImpl.invokedMock(InvocationContainerImpl.java:157)
	at org.mockito.internal.stubbing.OngoingStubbingImpl.<init>(OngoingStubbingImpl.java:22)
	at org.mockito.internal.handler.MockHandlerImpl.handle(MockHandlerImpl.java:83)
	at org.mockito.internal.handler.NullResultGuardian.handle(NullResultGuardian.java:29)
	at org.mockito.internal.handler.InvocationNotifierHandler.handle(InvocationNotifierHandler.java:35)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:61)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.doIntercept(MockMethodInterceptor.java:49)
	at org.mockito.internal.creation.bytebuddy.MockMethodInterceptor$DispatcherDefaultingToRealMethod.interceptAbstract(MockMethodInterceptor.java:126)
	at org.mockito.codegen.Runnable$MockitoMock$1840149894.run(Unknown Source)
	at MockitoTest.runTest(MockitoTest.java:13)
	at MockitoTest.main(MockitoTest.java:6)
```

I've reduced the problem to the following test program:
```java
import org.mockito.*;

public class MockitoTest {

  public static void main(String[] args) {
    while (true) runTest();
  }

  private static void runTest() {
    Node list = createList();
    while (list != null) {
      Node next = list.next;
      list.object.run();
      list = next;
    }
  }

  private static Node createList() {
    Node node = null;
    for (int i = 0; i < 1000; ++i) {
      Node next = new Node();
      next.next = node;
      node = next;
    }
    return node;
  }

  private static class Node {
    final Runnable object = Mockito.mock(Runnable.class);
    Node next;
  }
}
```

Whether the problem occurs depends on what exactly the JVM does with the code. It looks like the mock object can be garbage collected between the call to the mocked method and Mockito trying to use the weak reference to it. I'm using AdoptOpenJDK 11.0.3.7-hotspot on Windows. My test program more often than not reproduces the exception within a few seconds, but occasionally it can run forever without failing.""I tried bisecting. This issue happens after this PR.
https://github.com/mockito/mockito/pull/1544 =||= That makes sence, if the `BaseStubbing` instance wraps the mocks and the latter instance is referenced via a weak reference then that latter instance can be GC-ed even if the actual mock instance is still in use.

Thanks for the test, since we both have a test for the ""too weak"" and the ""not sufficiently weak"" mock applications, I hope that I can come up with a scenario that satisfies both conditions. =||= This issue just came up as we tried to upgrade from 3.3.3 to either 3.4.6 or 3.5.9. A large chunk of our unit tests became flaky as a result. Holding onto a strong reference of `MockitoAnnotations.openMocks()` does not seem to have any impact. The only thing that seemed to rectify the issue was creating and retaining a `MockitoSession` like via `MockitoJUnit.rule()` (Using the `MockspressoJUnitRunner` shows the same flakiness as no session is initialized in it). 

Considering that `Mockito.mockitoSession()` is labeled as optional and `@Incubating`, and considering that the junit rule & TestRunner have always been optional historically, this seems like a legitimate bug that will block mockito upgrades in many large codebases (especially those relying on mockito-kotlin's inline `mock()` method). =||= Yes, this needs to be addressed. The alternatives right now are unfortunately a leak or premature discarding. I think a leak is the better alternative, though since you can explicitly clear Mockito's mock store.

The updates within 3 should not have an impact but can have one as a result of changed GC cycles.

I will try to solve this one the next time I find some free time to work on Mockito. =||= Awesome! Thanks so much for addressing this! =||= "Escape mock during method dispatch on mock to avoid premature garbage collection."Under heavy optimization mocks might get garbage collected during the dispatching of a mocked method if the mock instance is not used after this method dispatch. To avoid this, we escape the mock instance during the dispatch to make sure that the GC cannot collect the object.

Fixes #1802."Rafael Winterhalterraphw09/03/20, 10:20:48 PM
1980.02042mockito3.4.0 InlineByteBuddyMockMaker can't work with spring cglib proxy, but ByteBuddyMockMaker works"I upgrade mockito to 3.4.0, and the mockMaker is InlineByteBuddyMockMaker, I use SpyBean to spy a spring bean, and then verify the bean, it throws NotAMockException.
![image](https://user-images.githubusercontent.com/16514353/87801421-4492da80-c882-11ea-8ebc-7f1ee4c80f9c.png)

then i debug, find that the mocks.get(mock) can't find it because the mock is CGLIB proxy, not the original type.

when I use the verify((AppGroupClusterAction) AopTestUtils.getTargetObject(appGroupClusterAction)) to verify. it works.

but the before mockMaker ByteBuddyMockMaker works. so can the InlineByteBuddyMockMaker be compatible with the before？""In this case, the mock is not registered correctly. Mockito has no knowledge of Spring and could not do much about this. Have you adressed this issue with Spring? How do you get hold of this proxied instance? =||= ``` java
@SpringBootTest
@RunWith(SpringJUnit4ClassRunner.class)
@AutoConfigureMockMvc
public class AppGroupClusterActionTest {

  @Autowired
  private MockMvc mockMvc;

  @MockBean
  private AppGroupClusterService appGroupClusterService;

  @SpyBean
  private AppGroupClusterAction appGroupClusterAction;

  @Captor
  private ArgumentCaptor<Object[]> argumentCaptor;

  @Test
  public void testUpdateExecuteAuditSpel() throws Exception {
    ServiceResult mockRes = new ServiceResult();
    mockRes.setSuccess(true);
    doReturn(mockRes).when(appGroupClusterService).update(
        Mockito.any(), Mockito.any(), Mockito.any(),
        Mockito.any(), Mockito.any(), Mockito.any(),
        Mockito.any(), Mockito.any(), Mockito.any());

    mockMvc.perform(
        MockMvcRequestBuilders.post(""/platforms/{platform}/appGroupNames/{appGroupName}/clusterNames/{clusterName}/update"",
            ""platform"", ""appGroupName"", ""clusterName"").content(""{}""))
        .andExpect(status().isOk())
        .andReturn();

//    not work
//    verify(appGroupClusterAction).addAfterAuditResult(argumentCaptor.capture());
    verify((AppGroupClusterAction) AopTestUtils.getTargetObject(appGroupClusterAction)).addAfterAuditResult(argumentCaptor.capture());
    assertArrayEquals(argumentCaptor.getValue(), new Object[]{""appGroupName"", ""platform"", ""clusterName"", ""{}""});

    verify((AppGroupClusterAction) AopTestUtils.getTargetObject(appGroupClusterAction)).addAfterAuditResult(argumentCaptor.capture());
    assertArrayEquals(argumentCaptor.getValue(), new Object[]{""appGroupName"", ""platform"", ""clusterName"", ""{}""});
  }
}
```
this is the code.  I haven't  addressed this issue with Spring, because it works before mockito3.4.0, I don't know whether the mockito need to be compatible with before？ =||= I'd say this issue would need to be adressed in Spring. I assume that the `MockBean` does not actually get the object injected that Mockito issues. =||= I've [taken a look at this from the Spring Boot side of things](https://github.com/spring-projects/spring-boot/issues/22416#issuecomment-670464669). The TL;DR is that Spring's creating a CGLib proxy of the spy that Mockito has created. This proxied spy is passed into `when` and `SubclassByteBuddyMockMaker` correctly identifies that it's a mock while `InlineByteBuddyMockMaker` does not. You can work around the problem by passing the target of Spring's proxy (the Mockito spy) into `when`, but my expectation is that the two mock makers should have the same ability to identify a mock and both should cope with the spy having been proxied.

> I haven't addressed this issue with Spring, because it works before mockito3.4.0

I should also note that, in my testing, this isn't the case. The problem exists with Mockito 3.4, 3.3, and 3.1 with the difference in behaviour depending on whether or not you're using mockito-inline. =||= @raphw @mockitoguy  can you help? =||= Thanks for filing the issue. Could you please provide us a minimal reproduction case that we can clone/download to debug the issue? Thanks in advance! =||= Sorry, I missed this. 

The reason this works with the `SubclassByteBuddyMockMaker` is that Spring proxies the (internal) `MockAccess` interface which we implement in the mock to extract the mock state which is stored in a field of the mock instance. We could just as much had read that field directly to avoid the interface; and this wouldn't even be such a bad idea as it less pollutes the reflection API. But at this time, when we call our internal interface method, it gets redirected to the actual proxy by Spring which is why this functions (accidentally).

The reason it does not work with the `InlineByteBuddyMockMaker` is that we cannot implement interfaces in a class after it has been loaded. The whole premise of the inline mock maker is to keep changes invisible to make use of the retransformation facilities even after class loading. Therefore, we need to identify mocks by the object identity which changes once Spring changes the object. We cannot change this, from our perspective nothing is broken.

From Mockito's side things are simple: if you do not provide ""our"" mock objects to us, we do not guarantee to work, not in the past or in the future. That it does currently work with the subclass mock maker facility is rather accidental and might change in the future. If Spring cannot do anything about this, you'd need to unproxy the objects explicitly. =||= > If Spring cannot do anything about this

As things stand, I don't believe we can as there's no opportunity for Spring to remove its proxy when the proxied spy is passed into `given` or `when`.

I've [wondered in the past](https://github.com/spring-projects/spring-boot/issues/22281#issuecomment-665762299) if Mockito could offer a low-level API that provides a mechanism for pre-processing the instance that's passed in, but concluded that it wouldn't be broadly usable. I'd be delighted if someone who's more familiar with Mockito's internals believes it could be done.

In the absence of some inspiration on the Mockito side, our [current plan](https://github.com/spring-projects/spring-boot/issues/22742) is to make it easier for users to work with both the Spring proxy and the ""bare"" Mockito spy.

 =||= I could certainly add a mechanism for this, it would not create too much overhead and we already have a plugin mechanism in place for it. We would just add a non-operational mechanism by default but allow frameworks to unwrap ""their"" mocks. You could declare this by Mockito's default plugin mechanism.

I will look into adding something like this to Mockito. =||= @wilkinsona

I just added an API. Could you try the *mock-resolver-plugin* branch where Spring would need to implement the `MockResolver` interface as a public class with a default constructor and add a file *org.mockito.plugins.MockResolver* to the *mockito-extensions* folder with the fully qualified class name. The resolver needs to check if a mock instance can be unwrapped and return this instance if applicable.

This way, I think this problem can be solved and Spring stops relying on the implementation detail.  =||= Thanks, @raphw. I think this moves things in the right direction and allows almost all of our Mockito-related tests to pass with the inline mock maker.

I am, however, still seeing a failure when calling `Mockito.reset(T)` with a spy that has been proxied with CGLib. The `MockHandler` is retrieved successfully (as our resolver removes the CGLib proxy) but it then fails in `InlineByteBuddyMockMaker.resetMock(Object, MockHandler, MockCreationSettings)` as the mock that is passed in is still CGLib-proxied. I wonder if reset should resolve the mock and use that both for getting the handler and for calling the mock maker? Something like this:

```java
public static <T> void resetMock(T mock) {
    mock = resolve(mock);
    MockHandler oldHandler = getMockHandler(mock);
    MockCreationSettings settings = oldHandler.getMockSettings();
    MockHandler newHandler = createMockHandler(settings);

    mockMaker.resetMock(mock, newHandler, settings);
}
``` =||= Good catch! I'll fix that up!  =||= I updated the branch and doublechecked that I did not miss anything else. Let me know if this works for you! =||= @wilkinsona Did you have a chance to validate my latest revision of this? =||= Not yet, sorry. I'll try and take another look at it this week. =||= It took a little longer than I'd hoped, but I've just tried the updated branch and all of Spring Boot's Mockito-related tests now pass with the inline mock maker. Thank you. =||= "Mock resolver plugin"Adds a plugin to allow for adding one or multiple mock resolvers. This way, instances that are provided to Mockito's DSL do no longer require to be the actual mocks but can also be proxies of mocks what is something already being applied by frameworks such as Spring.

This works today with the subclass mock maker by accident as we read the mock state from the mock instance via a method which gets proxied. If we ever find a more private appraoch this would however break Spring's Mockito use and it is already broken with the inline mock maker.

By this SPI, Spring could add an unproxy resolver to its Mockito build-up and make it's proxied mocks compatible with Mockito. Other frameworks could use the same approach if desired as this SPI is generic.

Closes #1980"Rafael Winterhalterraphw10/19/20, 01:48:23 PM
2039.02050Failed to mock after upgrading Mockito to version v3.4.x or higher"Upgrading Mockito to version v3.4.x or higher break the test.

```
private val stripe = Mockito.mock(Stripe::class.java)
```

I mock a Stripe SDK class (https://github.com/stripe/stripe-android) in my test.
On Mockito v3.4.x or higher the mock is failed. 

```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: class com.stripe.android.Stripe.
Can not mock final classes with the following settings :
 - explicit serialization (e.g. withSettings().serializable())
 - extra interfaces (e.g. withSettings().extraInterfaces(...))

You are seeing this disclaimer because Mockito is configured to create inlined mocks.
You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.

Underlying exception : java.lang.IllegalArgumentException: Could not create type
```

with trace

```
at com.x.y.z.domain.PaymentUseCaseTest.<init>(PaymentUseCaseTest.kt:24)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at org.junit.platform.commons.util.ReflectionUtils.newInstance(ReflectionUtils.java:511)
	at org.junit.jupiter.engine.execution.ConstructorInvocation.proceed(ConstructorInvocation.java:56)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$ValidatingInvocation.proceed(InvocationInterceptorChain.java:131)
	at org.junit.jupiter.api.extension.InvocationInterceptor.interceptTestClassConstructor(InvocationInterceptor.java:72)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.lambda$invoke$0(ExecutableInvoker.java:105)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain$InterceptedInvocation.proceed(InvocationInterceptorChain.java:106)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.proceed(InvocationInterceptorChain.java:64)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.chainAndInvoke(InvocationInterceptorChain.java:45)
	at org.junit.jupiter.engine.execution.InvocationInterceptorChain.invoke(InvocationInterceptorChain.java:37)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:104)
	at org.junit.jupiter.engine.execution.ExecutableInvoker.invoke(ExecutableInvoker.java:77)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.invokeTestClassConstructor(ClassBasedTestDescriptor.java:333)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateTestClass(ClassBasedTestDescriptor.java:280)
	at org.junit.jupiter.engine.descriptor.ClassTestDescriptor.instantiateTestClass(ClassTestDescriptor.java:77)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.instantiateAndPostProcessTestInstance(ClassBasedTestDescriptor.java:262)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$2(ClassBasedTestDescriptor.java:256)
	at java.util.Optional.orElseGet(Optional.java:267)
	at org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor.lambda$testInstancesProvider$3(ClassBasedTestDescriptor.java:255)
	at org.junit.jupiter.engine.execution.TestInstancesProvider.getTestInstances(TestInstancesProvider.java:29)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.lambda$prepare$0(TestMethodTestDescriptor.java:108)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:107)
	at org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor.prepare(TestMethodTestDescriptor.java:71)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$prepare$1(NodeTestTask.java:107)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.prepare(NodeTestTask.java:107)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:75)
	at java.util.ArrayList.forEach(ArrayList.java:1257)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at java.util.ArrayList.forEach(ArrayList.java:1257)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.invokeAll(SameThreadHierarchicalTestExecutorService.java:38)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$5(NodeTestTask.java:139)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$7(NodeTestTask.java:125)
	at org.junit.platform.engine.support.hierarchical.Node.around(Node.java:135)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.lambda$executeRecursively$8(NodeTestTask.java:123)
	at org.junit.platform.engine.support.hierarchical.ThrowableCollector.execute(ThrowableCollector.java:73)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.executeRecursively(NodeTestTask.java:122)
	at org.junit.platform.engine.support.hierarchical.NodeTestTask.execute(NodeTestTask.java:80)
	at org.junit.platform.engine.support.hierarchical.SameThreadHierarchicalTestExecutorService.submit(SameThreadHierarchicalTestExecutorService.java:32)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutor.execute(HierarchicalTestExecutor.java:57)
	at org.junit.platform.engine.support.hierarchical.HierarchicalTestEngine.execute(HierarchicalTestEngine.java:51)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:248)
	at org.junit.platform.launcher.core.DefaultLauncher.lambda$execute$5(DefaultLauncher.java:211)
	at org.junit.platform.launcher.core.DefaultLauncher.withInterceptedStreams(DefaultLauncher.java:226)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:199)
	at org.junit.platform.launcher.core.DefaultLauncher.execute(DefaultLauncher.java:132)
	at com.intellij.junit5.JUnit5IdeaTestRunner.startRunnerWithArgs(JUnit5IdeaTestRunner.java:69)
	at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)
	at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)
	at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)
Caused by: java.lang.IllegalArgumentException: Could not create type
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:154)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:365)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:174)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:376)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator.mockClass(TypeCachingBytecodeGenerator.java:36)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMockType(InlineByteBuddyMockMaker.java:379)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.doCreateMock(InlineByteBuddyMockMaker.java:339)
	at org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker.createMock(InlineByteBuddyMockMaker.java:318)
	at org.mockito.internal.util.MockUtil.createMock(MockUtil.java:52)
	at org.mockito.internal.MockitoCore.mock(MockitoCore.java:61)
	at org.mockito.Mockito.mock(Mockito.java:1949)
	at org.mockito.Mockito.mock(Mockito.java:1860)
	... 64 more
Caused by: java.lang.VerifyError
	at sun.instrument.InstrumentationImpl.retransformClasses0(Native Method)
	at sun.instrument.InstrumentationImpl.retransformClasses(InstrumentationImpl.java:144)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.triggerRetransformation(InlineBytecodeGenerator.java:260)
	at org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.mockClass(InlineBytecodeGenerator.java:211)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:46)
	at org.mockito.internal.creation.bytebuddy.TypeCachingBytecodeGenerator$1.call(TypeCachingBytecodeGenerator.java:43)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:152)
```

I am interested to know what changes from 3.3.x to 3.4.x that causing this

Edit: Added bytebuddy dump from `-Dnet.bytebuddy.dump` command
dump: [bytebuddy.zip](https://github.com/mockito/mockito/files/5193173/bytebuddy.zip)""Could you run with - Dnet.bytebuddy.dump=/some/folder and add the dumped class files to this ticket?  =||= @raphw Added bytebuddy dump =||= Thanks, this is a very strange error and I struggle to see how Byte Buddy could even emmit this bytecode. The library stores an integer where this should be impossible.

Could you force your Byte Buddy dependency to 1.10.14 manually just to see if this fixes the problem? =||= That is interesting 🤔 
I tried your suggestion and force ByteBuddy to v1.10.14 , unfortunately it does not solve the issue. 
I attach new bytebuddy dump with ByteBuddy to v1.10.14
Dump: [bytebuddy-1.10.14.zip](https://github.com/mockito/mockito/files/5200600/bytebuddy-1.10.14.zip)

Not sure this will help but when I put breakpoint here: 
https://github.com/raphw/byte-buddy/blob/master/byte-buddy-dep/src/main/java/net/bytebuddy/TypeCache.java#L366

Before the exception thrown.The first evaluation of the statement throw the exception but the second evaluation produce something.

First Execution | Second Execution
------------ | -------------
<img width=""586"" alt=""first"" src=""https://user-images.githubusercontent.com/8171574/92712274-b440b580-f359-11ea-864b-b923ae4b3e1a.png"">|<img width=""586"" alt=""second"" src=""https://user-images.githubusercontent.com/8171574/92712280-b7d43c80-f359-11ea-9754-9bac831c181f.png"">

 =||= I reconstructed the problem, the issue is that the method `getAdvancedFraudSignalsEnabled` pushes two values onto the stack but only pops one return value off. This byte code cannot be created by javac and is technically incorrect while the JVM forgives the excess value:

```
  // access flags 0x19
  public final static getAdvancedFraudSignalsEnabled()Z
    GETSTATIC com/stripe/android/Stripe.Companion : Lcom/stripe/android/Stripe$Companion;
    GETSTATIC com/stripe/android/Stripe.advancedFraudSignalsEnabled : Z
    IRETURN
    MAXSTACK = 2
    MAXLOCALS = 0
```
I need to see why this distracts the byte code enhancer but it is certainly fixable. =||= Fixed on master of Byte Buddy, will be fixed in the next release and then updated upstream. =||= Thanks for the explanation and fixes! =||= @raphw it looks like this one is very much related to :  https://github.com/mockito/mockito/issues/2090 ...  =||= "Update Byte Buddy.Fixes #2039, support for Java 16 EA.Rafael Winterhalterraphw09/18/20, 11:47:07 PM
2061.02071Lambda used as ArgumentMatcher causes decamelized lambda name to appear in error message"### Version
Mockito version: 3.5.13

### Description
Relates to #1932

When using a lambda or method reference expression as `ArgumentMatcher` and the matcher fails, the error message contains the lambda / method reference class name in ""decamelized"" form which is rather irritating, e.g.:
> myInterface.doSomething(
    <Mockito test$$ lambda$ 4 8/ 0x 0 0 0 0 0 0 0 8 0 0c 8f 4 4 0>
);

Expected would be that similar to anonymous classes the error output says ""\<custom argument matcher\>"". This could probably be achieved by testing for `Class.isSynthetic()` in `org.mockito.internal.matchers.text.MatcherToString.toString(ArgumentMatcher<?>)` before calling `decamelizeMatcher` there.

### Test case
```java
public class MockitoTest {
    interface MyInterface {
        void doSomething(String s);
    }
    
    private static boolean matches(String s) {
        return false;
    }
    
    public static void main(String[] args) {
        MyInterface mock = mock(MyInterface.class);
        try {
            verify(mock).doSomething(argThat(arg -> false));
        } catch (Error e) {
            e.printStackTrace();
        }
        try {
            verify(mock).doSomething(argThat(MockitoTest::matches));
        } catch (Error e) {
            e.printStackTrace();
        }
        
        // When an anonymous class is used the output is '<custom argument matcher>'
        // (as expected)
        verify(mock).doSomething(argThat(new ArgumentMatcher<>() {
            @Override
            public boolean matches(String argument) {
                return false;
            }
        }));
    }
}
```""> This could probably be achieved by testing for Class.isSynthetic() in

Sounds like a good idea. Do you want to submit a PR? Thanks! =||= Sorry for the delay, have submitted the pull request: #2071
Feedback is appreciated! =||= "Fixes #2061: ArgumentMatcher error messages use lambda class namesFixes #2061Marcono123410/17/20, 02:42:19 PM
2094.02096Refactor Gradle wrapper validation workflow to CI workflowRefactor Gradle wrapper validation workflow to CI workflow. This way, we CI feedback on PRs is cleaner and easier to use.Removed redundant CI workflow"We don't need an explicit workflow for wrapper validation. We already run this as a step in the build:

https://github.com/mockito/mockito/runs/1380756176?check_suite_focus=true#step:4:1

Fixes #2094"Szczepan Fabermockitoguy11/10/20, 04:33:50 PM
2095.02101Implement [ci skip release] in the CI pipeline"Make it possible to skip release when pushing changes to the repo. Our README.md currently documents that we can skip releases by adding ""ci skip release"" keyword to the commit message.

Reference example: https://github.com/shipkit/shipkit-auto-version/commit/7a8ada573e3d8f183b9101b716a261612db30f87"Commit message directives for CI workflow"Added standard idioms for avoiding unnecessary jobs: [skip ci] and [skip release] directives can be added in the commit message, bypassing the CI or release from CI.

Fixes #2095"Szczepan Fabermockitoguy11/12/20, 04:40:08 PM
2097.02103Consider reducing CI execution footprint"Right now we are running CI for:
 - branch pushes
 - PRs

This causes redundant builds to be triggered (example, see actions triggered for PR #2096). Redundant builds clutter the UI (reducing dev experience) and may count against our quota of free open source builds. This issue has been discussed on GH before: https://github.community/t/how-to-trigger-an-action-on-push-or-pull-request-but-not-both/16662

Potential solutions:
 - run only on PRs and pushes the the main dev branch
 - use https://github.com/marketplace/actions/skip-duplicate-actions (adds complexity to the workflow and requires exposing secrets to yet another 3rd party code)"Avoided parallel workflow execution"Avoided parallel execution of the workflow so that:
 - we get better UX (the ""checks"" view in PR does not have duplicated jobs - [example](https://github.com/mockito/mockito/pull/2098))
 - we run less builds (conserves build quota)

We *no longer* run CI for ordinary push to any remote branch. We run CI for pushes to the main dev branch or PRs.

Preventing parallel workflows is reported to GitHub and hopefully it will be resolved eventually: https://github.community/t/prevent-parallel-workflows/16370

Fixes #2097"Szczepan Fabermockitoguy11/14/20, 04:21:37 PM
2110.02111Release process misses commit message tag"https://github.com/mockito/mockito/runs/1447478222#step:4:168

https://github.com/mockito/mockito/commit/fde5abb9f044a6b614eeb6a8c63d25fffe2df210 did contain `[ci maven-central-release]` and therefore should have published."on it =||= Should work now and there is a version in maven central: https://bintray.com/mockito/maven/mockito/3.6.28#central =||= Enabled releases to Maven Central"Fixed the bug with how we controlled Maven Central releases via commit messages.

Testing done: Ran the workflow in a forked repository and b) observed that the information from the commit message is passed to the environment variable.

Fixes #2110"Szczepan Fabermockitoguy11/25/20, 02:54:05 AM
2159.02160Mockito published maven artifact is missing .module files"Around Gradle 5.3 new Gradle metadata was introduced (see https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html) This allows Gradle builds to publish more detail about dependencies than the lagacy maven pom.

Mockito is generating those files, but they aren't getting uploaded to Maven Central see: https://repo1.maven.org/maven2/org/mockito/mockito-junit-jupiter/3.6.28/

However in the [pom.xml](https://repo1.maven.org/maven2/org/mockito/mockito-junit-jupiter/3.6.28/mockito-junit-jupiter-3.6.28.pom) it contains the comment that tells Gradle to check for the `.module` files:

```
<!--
 This module was also published with a richer model, Gradle metadata,  
-->
<!--
 which should be used instead. Do not delete the following line which  
-->
<!--
 is to indicate to Gradle or any Gradle module metadata file consumer  
-->
<!-- that they should prefer consuming it instead. -->
<!-- do_not_remove: published-with-gradle-metadata -->
```

## Solution 1 [Disable metadata](https://docs.gradle.org/current/userguide/publishing_gradle_module_metadata.html#sub:disabling-gmm-publication ): 

This will remove the comment from the pom.xml and so Gradle won't continue to check for the `.module` file.

```
    tasks.withType<GenerateModuleMetadata> {
        enabled = false
    }
```

## Solution 2- Update the maven publishing to include the missing files

This is the better long-term solution. However I don't have a direct recommendation since I don't have experience in that regard and don't know what is mis-configured.


## Why hasn't this been a problem before?

When using `mavenCentral()` as a repo directly, it serves up a 404 for the missing `.module` file and Gradle recovers fine. However when using an internal repository like Artifactory, it is common to configure it to return `403` for missing files to try to obscure data that shouldn't be accessible.

So to reproduce this you would need to use Gradle > 5.3, Using Mockito as a dependency, when using a locked down Maven repository that is configured to serve 403 instead of exposing 404 for missing artifacts."Avoid Gradle module files"Avoid Gradle module files until there is a use case for them. The less we publish the less complexity.

Fixes: #2159

Tested by running `./gradlew publishToMavenLocal' and inspecting files / poms."Szczepan Fabermockitoguy12/30/20, 10:00:34 PM
2173.02179Feature request: Unify order of parameters"Hello,

I just stumbled accross the switched order of the VerificationMode parameter

    org.mockito.Mockito.verify(T, VerificationMode)
vs

    org.mockito.MockedStatic.verify(VerificationMode, Verification)

Is there a reason, the VerificationMode from MockitoStatic is at first position?"No, this might be a simple oversight. @raphw I think we can reverse the order? We would need to add an overload and then deprecate the existing one, which we can delete in Mockito 4.0.0. =||= No, I don't think I had an intention with the order, possibly to have the lambda last what often works better with languages like Kotlin. But I think consistency is the better goal.  =||= @bohni Do you mind sending us a PR with the added method + deprecation? =||= OK, I will take a look =||= Fix reversed order of verify parameters"For consistency the parameters of the method
MockedStatic.verify(VerificationMode, Verification)
have been swapped to
MockedStatic.verify(Verification, VerificationMode)
as this order is already used in
Mockito.verify(T, VerificationMode)

Fixes: #2173

check list

 - [x] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)
 - [x] PR should be motivated, i.e. what does it fix, why, and if relevant how
 - [x] If possible / relevant include an example in the description, that could help all readers
       including project members to get a better picture of the change
 - [x] Avoid other runtime dependencies
 - [x] Meaningful commit history ; intention is important please rebase your commit history so that each
       commit is meaningful and help the people that will explore a change in 2 years
 - [x] The pull request follows coding style
 - [x] Mention `Fixes #<issue number>` in the description _if relevant_
 - [x] At least one commit should mention `Fixes #<issue number>` _if relevant_"Stefan Bohnbohni01/16/21, 10:14:07 AM
2212.02213Please do a release, as we want to use mockito on jdk 17."Hi.
I'm tracking why commons-io will fail ci on JDK17.
After tracking I finally found out the latest mockito relase use ASM 9.0 which cannot handle jdk 17.
As you are using 9.1 now, who can handle JDK17,  I hope we can get it a release...
Thanks!
https://github.com/xenoamess-fork/commons-io/runs/1945142044

check that

 - [ ] The mockito message in the stacktrace have useful information, but it didn't help
 - [ ] The problematic code (if that's possible) is copied here;
       Note that some configuration are impossible to mock via Mockito
 - [ ] Provide versions (mockito / jdk / os / any other relevant information)
 - [ ] Provide a [Short, Self Contained, Correct (Compilable), Example](http://sscce.org) of the issue
       (same as any question on stackoverflow.com)
 - [ ] Read the [contributing guide](https://github.com/mockito/mockito/blob/release/3.x/.github/CONTRIBUTING.md)

"Sadly we can't guarantee yet that Mockito fully works on JDK 17, given that Gradle doesn't support JDK 16+ (https://github.com/mockito/mockito/pull/2211#issuecomment-782884920) That said, I can publish a new release to Maven Central this week, which seems appropriate regardless of JDK 17 support. =||= Publish new minor version to Maven centralCloses #2212Tim van der LippeTimvdLippe02/22/21, 06:55:38 PM
2188.02259"""But invoked here"" lists the invocation parameters"Fixes #2058"# [Codecov](https://codecov.io/gh/mockito/mockito/pull/2188?src=pr&el=h1) Report
> Merging [#2188](https://codecov.io/gh/mockito/mockito/pull/2188?src=pr&el=desc) (cd39a7e) into [release/3.x](https://codecov.io/gh/mockito/mockito/commit/0630886363bb657d965cfa318ea205c79733afee?el=desc) (0630886) will **decrease** coverage by `0.04%`.
> The diff coverage is `75.00%`.

[![Impacted file tree graph](https://codecov.io/gh/mockito/mockito/pull/2188/graphs/tree.svg?width=650&height=150&src=pr&token=MX80sLdeR0)](https://codecov.io/gh/mockito/mockito/pull/2188?src=pr&el=tree)

```diff
@@                Coverage Diff                @@
##             release/3.x    #2188      +/-   ##
=================================================
- Coverage          84.90%   84.85%   -0.05%     
- Complexity          2722     2724       +2     
=================================================
  Files                325      325              
  Lines               8280     8294      +14     
  Branches             989      989              
=================================================
+ Hits                7030     7038       +8     
- Misses               981      984       +3     
- Partials             269      272       +3     
```


| [Impacted Files](https://codecov.io/gh/mockito/mockito/pull/2188?src=pr&el=tree) | Coverage Δ | Complexity Δ | |
|---|---|---|---|
| [...java/org/mockito/internal/exceptions/Reporter.java](https://codecov.io/gh/mockito/mockito/pull/2188/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9leGNlcHRpb25zL1JlcG9ydGVyLmphdmE=) | `91.83% <73.33%> (-0.98%)` | `96.00 <4.00> (+3.00)` | :arrow_down: |
| [...ification/checkers/NumberOfInvocationsChecker.java](https://codecov.io/gh/mockito/mockito/pull/2188/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC92ZXJpZmljYXRpb24vY2hlY2tlcnMvTnVtYmVyT2ZJbnZvY2F0aW9uc0NoZWNrZXIuamF2YQ==) | `100.00% <100.00%> (ø)` | `11.00 <0.00> (ø)` | |
| [...l/creation/bytebuddy/InlineByteBuddyMockMaker.java](https://codecov.io/gh/mockito/mockito/pull/2188/diff?src=pr&el=tree#diff-c3JjL21haW4vamF2YS9vcmcvbW9ja2l0by9pbnRlcm5hbC9jcmVhdGlvbi9ieXRlYnVkZHkvSW5saW5lQnl0ZUJ1ZGR5TW9ja01ha2VyLmphdmE=) | `69.74% <0.00%> (-0.58%)` | `50.00% <0.00%> (-1.00%)` | |

------

[Continue to review full report at Codecov](https://codecov.io/gh/mockito/mockito/pull/2188?src=pr&el=continue).
> **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)
> `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`
> Powered by [Codecov](https://codecov.io/gh/mockito/mockito/pull/2188?src=pr&el=footer). Last update [0630886...cd39a7e](https://codecov.io/gh/mockito/mockito/pull/2188?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).
 =||= It might be a good idea to add similar code for `Reporter#tooManyActualInvocations` =||= @EugeneLesnov I don't have permission to push to your PR. Could you please pull in https://github.com/mockito/mockito/tree/but-invoked-here ? =||= """"But invoked here"" lists the invocation parameters"Supersedes and closes #2188Tim van der LippeTimvdLippe04/07/21, 01:42:29 PM
2266.02267Swallowed illegal access exceptions make it harder to debug modularity-related issues"### Issue Summary

In FieldReader and ReflectionMemberAccessor, if an IllegalAccessException is thrown, it will be suppressed.

At the very least, Mockito should include the original exception. When testing a modular application, it is common to have packages encapsulated by default.

### Stacktrace

In FieldReader, the IllegalAccessException is caught. The exception is re-thrown but the cause is lost.

https://github.com/mockito/mockito/blob/ea000f72444ed4c7e409441aedc3021951b89660/src/main/java/org/mockito/internal/util/reflection/FieldReader.java#L28-L35

Using a debugger, the IllegalAccessException can be observed: https://pastebin.com/GsnU29QV

### Problematic Code

1. Use `module-info` in the project and don't open the package under test to mockito.

2. Use the `MockitoExtension` for JUnit:

```java
@ExtendWith(MockitoExtension.class)
public class MyClassTest {

  private final MyType mock;

  public MyClassTest(@Mock MyType mock) {
    this.mock = mock;
  }
}
```

### Environment
Mockito-Junit-Jupiter 3.9.0
Zulu16.28+11-CA (build 16+36)"Include cause when FieldReader fails to access field"Fixes #2266

Simply passes the exception cause to the thrown MockitoException"A24804/14/21, 02:31:30 PM
2303.02306"""The type is not public and its mock class is loaded by a different class loader"" with a context classloader that delegates""Repro case:
```java
package com.google.clm.mockitobug;

import static org.mockito.Mockito.mock;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * My goal is to create a context classloader that is identical in every way to the existing one,
 * except that it has a different object identity and possibly some extra fields. However, even a
 * basic classloader that always delegates causes problems for mockito.
 */
@RunWith(JUnit4.class)
public final class ClassLoaderTest {

  @Test
  public void mockPackagePrivateInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // fails
    Object unused = mock(PackagePrivate.class);
  }

  @Test
  public void mockPublicInterface() {
    ClassLoader old = Thread.currentThread().getContextClassLoader();
    Thread.currentThread().setContextClassLoader(new ClassLoader(old) {});
    // succeeds
    Object unused = mock(Public.class);
  }

  interface PackagePrivate {}

  public interface Public {}
}
```
Error:
```
org.mockito.exceptions.base.MockitoException: 
Mockito cannot mock this class: interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate.

Mockito can only mock non-private & non-final classes.
If you're not sure why you're getting this error, please report to the mailing list.


Java               : 11
JVM vendor name    : Google Inc.
JVM vendor version : 11.0.10+9-google-release-371350251
JVM name           : OpenJDK 64-Bit Server VM
JVM version        : 11.0.10+9-google-release-371350251
JVM info           : mixed mode, sharing
OS name            : Linux
OS version         : 4.15.0-smp-912.23.0.0


Underlying exception : org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at com.google.clm.mockitobug.ClassLoaderTest.mockPackagePrivateInterface(ClassLoaderTest.java:21)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:57)
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:59)
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
	at org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:81)
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:327)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:84)
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:292)
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:73)
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:290)
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:60)
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:270)
	at org.junit.runners.ParentRunner.run(ParentRunner.java:370)
	at com.google.testing.junit.runner.internal.junit4.CancellableRequestFactory$CancellableRunner.run(CancellableRequestFactory.java:108)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
	at org.junit.runner.JUnitCore.run(JUnitCore.java:115)
	at com.google.testing.junit.runner.junit4.JUnit4Runner.run(JUnit4Runner.java:104)
	at com.google.testing.junit.runner.RunnerShell$2.run(RunnerShell.java:34)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:200)
	at com.google.testing.junit.runner.GoogleTestRunner.runTestsInSuite(GoogleTestRunner.java:184)
	at com.google.testing.junit.runner.GoogleTestRunner.main(GoogleTestRunner.java:137)
Caused by: org.mockito.exceptions.base.MockitoException: 
Cannot create mock for interface com.google.clm.mockitobug.ClassLoaderTest$PackagePrivate

The type is not public and its mock class is loaded by a different class loader.
This can have multiple reasons:
 - You are mocking a class with additional interfaces of another class loader
 - Mockito is loaded by a different class loader than the mocked type (e.g. with OSGi)
 - The thread's context class loader is different than the mock's class loader
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:153)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:366)
	at net.bytebuddy.TypeCache.findOrInsert(TypeCache.java:175)
	at net.bytebuddy.TypeCache$WithInlineExpunction.findOrInsert(TypeCache.java:377)
	... 27 more

```

If mockito actually tried to use the classloader, I think it would work. Since we don't see an interesting exception deep in the stack, my guess is that mockito is doing some extra validation to avoid generating bytecode it thinks would fail.""Rafael, I took a look at this code and it wasn't completely clear to my why we are failing here. The reason that is probably happening is that Mockito first adds the mocked type (https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L97) in this case `PackagePrivate` before adding the current classloader: https://github.com/mockito/mockito/blob/6f9108b833323345bd926f10914224d3e0a11b80/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java#L99

So it looks up the classloader for the mocked type, which is the old classloader. Then it looks up the current classloader (which you changed) and then determines that they don't match. Thus `localMock == false`.

This code landed as part of supporting Java 9+ modules: https://github.com/mockito/mockito/pull/1582 It wouldn't surprise me if there is an edge case we are missing.

Since the new classloader delegates to the former, I would have expected the classes to match and thus pass the checks, but they don't. Presumably because of the classloader equality check. Can we be lenient here and allow for child classloaders to be valid as well? =||= The reason we fail is that a package-private type is not visible outside of its own class loader. Even if we defined the subclass in the same nominal package, if it was loaded by a different class loader, it could not see its superclass. To avoid this visibility issue, we fail before even attempting to create the mock.

We could consider to drop the context class loader if a mocked class is package-private. I am not sure why we need the context class loader to begin with but I assume its related to serialization what tends to be an edge case. =||= I can think of a few options:

1. Ignore the context classloader if the type is package-private. It could have failed anyway... so if it succeeds, might as well reap the benefit.
2. Ignore the package-private restriction for classloaders that are not participating in the java module system, by checking isSealed on the class's package
3. Check to see if the context classloader is a child of the originating classloader, although if a classloader is declaring a parent but not following the delegation patter this might cause a false negative or positive.
4. Just load the stuff as you would, and check each relevant class you load and error if the defining classloader doesn't match. =||= I'll mess around a bit more and report back if I figure out what the issue is. =||= OK, I have a the minimal fix (as in, it will only affect cases that would have broken before):

If the mocked type is a non-interface or non-public, or any of the extra interfaces are non-public, don't include the context classloader in MultipleParentsClassLoader iff the context classloader is a child of the classloader we'd use if it wasn't included.

This fixes my issue, and in general likely fixes cases where a context classloader is set that follows the parent-first delegation pattern. I thought about simply removing the context loader entirely, but test authors who hit this can set and unset it in a try-finally block around their mock calls if necessary, and since there's no comments about why it's included I'd be wary of breaking somebody depending on the existing behavior.

I am going to run this fix through google's internal suite of tests to see if it breaks anything.  =||= 1. The problem is that it might fail delayed upon deserialization. This might be non-trivial to understand and we should document this restriction somewhere. 
2. That won't work. Sealing only affects jars on the same class loader that are defining the same package, this won't work with modules anymore anyways and is taken care of. Package-private classes are however never visible on other class loaders, therefore we must retain the class loader.
3. Is already done to some extend.
4. This is implicit by the multiple parent loader.

I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.  =||= > I think the right approach is to exclude the context loader for package-private classes by default since it will never work and to fail if serialization is enabled in addition.

It's not just package-private classes - mocking a public non-final-non-interface class also poses problems, since that will break stubbing/verification of package-private methods (#796).

My proposed fix:
```java
private static boolean needsSamePackageClassLoader(MockFeatures<?> features) {
  if (!Modifier.isPublic(features.mockedType.getModifiers())
                              || !features.mockedType.isInterface()) {
    // The mocked type is package private or is not an interface and thus may contain package
    // private methods.
    return true;
  }
  for (Class<?> iface : features.interfaces) {
    if (!Modifier.isPublic(iface.getModifiers())) {
      return true;
    }
  }
  return false;
}
...
MultipleParentClassLoader.Builder loaderBuilder = new MultipleParentClassLoader.Builder()
                  .appendMostSpecific(getAllTypes(features.mockedType))
                  .appendMostSpecific(features.interfaces)
                  .appendMostSpecific(MockAccess.class);
ClassLoader contextLoader = currentThread().getContextClassLoader();
boolean shouldIncludeContextLoader = true;
if (needsSamePackageClassLoader(features)) {
    // For the generated class to access package-private methods, it must be defined by the
    // same classloader as its type. All the other added classloaders are required to load
    // the type; if the context classloader is a child of the mocked type's defining
    // classloader, it will break a mock that would have worked. Check if the context class
    // loader is a child of the classloader we'd otherwise use, and possibly skip it.
    ClassLoader candidateLoader = loaderBuilder.build();
    for (ClassLoader parent = contextLoader; parent != null; parent = parent.getParent()) {
      if (parent == candidateLoader) {
        shouldIncludeContextLoader = false;
        break;
      }
    }
}
if (shouldIncludeContextLoader) {
  loaderBuilder = loaderBuilder.appendMostSpecific(contextLoader);
}
ClassLoader classLoader = loaderBuilder.build();
```

The focus was on only changing behavior for cases that failed before. Since we verify that the classloader we define in is a parent of the context classloader, we shouldn't see any problems with serialization, right? Or at least no new problems, as the existing `MultipleParentsClassLoader` relies on `getParent()` to infer the delegation order. =||= @charlesmunger Do you mind opening a PR that includes your proposed fix and adds a regression test for your use case? If all tests pass, I am inclined to merge as-is. If we end up breaking anybody else, we should add regression tests for their use cases and modify the implementation accordingly. =||= "Use the parent classloader if the context classloader is a child of it."This should only affect cases that previously would have thrown an
exception.
Fixes #2303"Charles Mungercharlesmunger05/27/21, 09:35:24 PM
